<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>数组与集合 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">




<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>BunnyAndOak0</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">
              <i class="iconfont icon-home-fill"></i>
              Home</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">
              <i class="iconfont icon-archive-fill"></i>
              Archives</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">
              <i class="iconfont icon-category-fill"></i>
              Categories</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">
              <i class="iconfont icon-tags-fill"></i>
              Tags</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2020-05-20 18:25">
                    May 20, 2020 pm
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    4.7k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    59
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <div align='center'><font size='6'>Java集合梳理</font></div>

<h2 id="数组与集合"><a href="#数组与集合" class="headerlink" title="数组与集合"></a>数组与集合</h2><hr>
<p>说明：</p>
<p>​        集合和数组都是对多个数据进行存储操作的结构，简称java容器，而此时说的<strong>存储</strong>，指的是<strong>内存层面</strong>的存储，不涉及到持久层（.txt, .jpg, .avi, 数据库中等）的存储。</p>
<p>数组在存储多个数据方面的特点：</p>
<ul>
<li>一旦初始化以后，其长度就确定了，<strong>不可修改</strong>。</li>
<li>数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。比如：String[] arr;int[] arr1; Object[] arr2;</li>
<li>数组存储数据的特点：<strong>有序、可重复</strong>。对于无序、不可重复的需求，不能满足。</li>
<li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><hr>
<p>​         <strong>Java集合不能存放基本数据类型</strong> ,Java集合如Map、Set、List等所有集合只能存放引用类型数据，它们都是存放引用类型数据的容器，不能存放如int、long、float、double等基础类型的数据。</p>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><pre><code class="hljs ```java">|----Collection接口：单列集合，用来存储一个一个的对象
         |----List接口：存储有序的、可重复的数据。                        		   |----ArrayList、LinkedList、Vector

         |----Set接口：存储无序的、不可重复的数据  
                |----HashSet、LinkedHashSet、TreeSet

|------Map接口：双列集合，用来存储一对(key - value)一对的数据  
         |----HashMap、LinkedHashMap、TreeMap、Hashtable、Properties</code></pre>

<p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE.png" srcset="/img/loading.gif" alt="集合框架图"></p>
<h3 id="Collection接口中的方法的使用"><a href="#Collection接口中的方法的使用" class="headerlink" title="Collection接口中的方法的使用"></a>Collection接口中的方法的使用</h3><pre><code class="hljs java">Collection coll = <span class="hljs-keyword">new</span> ArrayList();</code></pre>

<ol>
<li>add(Object e):将元素e添加到集合coll中</li>
</ol>
<pre><code class="hljs java">coll.add(<span class="hljs-string">"AA"</span>);
      coll.add(<span class="hljs-string">"BB"</span>);
      coll.add(<span class="hljs-number">123</span>);<span class="hljs-comment">//自动装箱</span>
      coll.add(<span class="hljs-keyword">new</span> Date());</code></pre>

<ol start="2">
<li>size():获取添加的元素的个数</li>
</ol>
<pre><code class="hljs java">System.out.println(coll.size());<span class="hljs-comment">//4</span></code></pre>

<ol start="3">
<li>addAll(Collection coll1):将coll1集合中的元素添加到当前的集合中</li>
</ol>
<pre><code class="hljs java">Collection coll1 = <span class="hljs-keyword">new</span> ArrayList();
     coll1.add(<span class="hljs-number">456</span>);
     coll1.add(<span class="hljs-string">"CC"</span>);
     coll.addAll(coll1);</code></pre>

<ol start="4">
<li>clear():清空集合元素</li>
</ol>
<pre><code class="hljs java">coll.clear();</code></pre>

<ol start="5">
<li>isEmpty():判断当前集合是否为空</li>
</ol>
<pre><code class="hljs ```java">System.out.println(coll.isEmpty());</code></pre>

<ol start="6">
<li>contains(Object obj):判断当前集合中是否包含obj，<strong>在判断时会调用obj对象所在类的equals()。</strong></li>
<li>containsAll(Collection coll1):判断形参coll1中的所有元素是否都存在于当前集合中。</li>
<li>remove(Object obj):从当前集合中移除obj元素。</li>
<li>removeAll(Collection coll1):差集：从当前集合中移除coll1中所有的元素。</li>
<li>retainAll(Collection coll1):交集：获取当前集合和coll1集合的交集，<strong>并返回给当前集合</strong></li>
<li>equals(Object obj):要想返回true，需要当前集合和形参集合的元素都相同。也会调用对象的添加方法，如果其中的元素的有序的要求相同的添加顺序，因为它是有序的，如果其中的元素是无序的就要求内容相同。</li>
<li>hashCode():返回当前对象的哈希值。</li>
<li>集合 —&gt;数组：toArray()</li>
</ol>
<pre><code class="hljs java">Collection coll = <span class="hljs-keyword">new</span> ArrayList();
      coll.add(<span class="hljs-number">123</span>);
      coll.add(<span class="hljs-number">456</span>);
      coll.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Jerry"</span>,<span class="hljs-number">20</span>));
      coll.add(<span class="hljs-keyword">new</span> String(<span class="hljs-string">"Tom"</span>));
      coll.add(<span class="hljs-keyword">false</span>);

Object[] arr = coll.toArray();
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; arr.length;i++)&#123;
          System.out.println(arr[i]);
      &#125;</code></pre>

<ol start="14">
<li>数组 —&gt;集合:调用Arrays类的静态方法asList()</li>
</ol>
<pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"AA"</span>, <span class="hljs-string">"BB"</span>, <span class="hljs-string">"CC"</span>&#125;);
      System.out.println(list);</code></pre>

<ol start="15">
<li>iterator():返回Iterator接口的实例，用于遍历集合元素</li>
</ol>
<p>Tips：</p>
<p>使用Collection集合存储对象，要求对象所属的类满足：<br>向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要<strong>重写equals()</strong>。</p>
<h3 id="关于迭代器"><a href="#关于迭代器" class="headerlink" title="关于迭代器"></a>关于迭代器</h3><p><strong>集合元素的遍历操作，使用迭代器Iterator接口</strong></p>
<p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8E%9F%E7%90%86%E5%9B%BE.png" srcset="/img/loading.gif" alt="迭代器原理图"></p>
<ul>
<li>内部的方法：hasNext() 和  next()</li>
<li>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</li>
<li>内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()</li>
</ul>
<pre><code class="hljs java">Collection coll = <span class="hljs-keyword">new</span> ArrayList();
      coll.add(<span class="hljs-number">123</span>);
      coll.add(<span class="hljs-number">456</span>);
      coll.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Jerry"</span>,<span class="hljs-number">20</span>));
      coll.add(<span class="hljs-keyword">new</span> String(<span class="hljs-string">"Tom"</span>));
      coll.add(<span class="hljs-keyword">false</span>);

      Iterator iterator = coll.iterator();

<span class="hljs-keyword">while</span>(iterator.hasNext())&#123;
          <span class="hljs-comment">//next():①指针下移 ②将下移以后集合位置上的元素返回</span>
          System.out.println(iterator.next());
      &#125;</code></pre>

<p>Tips:错误写法：</p>
<pre><code class="hljs java"><span class="hljs-comment">//错误方式一：原因：next():①指针下移 ②将下移以后集合位置上的元素返回，这样相当于下移了两次</span>
      Iterator iterator = coll.iterator();
      <span class="hljs-keyword">while</span>((iterator.next()) != <span class="hljs-keyword">null</span>)&#123;
          System.out.println(iterator.next());
      &#125;

<span class="hljs-comment">//错误方式二：</span>
      <span class="hljs-comment">//集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</span>
      <span class="hljs-keyword">while</span> (coll.iterator().hasNext())&#123;
          System.out.println(coll.iterator().next());
      &#125;</code></pre>

<p>Iterator中的remove()</p>
<p>Tips:  Iterator <strong>在工作的时候是不允许被迭代的对象被改变的</strong>。不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式。</p>
<p>删除元素：</p>
<pre><code class="hljs java"><span class="hljs-comment">//删除集合中"Tom"</span>
      Iterator iterator = coll.iterator();
      <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;
<span class="hljs-comment">// iterator.remove();</span>
          Object obj = iterator.next();
          <span class="hljs-keyword">if</span>(<span class="hljs-string">"Tom"</span>.equals(obj))&#123;
              iterator.remove();
<span class="hljs-comment">// iterator.remove();</span>
          &#125;</code></pre>

<h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p>jdk5.0新特性–增强for循环：(foreach循环)</p>
<p><strong>内部仍然调用了迭代器。</strong></p>
<pre><code class="hljs java">Collection coll = <span class="hljs-keyword">new</span> ArrayList();
   coll.add(<span class="hljs-number">123</span>);
   coll.add(<span class="hljs-number">456</span>);
   coll.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Jerry"</span>,<span class="hljs-number">20</span>));
   coll.add(<span class="hljs-keyword">new</span> String(<span class="hljs-string">"Tom"</span>));
   coll.add(<span class="hljs-keyword">false</span>);

   <span class="hljs-comment">//for(集合元素的类型 局部变量 : 集合对象)</span>
   
   <span class="hljs-keyword">for</span>(Object obj : coll)&#123;
       System.out.println(obj);
   &#125;</code></pre>

<h2 id="Collection子接口-List接口"><a href="#Collection子接口-List接口" class="headerlink" title="Collection子接口-List接口"></a>Collection子接口-List接口</h2><p><strong>存储有序的，可以重复的数据</strong></p>
<h3 id="List接口框架"><a href="#List接口框架" class="headerlink" title="List接口框架"></a>List接口框架</h3><p>|—-Collection接口：单列集合，用来存储一个一个的对象</p>
<p>​                |—-List接口：存储有序的、可重复的数据。  –&gt;“动态”数组,替换原有的数组</p>
<p>​                            |—-ArrayList：作为List接口的主要实现类；<strong>线程不安全</strong>的，<strong>效率高</strong>；底层使用Object[] elementData存储</p>
<p>​                            |—-LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用<strong>双向链表</strong>存储</p>
<p>​                            |—-Vector：作为List接口的古老实现类；<strong>线程安全</strong>的，<strong>效率低</strong>；底层使用Object[] elementData存储</p>
<h3 id="各种源码分析"><a href="#各种源码分析" class="headerlink" title="各种源码分析"></a>各种源码分析</h3><p> ArrayList的源码分析：</p>
<p>jdk 7情况下</p>
<p>ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData</p>
<p>list.add(123);//elementData[0] = new Integer(123);</p>
<p>…</p>
<p>list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。</p>
<p>默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</p>
<p>结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</p>
<p> jdk 8中ArrayList的变化：</p>
<p>ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组</p>
<p>list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</p>
<p>…</p>
<p>后续的添加和扩容操作与jdk 7 无异。</p>
<p>LinkedList的源码分析：</p>
<p> LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null</p>
<p>list.add(123);//将123封装到Node中，创建了Node对象。</p>
<p>Vector的源码分析：</p>
<p>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</p>
<p>在扩容方面，默认扩容为原来的数组长度的2倍。</p>
<p>ArrayList、LinkedList、Vector三者的异同：</p>
<p>三个类都是实现了List接口，存储数据的特点：存储的都是有序、可重复的数据。</p>
<p>不同，见源码分析</p>
<h3 id="List接口中常用的方法"><a href="#List接口中常用的方法" class="headerlink" title="List接口中常用的方法"></a>List接口中常用的方法</h3><p>void add(int index, Object ele):在index位置插入ele元素<br>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来<br>Object get(int index):获取指定index位置的元素<br>int indexOf(Object obj):返回obj在集合中首次出现的位置<br>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置<br>Object remove(int index):移除指定index位置的元素，并返回此元素<br>Object set(int index, Object ele):设置指定index位置的元素为ele<br>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</p>
<h2 id="Collection的子接口-set接口"><a href="#Collection的子接口-set接口" class="headerlink" title="Collection的子接口-set接口"></a>Collection的子接口-set接口</h2><p>无序性：</p>
<p>不等于随机性，存储的数据在底层数组中，并非按照数组索引的顺序添加，而是根据数据的哈希值决定的，</p>
<p>不可重复性：保证的元素的添加按照equals()判断，不能返回true，ye’jiu’shi’shuo相通的元素只添加一个</p>
<h3 id="Set接口框架"><a href="#Set接口框架" class="headerlink" title="Set接口框架"></a>Set接口框架</h3><p>|—-Collection接口：单列集合，用来存储一个一个的对象</p>
<p>​                |—-Set接口：存储无序的、不可重复的数据   –&gt;高中讲的“集合”</p>
<p>​                                |—-HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值</p>
<p>​                                                |—-LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</p>
<p>​                                |—-TreeSet：可以照添加对象的指定属性，进行排序。</p>
<p>说明：</p>
<p>1、Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。</p>
<p>2、向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()</p>
<p>要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码</p>
<p>重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</p>
<h3 id="元素的添加过程"><a href="#元素的添加过程" class="headerlink" title="元素的添加过程"></a>元素的添加过程</h3><p>我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，<br>        此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断<br>        数组此位置上是否已经有元素：<br>            如果此位置上没有其他元素，则元素a添加成功。 —&gt;情况1<br>            如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：<br>                如果hash值不相同，则元素a添加成功。—&gt;情况2<br>                如果hash值相同，进而需要调用元素a所在类的equals()方法：<br>                       equals()返回true,元素a添加失败<br>                       equals()返回false,则元素a添加成功。—&gt;情况2</p>
<p>对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。<br>    jdk 7 :元素a放到数组中，指向原来的元素。<br>    jdk 8 :原来的元素在数组中，指向元素a<br>    总结：七上八下</p>
<p>HashSet底层：数组+链表的结构。</p>
<p>关于HashSet的使用：</p>
<p>LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个<br>数据和后一个数据。<br>优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet</p>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;
        Set set = <span class="hljs-keyword">new</span> LinkedHashSet();
        set.add(<span class="hljs-number">456</span>);
        set.add(<span class="hljs-number">123</span>);
        set.add(<span class="hljs-number">123</span>);
        set.add(<span class="hljs-string">"AA"</span>);
        set.add(<span class="hljs-string">"CC"</span>);
        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Tom"</span>,<span class="hljs-number">12</span>));
        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Tom"</span>,<span class="hljs-number">12</span>));
        set.add(<span class="hljs-number">129</span>);

        Iterator iterator = set.iterator();
        <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;
            System.out.println(iterator.next());
        &#125;
    &#125;</code></pre>



<p>关于TreeSet的使用</p>
<p>1、向TreeSet中添加的数据，要求是<strong>相同类</strong>的对象。</p>
<p>2、两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator）</p>
<p>3、自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals().</p>
<p>4、定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals().</p>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;
        Comparator com = <span class="hljs-keyword">new</span> Comparator() &#123;
            <span class="hljs-comment">//按照年龄从小到大排列</span>
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;
                <span class="hljs-keyword">if</span>(o1 <span class="hljs-keyword">instanceof</span> User &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> User)&#123;
                    User u1 = (User)o1;
                    User u2 = (User)o2;
                    <span class="hljs-keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());
                &#125;<span class="hljs-keyword">else</span>&#123;
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不匹配"</span>);
                &#125;
            &#125;
        &#125;;

        TreeSet set = <span class="hljs-keyword">new</span> TreeSet(com);
        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Tom"</span>,<span class="hljs-number">12</span>));
        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jerry"</span>,<span class="hljs-number">32</span>));
        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jim"</span>,<span class="hljs-number">2</span>));
        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Mike"</span>,<span class="hljs-number">65</span>));
        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Mary"</span>,<span class="hljs-number">33</span>));
        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jack"</span>,<span class="hljs-number">33</span>));
        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jack"</span>,<span class="hljs-number">56</span>));

        Iterator iterator = set.iterator();
        <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;
            System.out.println(iterator.next());
        &#125;
    &#125;</code></pre>

<h2 id="双列集合框架-Map"><a href="#双列集合框架-Map" class="headerlink" title="双列集合框架-Map"></a>双列集合框架-Map</h2><p>Map接口框架</p>
<p>|—-Map:双列数据，存储key-value对的数据 </p>
<p>​            |—-HashMap:作为Map的<strong>主要实现类</strong>；<strong>线程不安全</strong>的，效率高；<strong>可以存储null的key和value</strong></p>
<pre><code>|----LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率高于HashMap。</code></pre><p>​            |—-TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序。底层使用红黑树</p>
<p>​            |—-Hashtable:作为古老的实现类；<strong>线程安全的</strong>，<strong>效率低</strong>；<strong>不能存储null的key和value</strong></p>
<p>​                                |—-Properties:常用来处理配置文件。key和value都是String类型</p>
<p>存储结构的理解：</p>
<p>Map中的key:无序的、不可重复的，使用Set存储所的key  —&gt; key所在的类要重写equals()和hashCode() （以HashMap为例)<br>Map中的value:无序的、可重复的，使用Collection存储所的value —&gt;value所在的类要重写equals()<br>一个键值对：key-value构成了一个Entry对象。<br>Map中的entry:无序的、不可重复的，使用Set存储所的entry</p>
<h3 id="HashMap的底层原理"><a href="#HashMap的底层原理" class="headerlink" title="HashMap的底层原理"></a>HashMap的底层原理</h3><p>HashMap map = new HashMap():</p>
<p>在实例化以后，底层创建了长度是16的一维数组Entry[] table。</p>
<p>…可能已经执行过多次put…</p>
<p>map.put(key1,value1):</p>
<p>首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</p>
<p>如果此位置上的数据为空，此时的key1-value1添加成功。 —-情况1</p>
<p>如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值：</p>
<p>如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。—-情况2</p>
<p>如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：</p>
<p>如果equals()返回false:此时key1-value1添加成功。—-情况3</p>
<p>如果equals()返回true:使用value1替换value2。补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。</p>
<p>在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p>
<p>jdk8 相较于jdk7在底层实现方面的不同：</p>
<p>new HashMap():底层没有创建一个长度为16的数组</p>
<p>jdk 8底层的数组是：Node[],而非Entry[]</p>
<p>首次调用put()方法时，底层创建长度为16的数组</p>
<p>jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。</p>
<p>形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）<br>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</p>
<p>HashMap底层典型属性的属性的说明：</p>
<p> DEFAULT_INITIAL_CAPACITY : HashMap的默认容量：16</p>
<p>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75</p>
<p>threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12</p>
<p>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8</p>
<p>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p> Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中<br> void putAll(Map m):将m中的所有key-value对存放到当前map中<br> Object remove(Object key)：移除指定key的key-value对，并返回value<br> void clear()：清空当前map中的所有数据<br> 元素查询的操作：<br> Object get(Object key)：获取指定key对应的value<br> boolean containsKey(Object key)：是否包含指定的key<br> boolean containsValue(Object value)：是否包含指定的value<br> int size()：返回map中key-value对的个数<br> boolean isEmpty()：判断当前map是否为空<br> boolean equals(Object obj)：判断当前map和参数对象obj是否相等<br> 元视图操作的方法：<br> Set keySet()：返回所有key构成的Set集合<br> Collection values()：返回所有value构成的Collection集合<br> Set entrySet()：返回所有key-value对构成的Set集合</p>
<pre><code class="hljs java"><span class="hljs-comment">//遍历所有的key-value</span>
        <span class="hljs-comment">//方式一：entrySet()</span>
        Set entrySet = map.entrySet();
        Iterator iterator1 = entrySet.iterator();
        <span class="hljs-keyword">while</span> (iterator1.hasNext())&#123;
            Object obj = iterator1.next();
            <span class="hljs-comment">//entrySet集合中的元素都是entry</span>
            Map.Entry entry = (Map.Entry) obj;
            System.out.println(entry.getKey() + <span class="hljs-string">"----&gt;"</span> + entry.getValue());

        &#125;
        System.out.println();
        <span class="hljs-comment">//方式二：</span>
        Set keySet = map.keySet();
        Iterator iterator2 = keySet.iterator();
        <span class="hljs-keyword">while</span>(iterator2.hasNext())&#123;
            Object key = iterator2.next();
            Object value = map.get(key);
            System.out.println(key + <span class="hljs-string">"====="</span> + value);

        &#125;</code></pre>

<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>向TreeMap中添加key-value，要求key必须是由同一个类创建的对象</p>
<p>因为要按照key进行排序：自然排序 、定制排序</p>
<p>定制排序：</p>
<pre><code class="hljs java"><span class="hljs-comment">//定制排序</span>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;
        TreeMap map = <span class="hljs-keyword">new</span> TreeMap(<span class="hljs-keyword">new</span> Comparator() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;
                <span class="hljs-keyword">if</span>(o1 <span class="hljs-keyword">instanceof</span> User &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> User)&#123;
                    User u1 = (User)o1;
                    User u2 = (User)o2;
                    <span class="hljs-keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());
                &#125;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的类型不匹配！"</span>);
            &#125;
        &#125;);
        User u1 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Tom"</span>,<span class="hljs-number">23</span>);
        User u2 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jerry"</span>,<span class="hljs-number">32</span>);
        User u3 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jack"</span>,<span class="hljs-number">20</span>);
        User u4 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Rose"</span>,<span class="hljs-number">18</span>);

        map.put(u1,<span class="hljs-number">98</span>);
        map.put(u2,<span class="hljs-number">89</span>);
        map.put(u3,<span class="hljs-number">76</span>);
        map.put(u4,<span class="hljs-number">100</span>);

        Set entrySet = map.entrySet();
        Iterator iterator1 = entrySet.iterator();
        <span class="hljs-keyword">while</span> (iterator1.hasNext())&#123;
            Object obj = iterator1.next();
            Map.Entry entry = (Map.Entry) obj;
            System.out.println(entry.getKey() + <span class="hljs-string">"----&gt;"</span> + entry.getValue());

        &#125;
    &#125;</code></pre>

<h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p>Properties:常用来处理配置文件。key和value都是String类型</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;
        FileInputStream fis = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            Properties pros = <span class="hljs-keyword">new</span> Properties();

            fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"jdbc.properties"</span>);
            pros.load(fis);<span class="hljs-comment">//加载流对应的文件</span>

            String name = pros.getProperty(<span class="hljs-string">"name"</span>);
            String password = pros.getProperty(<span class="hljs-string">"password"</span>);

            System.out.println(<span class="hljs-string">"name = "</span> + name + <span class="hljs-string">", password = "</span> + password);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">if</span>(fis != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    fis.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;</code></pre>

<h2 id="Connections工具类的使用"><a href="#Connections工具类的使用" class="headerlink" title="Connections工具类的使用"></a>Connections工具类的使用</h2><p>Connectionos是操作Collection和Map的工具类</p>
<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>reverse(List)：反转 List 中元素的顺序<br>shuffle(List)：对 List 集合元素进行随机排序<br>sort(List)：根据元素的自然顺序对指定 List 集合元素升序排序<br>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序<br>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换<br>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素<br>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素<br>Object min(Collection)<br>Object min(Collection，Comparator)<br>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数<br>void copy(List dest,List src)：将src中的内容复制到dest中<br>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所旧值</p>
<p>说明：ArrayList和HashMap都是线程不安全的，如果程序要求线程安全，我们可以将ArrayList、HashMap转换为线程的。<br>使用synchronizedList(List list） 和 synchronizedMap(Map map）</p>
<pre><code class="hljs java"><span class="hljs-comment">//返回的list1即为线程安全的List</span>
        List list1 = Collections.synchronizedList(list);</code></pre>






            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/05/15/Spring%E2%80%94%E2%80%94%E2%80%941/">
                        <span class="hidden-mobile">Spring———1</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>






<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "数组与集合&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>


















</body>
</html>
