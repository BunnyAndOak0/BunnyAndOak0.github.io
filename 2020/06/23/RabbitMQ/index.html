<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>RabbitMQ - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">




<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>BunnyAndOak0</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">
              <i class="iconfont icon-home-fill"></i>
              Home</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">
              <i class="iconfont icon-archive-fill"></i>
              Archives</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">
              <i class="iconfont icon-category-fill"></i>
              Categories</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">
              <i class="iconfont icon-tags-fill"></i>
              Tags</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2020-06-23 00:53">
                    June 23, 2020 am
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    10.8k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    146
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <div align='center'><font size='6'>RabbitMQ</font></div>

<h2 id="RabbitMQ概述"><a href="#RabbitMQ概述" class="headerlink" title="RabbitMQ概述"></a>RabbitMQ概述</h2><p>​        MQ（Message Quene），消息队列（别名：消息中间件），通过典型的生产者和消费者模型，生产者不断地向消息队列生产消息，消费者不断的从队列中获取消息，通过这种模型实现系统间的<strong>解耦</strong>（<strong>异步</strong>的协作机制）。通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。</p>
<p>使用场景：最终一致性、广播、错峰流控（降低峰值避免瘫痪）等等。</p>
<p>RabbitMQ特点：</p>
<ol>
<li>可靠性：例如：持久化、传输确认、发布确认</li>
<li>灵活的路由</li>
<li>消息的集群</li>
<li>高可用</li>
<li>多种协议</li>
<li>多语言客户端</li>
<li>管理界面</li>
<li>跟踪机制</li>
</ol>
<h2 id="RabbitMQ的常用命令"><a href="#RabbitMQ的常用命令" class="headerlink" title="RabbitMQ的常用命令"></a>RabbitMQ的常用命令</h2><p>启动和关闭</p>
<ol>
<li><p>启动RabbitMQ</p>
<font size = '5'>

<pre><code class="hljs java">rabbitmq-server start &amp;			<span class="hljs-comment">//表示在后台运行</span></code></pre>

</font>
</li>
<li><p>停止服务</p>
<font size = '5'>

<pre><code class="hljs java">rabbitmqctl stop</code></pre>

</font>

</li>
</ol>
<p>插件管理</p>
<p>RabbitMQ启动后可以使用浏览器进入管控台，但是默认情况下，RabbitMQ不想允许直接使用浏览器访问，必须安装插件</p>
<ol>
<li><p>添加插件</p>
<font size = '5'>

<pre><code class="hljs java">rabbitmq-plugins enable &#123;插件名&#125;</code></pre>

</font>

<p>例如：</p>
<font size = '5'>

<pre><code class="hljs java">rabbitmq-plugins enable rabbitmq_management</code></pre>

</font>
</li>
<li><p>删除插件</p>
<font size = '5'>

<pre><code class="hljs java">rabbitmq-plugins disable &#123;插件名&#125;</code></pre>

</font>

<p>例如：</p>
<font size = '5'>

<pre><code class="hljs java">rabbitmq-plugins enable rabbitmq_management</code></pre>

</font>

<p>Tips：需要关闭防火墙或者开放端口</p>
<blockquote>
<p>开启端口：firewall-cmd –zone=public –add-port=15672/tcp –permanent</p>
<p>重新载入配置：firewall-cmd –reload</p>
<p>查看开放的端口号 firewall-cmd –list-all </p>
</blockquote>
</li>
</ol>
<p>用户管理</p>
<p>账号：guest</p>
<p>密码：guest</p>
<p>但是只允许在本机登录，所以需要进行用户管理</p>
<ol>
<li><p>添加用户</p>
<font size = '5'>

<pre><code class="hljs java">rabbitmqctl add_user root root</code></pre>

</font>
</li>
<li><p>删除用户</p>
<font size = '5'>

<pre><code class="hljs java">rabbitmqctl delete user&#123;username&#125;</code></pre>

</font>
</li>
<li><p>修改密码</p>
<font size = '5'>

<pre><code class="hljs java">rabbitmqctl change_password &#123;username&#125; &#123;newpassword&#125; 
<span class="hljs-comment">//例如：</span>
rabbitmqctl change_password root <span class="hljs-number">123456</span></code></pre>

</font>
</li>
<li><p>设置用户角色</p>
<font size = '5'>

<pre><code class="hljs java">rabbitmqctl set_user_tags &#123;username&#125; &#123;tag&#125; 
<span class="hljs-comment">//例如：</span>
rabbitmqctl set_user_tags root administrator</code></pre>

</font>

<p>tag 参 数 表 示 用 户 角 色 取 值 为 ： management 、monitoring 、policymaker、 administrator  </p>
</li>
</ol>
<p>权限管理</p>
<p>可以直接在管控台上设置</p>
<p>vhost管理</p>
<p>是一个命名空间，相当于windows上的文件夹</p>
<p>也可以在管控台上操作</p>
<h2 id="RabbitMQ消息发送和接收"><a href="#RabbitMQ消息发送和接收" class="headerlink" title="RabbitMQ消息发送和接收"></a>RabbitMQ消息发送和接收</h2><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p>​        MQ模型抽象上来讲都是一样的过程，消费者订阅某个队列，生产者创建消息，然后发布到队列中，最后将消息发送到监听的消费者。</p>
<p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/RabbitMQ/%E9%98%9F%E5%88%97.PNG" srcset="/img/loading.gif" alt="队列"></p>
<p>​        RabbitMQ实际是基于AMQP协议的一个开源实现，因此RabbitMQ内部也是AMQP的基本概念。</p>
<p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/RabbitMQ/RabbitMQ%E5%86%85%E9%83%A8.PNG" srcset="/img/loading.gif" alt="RabbitMQ内部"></p>
<p>​        Broker就是消息队列实体，也就是消息服务器，可以有若干了vhost，一个vhost可以有若干个交换机（也就是Exchange）和队列（Queue相当于一个容器），交换机与队列之间有一个绑定的关系</p>
<ol>
<li><p>消息</p>
<p>也就是我们传递的数据，发送过来的消息存入交换机中，交换机与队列进行绑定，消息由消息头和消息体组成，消息体不是不透明的，而消息头包含很多属性，包括routing-key（路由键  重点）</p>
</li>
<li><p>生产者 消息生产者</p>
</li>
<li><p>交换机</p>
<p>用于接收生产者发送的消息，并将消息路由给服务器中的队列</p>
</li>
<li><p>binding</p>
<p>基于路由键将交换机和消息队列连接起来的路由规则</p>
</li>
<li><p>队列</p>
<p>存放消息，先进先出</p>
</li>
<li><p>Connection</p>
<p>网络链接，例如：tcp连接</p>
</li>
<li><p>channel</p>
<p>信道，多路复用连接中的双向通道，可读可写</p>
</li>
<li><p>Customer</p>
<p>消费者，从消息队列中获取消息的客户端应用</p>
</li>
<li><p>virtual host</p>
<p>虚拟主机，表示一批交换器、消息队列和相关对象。命名空间。</p>
</li>
<li><p>Broker</p>
<p>消息服务器，也就是RabbitMQ的一个主进程</p>
</li>
</ol>
<h3 id="AMQP中的消息路由"><a href="#AMQP中的消息路由" class="headerlink" title="AMQP中的消息路由"></a>AMQP中的消息路由</h3><p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/RabbitMQ/AMQP%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%B7%AF%E7%94%B1.PNG" srcset="/img/loading.gif" alt=""></p>
<p>​        生产者把消息发布到 Exchange 上， 消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到 那个队列 </p>
<p>Exchange类型</p>
<p>Exchange 分发消息时根据类型的不同分发策，有四种类型：</p>
<p>direct、fanout、topic、headers 。（ header 不是路由键，而且性能差很多，几乎用不到了）</p>
<p>所谓<strong>单播模式</strong>，就是<strong>精准匹配</strong></p>
<ol>
<li><p>direct类型</p>
<p>​        根据路由键<strong>精准</strong>匹配。RabbitMQ的交换机会根据RoutingKey的内容，精准的匹配将消息发送给与RoutingKey<strong>完全一致</strong>的Queue队列，而队列需要制定好BudingKey必须与RoutingKey<strong>完全一致</strong>。消费者只监听某个队列之后，就可以获取队列中信息的消息。它是完全匹配、 <strong>单播</strong>的模式。 </p>
<p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/RabbitMQ/direct.PNG" srcset="/img/loading.gif" alt="direct"></p>
</li>
</ol>
<ol start="2">
<li><p>fanout类型</p>
<p>​        多播模式（广播模式），消息是一对多的，每一个分发到fanout交换机的消息会被发送到所有绑定的队列上去，fanout不处理路由键，只是简单的将队列绑定到交换机上，每个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。必须要先在消费中监听队列，否则如果消息先发送了，消费者会永远错过这条消息。</p>
<p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/RabbitMQ/fanout.PNG" srcset="/img/loading.gif" alt="fanout"></p>
<p>​    这种模式的交换机适合使用在，一些消息数据不是很重要的应用中，用户接不接收到都问题不大的场景，例如：手机App的消息推送。虽然会丢失消息，但是速度是最快的</p>
</li>
</ol>
<ol start="3">
<li><p>topic类型</p>
<p>​        也是一种一对多的模式，topic交换机通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上，它将路由键和字符串切分成单词，这些单词之间用点隔开，他会识别两个通配符：符号“#”和“<code>*</code>”，“#”匹配<strong>0个</strong>或者多个单词，“<code>*</code>”匹配不多不少<strong>一个</strong>单词。</p>
<p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/RabbitMQ/toipc.PNG" srcset="/img/loading.gif" alt="topic"></p>
<p>也会丢失消息，所以也应该先启动消费者来监听队列。</p>
</li>
</ol>
<h2 id="发送和接收Queue的消息"><a href="#发送和接收Queue的消息" class="headerlink" title="发送和接收Queue的消息"></a>发送和接收Queue的消息</h2><p>发送消息</p>
<ol>
<li><p>创建按普通的maven工程，并添加依赖</p>
<font size='5'>

<pre><code class="hljs java">&lt;dependencies&gt;
    &lt;dependency&gt;
         &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
         &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
         &lt;version&gt;5.1.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>

</font>
</li>
<li><p>实现代码</p>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Send</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">//创建连接工厂</span>
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();
        <span class="hljs-comment">//配置连接的相关信息</span>
        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);  <span class="hljs-comment">//指定ip</span>
        factory.setPort(<span class="hljs-number">5672</span>);      <span class="hljs-comment">//指定端口</span>
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connection = <span class="hljs-keyword">null</span>;   <span class="hljs-comment">//定义连接</span>
        Channel channel = <span class="hljs-keyword">null</span>;         <span class="hljs-comment">//定义通道</span>

        <span class="hljs-keyword">try</span> &#123;
            connection = factory.newConnection();   <span class="hljs-comment">//获取连接</span>
            channel = connection.createChannel();   <span class="hljs-comment">//获取通道</span>
            <span class="hljs-comment">/**</span>
<span class="hljs-comment">             * 声明一个队列</span>
<span class="hljs-comment">             * 参数1：为队列参数取值</span>
<span class="hljs-comment">             * 参数2：是否为持久化的队列</span>
<span class="hljs-comment">             * 参数3：是否排外，如果排外那么这个队列只允许一个消费者监听</span>
<span class="hljs-comment">             * 参数4：时候自动删除，如果为true，表示当队列中没有消息，也没有消费者连接时，会自动删除</span>
<span class="hljs-comment">             * 参数5：为队列的一些属性设置，通常为null</span>
<span class="hljs-comment">             * Tips</span>
<span class="hljs-comment">             * 1.声明队列时，这个队列名称如果已经存在，则放弃声明，如果队列不存在，则会声明一个新的队列</span>
<span class="hljs-comment">             * 2.队列名任意取值，但是需要和消息接收时完全一致</span>
<span class="hljs-comment">             * 3.这行代码是可有可无的，但是一定要在发送消息前确认队列名已经存在于RabbitMQ当中，否则会出现问题</span>
<span class="hljs-comment">             * 也可以在管控台上手动创建一个队列</span>
<span class="hljs-comment">             **/</span>
            channel.queueDeclare(<span class="hljs-string">"myQueue"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
            <span class="hljs-comment">//信息</span>
            String message = <span class="hljs-string">"MyQueue的测试消息！222"</span>;
            <span class="hljs-comment">/*</span>
<span class="hljs-comment">             * 发送消息到MQ</span>
<span class="hljs-comment">             * 参数1：为交换机名称，这里是空字符串表示不使用交换机</span>
<span class="hljs-comment">             * 参数2：为队列名称或者RoutingKey，当指定了交换机名称之后，这个值就是RoutingKey</span>
<span class="hljs-comment">             * 参数3：为消息的属性信息，通常为空即可</span>
<span class="hljs-comment">             * 参数4：具体的消息的字节数组</span>
<span class="hljs-comment">             * 注意：队列名必须要与接收时完全一致</span>
<span class="hljs-comment">             **/</span>
            channel.basicPublish(<span class="hljs-string">""</span>, <span class="hljs-string">"myQueue"</span>, <span class="hljs-keyword">null</span>, message.getBytes(<span class="hljs-string">"utf-8"</span>));

            System.out.println(<span class="hljs-string">"消息发送成功！"</span>);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    channel.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    connection.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

</font>

<p>Tips：注意开放5672的端口</p>
<pre><code class="hljs java">firewall-cmd --zone=<span class="hljs-keyword">public</span> --add-port=<span class="hljs-number">5672</span>/tcp --permanent				<span class="hljs-comment">//开放端口</span>

firewall-cmd --reload			<span class="hljs-comment">//防火墙重启</span></code></pre>

</li>
</ol>
<p>取消息时，一回只能取一个消息，取完消息后，管控台的消息数-1。</p>
<p>接收消息</p>
<ol>
<li><p>创建消息接收的maven工程</p>
<font size = '5'>

<pre><code class="hljs java">&lt;dependencies&gt;
    &lt;dependency&gt;
         &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
         &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
         &lt;version&gt;5.1.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>

</font>
</li>
<li><p>代码实现</p>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">recive</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connection = factory.newConnection();
            channel = connection.createChannel();

            channel.queueDeclare(<span class="hljs-string">"myQueue"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
            <span class="hljs-comment">/*</span>
<span class="hljs-comment">             * 接收消息</span>
<span class="hljs-comment">             * 参数1：为当前消费者需要监听的队列名，队列名必须要与发送时的队列名完全一致，否则接收不到消息</span>
<span class="hljs-comment">             * 参数2：为消息是否自动确认，true表示自动确认接收完消息以后会自动将消息从队列中移除</span>
<span class="hljs-comment">             * 参数3：为消息接收者的标签，用于当多个消费者同时监听同一个队列时用于确认不同消费者，通常为空字符串即可</span>
<span class="hljs-comment">             * 参数4：为消息接收的回调方法，这个方法中具体完成对消息的处理代码</span>
<span class="hljs-comment">             * 注意：使用了basicConsume()方法后，会启动一个线程持续监听队列，如果队列中有信息的数据进入，则会自动接收消息，因此不能关闭</span>
<span class="hljs-comment">             * 连接和通道对象   一旦关闭了可能会造成接收时抛出异常，或者无法接收消息</span>
<span class="hljs-comment">             **/</span>
            channel.basicConsume(<span class="hljs-string">"myQueue"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-string">""</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;
                <span class="hljs-comment">//消息的具体接收和处理方法</span>
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                    String message = <span class="hljs-keyword">new</span> String (body, <span class="hljs-string">"utf-8"</span>);
                    System.out.println(<span class="hljs-string">"消费者收到的消息为：====》"</span> + message);
                &#125;
            &#125;);

        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;

        &#125;
    &#125;
&#125;</code></pre>

</font>

</li>
</ol>
<h2 id="交换机-direct-消息接收发送"><a href="#交换机-direct-消息接收发送" class="headerlink" title="交换机-direct-消息接收发送"></a>交换机-direct-消息接收发送</h2><p>direct发送消息的类</p>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Send</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connection = factory.newConnection();
            channel = connection.createChannel();

            channel.queueDeclare(<span class="hljs-string">"myDirectQueue"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
            <span class="hljs-comment">/*</span>
<span class="hljs-comment">             * 声明一个交换机</span>
<span class="hljs-comment">             * 参数1：为交换机的名称的任意取值</span>
<span class="hljs-comment">             * 参数2：为交换机的类型，有direct、fanout、topic、headers</span>
<span class="hljs-comment">             * 参数3：为是否为持久化的交换机</span>
<span class="hljs-comment">             * 注意：</span>
<span class="hljs-comment">             * 1.声明交换机时，如果交换机已存在会放弃声明，如果不存在则会声明交换机</span>
<span class="hljs-comment">             * 2.这个代码时可有可无的，但是在使用前必须确保此交换机被声明</span>
<span class="hljs-comment">             **/</span>
            channel.exchangeDeclare(<span class="hljs-string">"directExchange"</span>, <span class="hljs-string">"direct"</span>, <span class="hljs-keyword">true</span>);
            <span class="hljs-comment">/*</span>
<span class="hljs-comment">             * 将队列绑定到交换机</span>
<span class="hljs-comment">             * 参数1：为队列名称</span>
<span class="hljs-comment">             * 参数2：为交换机名称</span>
<span class="hljs-comment">             * 参数3：为消息的RoutingKey(就是BindingKey)</span>
<span class="hljs-comment">             * 注意：</span>
<span class="hljs-comment">             * 1.在进行队列和交换机绑定时，必须要确保交换机和队列已经成功的声明</span>
<span class="hljs-comment">             **/</span>
            channel.queueBind(<span class="hljs-string">"myDirectQueue"</span>, <span class="hljs-string">"directExchange"</span>, <span class="hljs-string">"directRoutingKey"</span>);

            String message = <span class="hljs-string">"myDirectQueue的消息！！！"</span>;
            <span class="hljs-comment">/*</span>
<span class="hljs-comment">             * 发送消息到指定的队列</span>
<span class="hljs-comment">             * 参数1：交换机名称</span>
<span class="hljs-comment">             * 参数2：为消息的RoutingKey，如果这个消息的RoutingKey和某个队列与交换机绑定的RoutingKey一致，</span>
<span class="hljs-comment">             * 那么这个消息就会发送到指定的队列中</span>
<span class="hljs-comment">             * 注意：</span>
<span class="hljs-comment">             * 1.发送消息时，必须确保交换机已经创建并且已经争取的绑定到了某个队列</span>
<span class="hljs-comment">             **/</span>
            channel.basicPublish(<span class="hljs-string">"directExchange"</span>, <span class="hljs-string">"directRoutingKey"</span>, <span class="hljs-keyword">null</span>,
                    message.getBytes(<span class="hljs-string">"utf-8"</span>));
            System.out.println(<span class="hljs-string">"myDirectQueue发送消息完成"</span>);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    channel.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    connection.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

</font>

<p>direct接收消息的类</p>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receive</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connection = factory.newConnection();
            channel = connection.createChannel();
            <span class="hljs-comment">//下面三句都是可有可无的，但是在操作前必须确保进行了声明和绑定</span>
            channel.queueDeclare(<span class="hljs-string">"myDirectQueue"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
            channel.exchangeDeclare(<span class="hljs-string">"directExchange"</span>, <span class="hljs-string">"direct"</span>, <span class="hljs-keyword">true</span>);
            channel.queueBind(<span class="hljs-string">"myDirectQueue"</span>, <span class="hljs-string">"directExchange"</span>, <span class="hljs-string">"directRoutingKey"</span>);
            <span class="hljs-comment">/*</span>
<span class="hljs-comment">             * 监听某个队列并获取队列中的数据</span>
<span class="hljs-comment">             * 注意：</span>
<span class="hljs-comment">             * 当前被监听的队列，必须已经存在并正确的绑定到了某个交换机中</span>
<span class="hljs-comment">             **/</span>
            channel.basicConsume(<span class="hljs-string">"myDirectQueue"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-string">""</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                    String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"utf-8"</span>);
                    message += <span class="hljs-string">"direct类型的消费者接收到的消息为："</span> + message;
                    System.out.println(message);
                &#125;
            &#125;);

        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125;

    &#125;
&#125;</code></pre>

</font>



<h2 id="交换机-fanout-消息接收发送"><a href="#交换机-fanout-消息接收发送" class="headerlink" title="交换机-fanout-消息接收发送"></a>交换机-fanout-消息接收发送</h2><p>​        不需要RoutingKey，交换机会用简单的方式，进行与队列的绑定，因此不需要RoutingKey。可以同时有多个队列取绑定交换机。</p>
<p>fanout发送消息的类</p>
<font sieze = '5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Send</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();
        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connection = factory.newConnection();
            channel = connection.createChannel();

            <span class="hljs-comment">/*</span>
<span class="hljs-comment">             * 由于使用fanout类型的交换机，因此消息接收方可能会有多个，因此不建议在消息发送来的时候创建队列，以及绑定交换机，</span>
<span class="hljs-comment">             * 建议在消费者中创建队列并绑定交换机，但是发送消息时，至少应该保证交换机是存在的</span>
<span class="hljs-comment">             **/</span>

<span class="hljs-comment">//            channel.queueDeclare("myFanoutQueue", true, false, false, null);</span>
            channel.exchangeDeclare(<span class="hljs-string">"myFanoutExchange"</span>, <span class="hljs-string">"fanout"</span>, <span class="hljs-keyword">true</span>);
<span class="hljs-comment">//            channel.queueBind("myFanoutQueue", "myFanoutExchange", "fanoutRoutingKey");</span>

            String message = <span class="hljs-string">"fanout类型的消息"</span>;

            channel.basicPublish(<span class="hljs-string">"myFanoutExchange"</span>, <span class="hljs-string">""</span>, <span class="hljs-keyword">null</span>,
                    message.getBytes(<span class="hljs-string">"utf-8"</span>));

            System.out.println(<span class="hljs-string">"发送成功！"</span>);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    channel.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    connection.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

</font>

<p>接收消息的类</p>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receive01</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connection = factory.newConnection();
            channel = connection.createChannel();
            <span class="hljs-comment">/*</span>
<span class="hljs-comment">             * 由于fanout类型的交换机的消息是类似于广播的模式，它不需要绑定RoutingKey</span>
<span class="hljs-comment">             * 而又可能会有很多个消息来接受这个交换机中的数据，因此我们创建队列时，要创建一个随机的队列名称</span>
<span class="hljs-comment">             * 没有参数的queueDeclare方法会创建一个名字为随机的一个队列</span>
<span class="hljs-comment">             * 这个队列的数据是非持久化，是排外的（同时最多只允许一个消费者监听当前队列）、会自动删除（当没有任何消费者监听队列时，</span>
<span class="hljs-comment">             * 这个队列会自动删除）</span>
<span class="hljs-comment">             * getQueue();此方法用于获取随机的队列名称</span>
<span class="hljs-comment">             **/</span>
            String queueName = channel.queueDeclare().getQueue();
            channel.exchangeDeclare(<span class="hljs-string">"myFanoutExchange"</span>, <span class="hljs-string">"fanout"</span>, <span class="hljs-keyword">true</span>);
            <span class="hljs-comment">/*</span>
<span class="hljs-comment">             * 将这个随机的队列绑定到交换机中，由于是fanout类型，因此不需要指定RoutingKey进行绑定</span>
<span class="hljs-comment">             **/</span>
            channel.queueBind(queueName, <span class="hljs-string">"myFanoutExchange"</span>, <span class="hljs-string">""</span>);

            channel.basicConsume(queueName, <span class="hljs-keyword">true</span>, <span class="hljs-string">""</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                    String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"utf-8"</span>);
                    System.out.println(<span class="hljs-string">"fanout011111类型的交换机消息为："</span> + message);
                &#125;
            &#125;);

        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receive02</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connection = factory.newConnection();
            channel = connection.createChannel();

            String queueName = channel.queueDeclare().getQueue();
            channel.exchangeDeclare(<span class="hljs-string">"myFanoutExchange"</span>, <span class="hljs-string">"fanout"</span>, <span class="hljs-keyword">true</span>);
            channel.queueBind(queueName, <span class="hljs-string">"myFanoutExchange"</span>, <span class="hljs-string">""</span>);

            channel.basicConsume(queueName, <span class="hljs-keyword">true</span>, <span class="hljs-string">""</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                    String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"utf-8"</span>);
                    System.out.println(<span class="hljs-string">"fanout022222类型的交换机消息为："</span> + message);
                &#125;
            &#125;);

        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>

</font>

<p>​    此时，Receive01和Receive02都会接收到消息。</p>
<p>Tips</p>
<p>如果此时，fanout交换机指定了和明确的绑定了队列的话</p>
<p>发送：</p>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Send03</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connection = factory.newConnection();
            channel = connection.createChannel();

            channel.queueDeclare(<span class="hljs-string">"myFanoutQueue"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
            channel.exchangeDeclare(<span class="hljs-string">"myFanoutExchange"</span>, <span class="hljs-string">"fanout"</span>, <span class="hljs-keyword">true</span>);
            channel.queueBind(<span class="hljs-string">"myFanoutQueue"</span>, <span class="hljs-string">"myFanoutExchange"</span>,  <span class="hljs-string">"fanoutRoutingKey"</span>);

            String messge = <span class="hljs-string">"fanout类型的消息33333"</span>;

            channel.basicPublish(<span class="hljs-string">"myFanoutExchange"</span>, <span class="hljs-string">"fanoutRoutingKey"</span>, <span class="hljs-keyword">null</span>,
                    messge.getBytes(<span class="hljs-string">"utf-8"</span>));

            System.out.println(<span class="hljs-string">"消息发送成功！"</span>);

        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    channel.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    connection.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;

    &#125;
&#125;</code></pre>

</font>

<p>接收</p>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receive03</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connection = factory.newConnection();
            channel = connection.createChannel();

            <span class="hljs-comment">/*</span>
<span class="hljs-comment">             * 明确指定的队列名称，并进行了与交换机的绑定，可以保证，fanout类型的信息不会丢失，但是没有意义</span>
<span class="hljs-comment">             * 因为消费者可能会很多，因此不能让所有的消费者全部监听一个队列</span>
<span class="hljs-comment">             **/</span>

            channel.queueDeclare(<span class="hljs-string">"myFanoutQueue"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
            channel.exchangeDeclare(<span class="hljs-string">"myFanoutExchange"</span>, <span class="hljs-string">"fanout"</span>, <span class="hljs-keyword">true</span>);
            channel.queueBind(<span class="hljs-string">"myFanoutQueue"</span>, <span class="hljs-string">"myFanoutExchange"</span>, <span class="hljs-string">"fanoutRoutingKey"</span>);

            channel.basicConsume(<span class="hljs-string">"myFanoutQueue"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-string">""</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                    String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"utf-8"</span>);
                    System.out.println(<span class="hljs-string">"fanout33333类型的交换机消息为："</span> + message);
                &#125;
            &#125;);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>

</font>

<p>这时Receive01和Receive02都接收不到消息，只有Receive03可以接收到，不过这样做的话。意义不大。</p>
<h2 id="交换机-topic-消息接收发送"><a href="#交换机-topic-消息接收发送" class="headerlink" title="交换机-topic-消息接收发送"></a>交换机-topic-消息接收发送</h2><p>​        也是一种一对多的模式，但是需要绑定RoutingKey，但是RoutingKey可以使用通配符。</p>
<p>发送者：</p>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Send</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connection = factory.newConnection();
            channel = connection.createChannel();

            channel.exchangeDeclare(<span class="hljs-string">"myTopicExchange"</span>, <span class="hljs-string">"topic"</span>, <span class="hljs-keyword">true</span>);

            String message = <span class="hljs-string">"来自Topic的消息"</span>;

            channel.basicPublish(<span class="hljs-string">"myTopicExchange"</span>, <span class="hljs-string">"aa.bb.cc"</span>, <span class="hljs-keyword">null</span>,
                    message.getBytes(<span class="hljs-string">"utf-8"</span>));
            System.out.println(<span class="hljs-string">"消息已发送！"</span>);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    channel.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    connection.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

</font>

<p>接收者</p>
<p>01</p>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receive01</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connection = factory.newConnection();
            channel = connection.createChannel();

            channel.queueDeclare(<span class="hljs-string">"myTopicQueue01"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
            channel.exchangeDeclare(<span class="hljs-string">"myTopicExchange"</span>, <span class="hljs-string">"topic"</span>, <span class="hljs-keyword">true</span>);
            channel.queueBind(<span class="hljs-string">"myTopicQueue01"</span>, <span class="hljs-string">"myTopicExchange"</span>, <span class="hljs-string">"aa"</span>);

            channel.basicConsume(<span class="hljs-string">"myTopicQueue01"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-string">""</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;

                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                    String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"utf-8"</span>);
                    System.out.println(<span class="hljs-string">"topic011111类型的消费者接收到的消息为："</span> + message);
                &#125;
            &#125;);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;

        &#125;
    &#125;
&#125;</code></pre>

</font>

<p>02</p>
<font size='5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receive02</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connection = factory.newConnection();
            channel = connection.createChannel();

            channel.queueDeclare(<span class="hljs-string">"myTopicQueue02"</span>,<span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
            channel.exchangeDeclare(<span class="hljs-string">"myExchange"</span>, <span class="hljs-string">"topic"</span>, <span class="hljs-keyword">true</span>);
            channel.queueBind(<span class="hljs-string">"myTopicQueue02"</span>, <span class="hljs-string">"myTopicExchange"</span>, <span class="hljs-string">"aa.*"</span>);

            channel.basicConsume(<span class="hljs-string">"myTopicQueue02"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-string">""</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                    String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"utf-8"</span>);
                    System.out.println(<span class="hljs-string">"topic022222类型的消费者接收到的消息为："</span> + message);
                &#125;
            &#125;);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>

</font>

<p>03</p>
<font size='5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receive03</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connection = factory.newConnection();
            channel = connection.createChannel();

            channel.queueDeclare(<span class="hljs-string">"myTopicQueue03"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
            channel.exchangeDeclare(<span class="hljs-string">"myTopicExchange"</span>, <span class="hljs-string">"topic"</span>, <span class="hljs-keyword">true</span>);
            channel.queueBind(<span class="hljs-string">"myTopicQueue03"</span>, <span class="hljs-string">"myTopicExchange"</span>, <span class="hljs-string">"aa.#"</span>);

            channel.basicConsume(<span class="hljs-string">"myTopicQueue03"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-string">""</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                    String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"utf-8"</span>);
                    System.out.println(<span class="hljs-string">"topic033333类型的消费者接收到的消息为："</span> + message);
                &#125;
            &#125;);
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125;

    &#125;
&#125;</code></pre>

</font>        

<p>​        根据绑定时候的，RoutinKey不同，发送时使用的RoutinngKey不同，收到消息的队列也不同，比如：发送时使用的RoutinngKey为aa时01、03可以收到消息，02不行，发送时使用的RoutinngKey为aa.bb时，02、03可以收到，01接收不到，发送时使用的RoutinngKey为aa.bb.cc时，只有03可以收到。</p>
<p>​        这是因为：Topic模式的消息接收时必须要指定 RoutingKey并且可以使用# 和 * 来做统配符号，#表示通配任意一个单词 *表示通配任意多个单词，例如消 费者的 RoutingKey 为 test.#或#.myRoutingKey 都可以获取 RoutingKey 为 test.myRoutingKey 发送者发送的消息  </p>
<h2 id="fanout和topic使用场景的对比"><a href="#fanout和topic使用场景的对比" class="headerlink" title="fanout和topic使用场景的对比"></a>fanout和topic使用场景的对比</h2><p>Topic：也是消息一对多的一种交换机类型，它和fanout都能实现一个消息，同时发送给多个队列。更适合于不同的功能模块来接收同一个消息，例如：商城下单成功后，需要发送消息到队列中，例如：RoutingKey为订单order.success，物流系统监听订单order.wuliu，发票系统监听order.fapiao</p>
<p>Fanout：更适合使用在一个功能不同的进程来获取数据，例如：手机app的消息推送，一个app会有很多用户来进行安装，都会启动一个随机队列来接收着自己的数据。</p>
<p>Topic可以使用一个明确的队列名称，也可以使用一个随机的队列名称，但是如果应用在和订单有关的功能中，建议使用明确的队列名称，并且要求为持久化的。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>与数据库中的事务十分相似，防丢失的策略。</p>
<p>防止消息丢失有两种策略：</p>
<ol>
<li>通过AMQP提供的事务机制实现</li>
<li>使用发送者确认模式</li>
</ol>
<p>事务的实现主要是通过对信道的设置，主要方法：</p>
<ol>
<li>channel.txSelect()  声明启动事务模式</li>
<li>channel.txCommit()  提交事务</li>
<li>channel.txRollback()  回滚事务</li>
</ol>
<h3 id="事务性的消息发送"><a href="#事务性的消息发送" class="headerlink" title="事务性的消息发送"></a>事务性的消息发送</h3><p>发送类</p>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Send</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connecion = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connecion = factory.newConnection();
            channel = connecion.createChannel();

            channel.queueDeclare(<span class="hljs-string">"myTransactionQueue"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
            channel.exchangeDeclare(<span class="hljs-string">"myTransationExchange"</span>, <span class="hljs-string">"direct"</span>, <span class="hljs-keyword">true</span>);
            channel.queueBind(<span class="hljs-string">"myTransactionQueue"</span>, <span class="hljs-string">"myTransationExchange"</span>, <span class="hljs-string">"myTransactionRoutingKey"</span>);

            String message = <span class="hljs-string">"myTransation的消息！！！"</span>;
            channel.basicPublish(<span class="hljs-string">"myTransationExchange"</span>, <span class="hljs-string">"myTransactionRoutingKey"</span>, <span class="hljs-keyword">null</span>,
                    message.getBytes(<span class="hljs-string">"utf-8"</span>));
            <span class="hljs-comment">//模拟程序出现问题</span>
            System.out.println(<span class="hljs-number">10</span> / <span class="hljs-number">0</span>);
            channel.basicPublish(<span class="hljs-string">"myTransationExchange"</span>, <span class="hljs-string">"myTransactionRoutingKey"</span>, <span class="hljs-keyword">null</span>,
                    message.getBytes(<span class="hljs-string">"utf-8"</span>));
            
            System.out.println(<span class="hljs-string">"消息发送成功！"</span>);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    channel.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (connecion != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    connecion.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

</font>

<p>此时就会丢失消息</p>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Send</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connecion = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connecion = factory.newConnection();
            channel = connecion.createChannel();

            channel.queueDeclare(<span class="hljs-string">"myTransactionQueue"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
            channel.exchangeDeclare(<span class="hljs-string">"myTransationExchange"</span>, <span class="hljs-string">"direct"</span>, <span class="hljs-keyword">true</span>);
            channel.queueBind(<span class="hljs-string">"myTransactionQueue"</span>, <span class="hljs-string">"myTransationExchange"</span>, <span class="hljs-string">"myTransactionRoutingKey"</span>);

            String message = <span class="hljs-string">"myTransation的消息！！！"</span>;
            <span class="hljs-comment">/*</span>
<span class="hljs-comment">             * 启动一个事务，启动事务以后所有写入到队列中的消息都必须显示的调用txCommit()提交事务，或者tx.Rollback()回滚事务</span>
<span class="hljs-comment">             **/</span>

            channel.txSelect();
            channel.basicPublish(<span class="hljs-string">"myTransationExchange"</span>, <span class="hljs-string">"myTransactionRoutingKey"</span>, <span class="hljs-keyword">null</span>,
                    message.getBytes(<span class="hljs-string">"utf-8"</span>));
            <span class="hljs-comment">//提交事务，如果调用了tx.Select方法启动了事务，那么必须显式调用事物的提交，否则消息不会真正的写入到队列中</span>
            <span class="hljs-comment">//提交以后，会将内存中的消息写入到队列中，并释放内存</span>
           channel.txCommit();

            System.out.println(<span class="hljs-string">"消息发送成功！"</span>);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    <span class="hljs-comment">//回滚事务，放弃当前事务中没有提交的消息，释放内存</span>
                    channel.txRollback();
                    channel.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (connecion != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    connecion.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

</font>



<h3 id="事务性的消息接收"><a href="#事务性的消息接收" class="headerlink" title="事务性的消息接收"></a>事务性的消息接收</h3><font size='5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receive</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connnection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connnection = factory.newConnection();
            channel = connnection.createChannel();

            channel.queueDeclare(<span class="hljs-string">"myTransactionQueue"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
            channel.exchangeDeclare(<span class="hljs-string">"myTransactionExchange"</span>, <span class="hljs-string">"direct"</span>, <span class="hljs-keyword">true</span>);
            channel.queueBind(<span class="hljs-string">"myTransactionQueue"</span>, <span class="hljs-string">"myTransactionExchange"</span>, <span class="hljs-string">"myTransactionRoutingKey"</span>);
            <span class="hljs-comment">/*</span>
<span class="hljs-comment">             * 开启事务</span>
<span class="hljs-comment">             * 当消费者开启事务之后，即使不做事务的提交依然可以获取队列中的消息，并且将消息从队列中移除掉</span>
<span class="hljs-comment">             * 注意：</span>
<span class="hljs-comment">             * 暂时事务对接收者没有任何的影响</span>
<span class="hljs-comment">             * </span>
<span class="hljs-comment">             **/</span>
            channel.txSelect();
            channel.basicConsume(<span class="hljs-string">"myTransactionQueue"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-string">""</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                    String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"utf-8"</span>);
                    System.out.println(<span class="hljs-string">"myTransaction接收到的消息为："</span> + message);
                &#125;
            &#125;);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125;

    &#125;
&#125;</code></pre>

</font>



<h2 id="发送者确认模式"><a href="#发送者确认模式" class="headerlink" title="发送者确认模式"></a>发送者确认模式</h2><p>​        通过设置Channel进行发送方的确认，确保所有的消息全部发送成功。</p>
<h3 id="普通确认"><a href="#普通确认" class="headerlink" title="普通确认"></a>普通确认</h3><h2 id="普通确认-1"><a href="#普通确认-1" class="headerlink" title="普通确认"></a>普通确认</h2><p>chanel.waitForConfirms();     普通发送者确认模式</p>
<font size ='5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Send</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connecion = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connecion = factory.newConnection();
            channel = connecion.createChannel();

            channel.queueDeclare(<span class="hljs-string">"myConfirmQueue"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
            channel.exchangeDeclare(<span class="hljs-string">"myConfirmExchange"</span>, <span class="hljs-string">"direct"</span>, <span class="hljs-keyword">true</span>);
            channel.queueBind(<span class="hljs-string">"myConfirmQueue"</span>, <span class="hljs-string">"myConfirmExchange"</span>, <span class="hljs-string">"myConfirmRoutingKey"</span>);

            String message = <span class="hljs-string">"myConfirm的消息！！！发送者确认模式的普通情况下"</span>;
            <span class="hljs-comment">//启动发送者确认模式</span>
            channel.confirmSelect();
            channel.basicPublish(<span class="hljs-string">"myConfirmExchange"</span>, <span class="hljs-string">"myConfirmRoutingKey"</span>, <span class="hljs-keyword">null</span>,
                    message.getBytes(<span class="hljs-string">"utf-8"</span>));
            <span class="hljs-comment">//阻塞线程，等待服务器返回响应，用于是否消息是否发送成功，如果服务器确认消息已经发送完成，则返回true，否则返回false</span>
            <span class="hljs-comment">//可以为这个方法指定一个毫秒值用于确定我们需要等待服务器确认的超时时间，如果超过了指定的时间，则会抛出异常，表示服务器出现问题</span>
            <span class="hljs-comment">//需要补发消息，或者将消息缓存到redis中，稍后利用定时任务发送不发，无论是返回false还是抛出异常，消息都有可能发送成功，有可能没有发送成功</span>
            <span class="hljs-comment">//如果要求这个消息一定要发送到队列，例如订单，那么可以采用消息补发（也就是重新发送一次，可以使用递归或利用redis + 定时任务来补发）</span>
            <span class="hljs-keyword">boolean</span> flag = channel.waitForConfirms();
            System.out.println(<span class="hljs-string">"消息发送成功！"</span> + flag);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    channel.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (connecion != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    connecion.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

</font>

<h3 id="批量确认"><a href="#批量确认" class="headerlink" title="批量确认"></a>批量确认</h3><p>一次性确认多条数据</p>
<p>channel.waitForConfirmsOrDie()</p>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Send</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connecion = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connecion = factory.newConnection();
            channel = connecion.createChannel();

            channel.queueDeclare(<span class="hljs-string">"myConfirmOrDieQueue"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
            channel.exchangeDeclare(<span class="hljs-string">"myConfirmOrDieExchange"</span>, <span class="hljs-string">"direct"</span>, <span class="hljs-keyword">true</span>);
            channel.queueBind(<span class="hljs-string">"myConfirmOrDieQueue"</span>, <span class="hljs-string">"myConfirmOrDieExchange"</span>, <span class="hljs-string">"myConfirmOrDieRoutingKey"</span>);

            String message = <span class="hljs-string">"myConfirm的消息！！！发送者批量确认的情况下"</span>;
            <span class="hljs-comment">//启动发送者确认模式</span>
            channel.confirmSelect();
            channel.basicPublish(<span class="hljs-string">"myConfirmOrDieExchange"</span>, <span class="hljs-string">"myConfirmOrDieRoutingKey"</span>, <span class="hljs-keyword">null</span>,
                    message.getBytes(<span class="hljs-string">"utf-8"</span>));
            <span class="hljs-comment">/*</span>
<span class="hljs-comment">             *批量消息确认</span>
<span class="hljs-comment">             * 它会同时向服务器中之前当前通道中发送的所有消息是否已经全部成功写入，不会有任何返回值</span>
<span class="hljs-comment">             * 如果服务器中，有一条消息没有能够成功或向服务器发送确认时，服务器不可访问，都会被认定为消息确认失败 可能有消息没有发送成功</span>
<span class="hljs-comment">             * 需要进行消息的补发策略</span>
<span class="hljs-comment">             * 如果无法向服务器获取确认信息，当前方法就会抛出InterruptedException异常，这时就需要补发消息到队列，这个方法</span>
<span class="hljs-comment">             * 可以指定一个参数，用于等待服务器的确认时间，如果超出这个时间也会抛出异常，表示确认失败需要补发消息</span>
<span class="hljs-comment">             * 注意：</span>
<span class="hljs-comment">             * 批量消息确认的速度比普通的确认速度要快，但是一旦出现了消息补发的情况，我们就不能确定具体是哪条消息没有完成发送</span>
<span class="hljs-comment">             * 需要将本次的发送所有消息全部进行补发</span>
<span class="hljs-comment">             **/</span>
            channel.waitForConfirmsOrDie();
            System.out.println(<span class="hljs-string">"消息发送成功！"</span>);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    channel.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (connecion != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    connecion.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

</font>

<h3 id="异步监听发送者确认模式"><a href="#异步监听发送者确认模式" class="headerlink" title="异步监听发送者确认模式"></a>异步监听发送者确认模式</h3><p>需要写创建一个监听器</p>
<font size='5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Send</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connecion = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connecion = factory.newConnection();
            channel = connecion.createChannel();

            channel.queueDeclare(<span class="hljs-string">"myAddConfirmListenerQueue"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
            channel.exchangeDeclare(<span class="hljs-string">"myAddConfirmListenerExchange"</span>, <span class="hljs-string">"direct"</span>, <span class="hljs-keyword">true</span>);
            channel.queueBind(<span class="hljs-string">"myAddConfirmListenerQueue"</span>, <span class="hljs-string">"myAddConfirmListenerExchange"</span>, <span class="hljs-string">"myAddConfirmListenerRoutingKey"</span>);

            String message = <span class="hljs-string">"myAddConfirmListener的消息！！！异步监听发送者确认模式的普通情况下"</span>;
            <span class="hljs-comment">//启动发送者确认模式</span>
            channel.confirmSelect();
            <span class="hljs-comment">//异步的消息确认监听  需要在发送消息前启动</span>
            channel.addConfirmListener(<span class="hljs-keyword">new</span> ConfirmListener() &#123;
                <span class="hljs-comment">/*</span>
<span class="hljs-comment">                 * 消息确认之后的回调方法</span>
<span class="hljs-comment">                 * 参数1：为被确认的消息的编号，从1自动开始递增用于标记当前是第几个消息</span>
<span class="hljs-comment">                 * 参数2：为当前消息是否同时确认了多个</span>
<span class="hljs-comment">                 * 如果参数为true，表示本次确认同时确认了多条消息，消息小于等于参数1（参数编号）</span>
<span class="hljs-comment">                 * 的所有消息全部被确认，如果为false，则表示只确认了当前编号的消息</span>
<span class="hljs-comment">                 **/</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleAck</span><span class="hljs-params">(<span class="hljs-keyword">long</span> l, <span class="hljs-keyword">boolean</span> b)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                    System.out.println(<span class="hljs-string">"消息被确认---消息编号："</span> + l + <span class="hljs-string">"     是否批量确认了多条："</span> + b);
                &#125;
                <span class="hljs-comment">/*</span>
<span class="hljs-comment">                 * 消息没有确认的回调方法</span>
<span class="hljs-comment">                 * 如果这个方法被执行，表示当前的消息没有被确认，需要进行消息的补发</span>
<span class="hljs-comment">                 * 参数1：为没有被确认的消息的编号，从1自动开始递增用于标记当前是第几个消息</span>
<span class="hljs-comment">                 * 参数2：为当前消息是否没有同时确认多个</span>
<span class="hljs-comment">                 * 注意：</span>
<span class="hljs-comment">                 * 如果参数2为true，表示小于当前编号的所有消息可能都没有发送成功需要进行补发，</span>
<span class="hljs-comment">                 * 如果参数2为false，表示当前编号的消息没有发送成功需要被补发</span>
<span class="hljs-comment">                 **/</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleNack</span><span class="hljs-params">(<span class="hljs-keyword">long</span> l, <span class="hljs-keyword">boolean</span> b)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                    System.out.println(<span class="hljs-string">"消息没有被确认---消息编号："</span> + l + <span class="hljs-string">"     是否批量确认了多条："</span> + b);
                &#125;
            &#125;);

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)&#123;
                channel.basicPublish(<span class="hljs-string">"myAddConfirmListenerExchange"</span>, <span class="hljs-string">"myAddConfirmListenerRoutingKey"</span>, <span class="hljs-keyword">null</span>,
                        message.getBytes(<span class="hljs-string">"utf-8"</span>));
            &#125;

            System.out.println(<span class="hljs-string">"消息发送成功！"</span>);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    channel.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (connecion != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    connecion.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

</font>

<h3 id="消息的消费者确认模式"><a href="#消息的消费者确认模式" class="headerlink" title="消息的消费者确认模式"></a>消息的消费者确认模式</h3><p>（很重要）</p>
<p>手动确认消息的方法：</p>
<blockquote>
<p>basicAck(): 用于肯定确认，multiple 参数用于多个消息确认。 basicRecover()：是路由不成功的消息可以使用 recovery 重新发送到队列中。</p>
<p> basicReject()：是接收端告诉服务器这个消息我拒绝接收,不处理,可以设置是否放回到队列中 还是丢掉，而且只能一次拒绝一个消息,官网中有明确说明不能批量拒绝消息，为解决批量 拒绝消息才有了 basicNack。 basicNack()：可以一次拒绝N条消息，客户端可以设置basicNack方法的multiple参数为true</p>
</blockquote>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receive</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connection = factory.newConnection();
            channel = connection.createChannel();
            <span class="hljs-comment">//下面三句都是可有可无的，但是在操作前必须确保进行了声明和绑定</span>
            channel.queueDeclare(<span class="hljs-string">"myAddConfirmListenerQueue"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
            channel.exchangeDeclare(<span class="hljs-string">"myAddConfirmListenerExchange"</span>, <span class="hljs-string">"direct"</span>, <span class="hljs-keyword">true</span>);
            channel.queueBind(<span class="hljs-string">"myAddConfirmListenerQueue"</span>, <span class="hljs-string">"myAddConfirmListenerExchange"</span>, <span class="hljs-string">"myAddConfirmListenerRoutingKey"</span>);
            <span class="hljs-comment">/*</span>
<span class="hljs-comment">             * 接收消息</span>
<span class="hljs-comment">             * 参数2：为消息的确认机制，true表示自动消息确认，确认之后消息会从队列中被移除，当读取完消息以后，就会自动确认</span>
<span class="hljs-comment">             * 如果为false，表示手动的确认消息</span>
<span class="hljs-comment">             * 注意：</span>
<span class="hljs-comment">             * 1.如果我们只是接收了消息，还没有来得及处理，那么当前应用就崩溃了，或者在进行处理的时候，例如：</span>
<span class="hljs-comment">             * 像在数据库中写入数据，但是这时数据库不可用，那么由于消息是自动确认的，那么这个消息会在接受完之后自动从</span>
<span class="hljs-comment">             * 队列中被删除，这就会丢失消息</span>
<span class="hljs-comment">             *</span>
<span class="hljs-comment">              **/</span>
            channel.basicConsume(<span class="hljs-string">"myAddConfirmListenerQueue"</span>, <span class="hljs-keyword">false</span>, <span class="hljs-string">""</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                    String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"utf-8"</span>);
                    System.out.println(<span class="hljs-string">"消费者处理的消息："</span> + message);
                    <span class="hljs-comment">//获取消息的编号 根据编号来确认消息</span>
                    <span class="hljs-keyword">long</span> tag = envelope.getDeliveryTag();
                    <span class="hljs-comment">//获取当前内部类中的通道</span>
                    Channel c = <span class="hljs-keyword">this</span>.getChannel();
                    <span class="hljs-comment">/*</span>
<span class="hljs-comment">                     * 手动确认消息，确认以后表示当前的消息已经处理成功了，需要从队列中移除</span>
<span class="hljs-comment">                     * 这个方法，应该在当前消息的处理程序全部执行完之后执行</span>
<span class="hljs-comment">                     * 参数1：为消息的序号</span>
<span class="hljs-comment">                     * 参数2：为是否确认多个，如果为true表示需要确认小于等于当前编号的所有消息，false就是单个确认，只确认当前消息</span>
<span class="hljs-comment">                     **/</span>
                    c.basicAck(tag, <span class="hljs-keyword">true</span>);
                &#125;
            &#125;);

        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>

</font>

<ul>
<li><p>如果启动了事务，而消息消费者确认模式为手动确认那么必须要提交事务，否则即使手动确认方法，消息也不会从队列中被移除</p>
<font size = '5'>

</li>
</ul>
<pre><code class="hljs java"><span class="hljs-comment">//启动事务   不提交事务就不会确认</span>
           channel.txSelect();
           channel.basicConsume(<span class="hljs-string">"myAddConfirmListenerQueue"</span>, <span class="hljs-keyword">false</span>, <span class="hljs-string">""</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;
               <span class="hljs-meta">@Override</span>
               <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                   String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"utf-8"</span>);
                   System.out.println(<span class="hljs-string">"消费者处理的消息："</span> + message);
                   <span class="hljs-comment">//获取消息的编号 根据编号来确认消息</span>
                   <span class="hljs-keyword">long</span> tag = envelope.getDeliveryTag();
                   <span class="hljs-comment">//获取当前内部类中的通道</span>
                   Channel c = <span class="hljs-keyword">this</span>.getChannel();
                   <span class="hljs-comment">/*</span>
<span class="hljs-comment">                    * 手动确认消息，确认以后表示当前的消息已经处理成功了，需要从队列中移除</span>
<span class="hljs-comment">                    * 这个方法，应该在当前消息的处理程序全部执行完之后执行</span>
<span class="hljs-comment">                    * 参数1：为消息的序号</span>
<span class="hljs-comment">                    * 参数2：为是否确认多个，如果为true表示需要确认小于等于当前编号的所有消息，false就是单个确认，只确认当前消息</span>
<span class="hljs-comment">                    **/</span>
                   c.basicAck(tag, <span class="hljs-keyword">true</span>);
                   <span class="hljs-comment">//如果启动了事务，而消息消费者确认模式为手动确认那么必须要提交事务，否则即使手动确认方法，消息也不会从队列中被移除</span>
                   c.txCommit();
               &#125;
           &#125;);</code></pre>

</font>

<ul>
<li><p>关于防重复处理</p>
<font size = '5'>

</li>
</ul>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receive</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

        factory.setHost(<span class="hljs-string">"192.168.56.103"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"root"</span>);
        factory.setPassword(<span class="hljs-string">"root"</span>);

        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            connection = factory.newConnection();
            channel = connection.createChannel();
            <span class="hljs-comment">//下面三句都是可有可无的，但是在操作前必须确保进行了声明和绑定</span>
            channel.queueDeclare(<span class="hljs-string">"myAddConfirmListenerQueue"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
            channel.exchangeDeclare(<span class="hljs-string">"myAddConfirmListenerExchange"</span>, <span class="hljs-string">"direct"</span>, <span class="hljs-keyword">true</span>);
            channel.queueBind(<span class="hljs-string">"myAddConfirmListenerQueue"</span>, <span class="hljs-string">"myAddConfirmListenerExchange"</span>, <span class="hljs-string">"myAddConfirmListenerRoutingKey"</span>);
            <span class="hljs-comment">/*</span>
<span class="hljs-comment">             * 接收消息</span>
<span class="hljs-comment">             * 参数2：为消息的确认机制，true表示自动消息确认，确认之后消息会从队列中被移除，当读取完消息以后，就会自动确认</span>
<span class="hljs-comment">             * 如果为false，表示手动的确认消息</span>
<span class="hljs-comment">             * 注意：</span>
<span class="hljs-comment">             * 1.如果我们只是接收了消息，还没有来得及处理，那么当前应用就崩溃了，或者在进行处理的时候，例如：</span>
<span class="hljs-comment">             * 像在数据库中写入数据，但是这时数据库不可用，那么由于消息是自动确认的，那么这个消息会在接受完之后自动从</span>
<span class="hljs-comment">             * 队列中被删除，这就会丢失消息</span>
<span class="hljs-comment">             *</span>
<span class="hljs-comment">              **/</span>
            <span class="hljs-comment">//启动事务   不提交事务就不会确认</span>
            channel.txSelect();
            channel.basicConsume(<span class="hljs-string">"myAddConfirmListenerQueue"</span>, <span class="hljs-keyword">false</span>, <span class="hljs-string">""</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                    <span class="hljs-comment">//获取当前消息是否被接收过一次，如果返回值为false表示之前没有被接收过</span>
                    <span class="hljs-comment">//如果为true表示这个消息之前被接收过，可能也处理完成，因此需要进行消息的防重复处理</span>
                    <span class="hljs-keyword">boolean</span> isRedeliver = envelope.isRedeliver();
                    System.out.println(isRedeliver);
                    <span class="hljs-comment">//获取当前内部类中的通道</span>
                    Channel c = <span class="hljs-keyword">this</span>.getChannel();

                    <span class="hljs-keyword">if</span> (!isRedeliver)&#123;
                        String message = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"utf-8"</span>);
                        System.out.println(<span class="hljs-string">"消费者处理的消息："</span> + message);
                        <span class="hljs-comment">//获取消息的编号 根据编号来确认消息</span>
                        <span class="hljs-keyword">long</span> tag = envelope.getDeliveryTag();
                        <span class="hljs-comment">/*</span>
<span class="hljs-comment">                         * 手动确认消息，确认以后表示当前的消息已经处理成功了，需要从队列中移除</span>
<span class="hljs-comment">                         * 这个方法，应该在当前消息的处理程序全部执行完之后执行</span>
<span class="hljs-comment">                         * 参数1：为消息的序号</span>
<span class="hljs-comment">                         * 参数2：为是否确认多个，如果为true表示需要确认小于等于当前编号的所有消息，false就是单个确认，只确认当前消息</span>
<span class="hljs-comment">                         **/</span>
<span class="hljs-comment">//                    c.basicAck(tag, true);</span>
<span class="hljs-comment">//                    //如果启动了事务，而消息消费者确认模式为手动确认那么必须要提交事务，否则即使手动确认方法，消息也不会从队列中被移除</span>
<span class="hljs-comment">//                    c.txCommit();</span>
                    &#125;<span class="hljs-keyword">else</span>&#123;
                        <span class="hljs-comment">//程序到这里表示，这个消息之前已经被接收过，需要进行放重复处理</span>
                        <span class="hljs-comment">// 例如：查询数据库中是否已经添加了记录或者已经修改过记录</span>
                        <span class="hljs-comment">//如果经过判断这条消息没有被处理完成，则需要重新处理消息，然后确认掉这条消息</span>
                        <span class="hljs-comment">//如果已经处理过了，则直接确认消息即可不需要进行其他处理</span>
                        <span class="hljs-comment">//c.basicAck(tag, false);</span>
                    &#125;

                &#125;
            &#125;);

        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;
            e.printStackTrace();
        &#125;

    &#125;
&#125;</code></pre>

</font>

<h2 id="与SpringBoot的整合"><a href="#与SpringBoot的整合" class="headerlink" title="与SpringBoot的整合"></a>与SpringBoot的整合</h2><p>send和receive的application.properties中，写入配置文件</p>
<font size = '5'>

<pre><code class="hljs java">spring.rabbitmq.host=<span class="hljs-number">192.168</span><span class="hljs-number">.56</span><span class="hljs-number">.103</span>
spring.rabbitmq.port=<span class="hljs-number">5672</span>
spring.rabbitmq.username=root
spring.rabbitmq.password=root</code></pre>

</font>

<p>receive：</p>
<p>配置类</p>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">directExchange</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(<span class="hljs-string">"bootDirectExchange"</span>);
    &#125;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">directQueue</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">"bootDirectQueue"</span>);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">directBingding</span><span class="hljs-params">(Queue directQueue, DirectExchange directExchange)</span></span>&#123;
        <span class="hljs-keyword">return</span> BindingBuilder.bind(directQueue).to(directExchange)
                .with(<span class="hljs-string">"bootDirectRouting"</span>);
    &#125;
&#125;</code></pre>

</font>

<p>实现类</p>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-meta">@Service</span>(<span class="hljs-string">"receiveService"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReceiveServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ReceiveService</span> </span>&#123;
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> AmqpTemplate amqpTemplate;

    <span class="hljs-comment">/*</span>
<span class="hljs-comment">     * 这个接收不是不间断的接收消息，每运行一次这个方法 只能接收一次消息，如果有新的</span>
<span class="hljs-comment">     * 消息进入，不会自动接收消息</span>
<span class="hljs-comment">     * 所以一般不建议使用</span>
<span class="hljs-comment">     **/</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span> </span>&#123;
<span class="hljs-comment">//        String message = (String) amqpTemplate.receiveAndConvert("bootDirectQueue");</span>
<span class="hljs-comment">//        System.out.println("收到的消息为：" + message);</span>
    &#125;

    <span class="hljs-comment">//配置一个消息监听器</span>
    <span class="hljs-comment">/*</span>
<span class="hljs-comment">     * @Param 注解用于标记当前方法是一个RabbitMQ的消息监听方法，</span>
<span class="hljs-comment">     * 作用是持续性的自动接收消息，这个方法不需要手动调用spring会自动运行这个监听</span>
<span class="hljs-comment">     * queues用于指定一个已经存在的队列名，用于进行队列的监听</span>
<span class="hljs-comment">     * 注意：</span>
<span class="hljs-comment">     * 如果当前监听方法正常结束，spring就会正常自动确认消息，如果出现异常就不会确认消息</span>
<span class="hljs-comment">     * 因此在消息处理时，需要做好消息的防重复处理工作</span>
<span class="hljs-comment">     **/</span>
    <span class="hljs-meta">@RabbitListener</span>(queues = &#123;<span class="hljs-string">"bootDirectQueue"</span>&#125;)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">directReceive</span><span class="hljs-params">(String message)</span></span>&#123;
        System.out.println(<span class="hljs-string">"监听器接收的消息："</span> + message);
<span class="hljs-comment">//        System.out.println(10 / 0);</span>
    &#125;

    <span class="hljs-meta">@RabbitListener</span>(bindings = &#123;
            <span class="hljs-meta">@QueueBinding</span>(      <span class="hljs-comment">//@QueueBinding完成队列和交换机的绑定</span>
                    value = <span class="hljs-meta">@Queue</span>(),       <span class="hljs-comment">//@Queue创建一个随机队列，没有指明参数表示创建一个随机队列</span>
                    exchange = <span class="hljs-meta">@Exchange</span>(name = <span class="hljs-string">"bootFanoutExchange"</span>, type = <span class="hljs-string">"fanout"</span>)      <span class="hljs-comment">//@Exchange创建一个的交换机</span>
                        )&#125;)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fanoutReceive01</span><span class="hljs-params">(String message)</span></span>&#123;
        System.out.println(<span class="hljs-string">"fanoutReceive01监听器接收的消息："</span> + message);
    &#125;

    <span class="hljs-meta">@RabbitListener</span>(bindings = &#123;
            <span class="hljs-meta">@QueueBinding</span>(      <span class="hljs-comment">//@QueueBinding完成队列和交换机的绑定</span>
                    value = <span class="hljs-meta">@Queue</span>(),       <span class="hljs-comment">//@Queue创建一个随机队列，没有指明参数表示创建一个随机队列</span>
                    exchange = <span class="hljs-meta">@Exchange</span>(name = <span class="hljs-string">"bootFanoutExchange"</span>, type = <span class="hljs-string">"fanout"</span>)      <span class="hljs-comment">//@Exchange创建一个的交换机</span>
            )&#125;)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fanoutReceive02</span><span class="hljs-params">(String message)</span></span>&#123;
        System.out.println(<span class="hljs-string">"fanoutReceive02监听器接收的消息："</span> + message);
    &#125;

    <span class="hljs-meta">@RabbitListener</span>(bindings = &#123;
            <span class="hljs-meta">@QueueBinding</span>(value = <span class="hljs-meta">@Queue</span>(name = <span class="hljs-string">"bootTopicQueue01"</span>),
                          exchange = <span class="hljs-meta">@Exchange</span>(name = <span class="hljs-string">"bootTopicExchange"</span>, type = <span class="hljs-string">"topic"</span>),
                          key = &#123;<span class="hljs-string">"aa"</span>&#125;)
    &#125;)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">topicReceive01</span><span class="hljs-params">(String message)</span></span>&#123;
        System.out.println(<span class="hljs-string">"topic01消费者 --- routingkey为aa："</span> + message);
    &#125;

    <span class="hljs-meta">@RabbitListener</span>(bindings = &#123;
            <span class="hljs-meta">@QueueBinding</span>(value = <span class="hljs-meta">@Queue</span>(name = <span class="hljs-string">"bootTopicQueue02"</span>),
                          exchange = <span class="hljs-meta">@Exchange</span>(name = <span class="hljs-string">"bootTopicExchange"</span>, type = <span class="hljs-string">"topic"</span>),
                          key = &#123;<span class="hljs-string">"aa.*"</span>&#125;)
    &#125;)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">topicReceive02</span><span class="hljs-params">(String message)</span></span>&#123;
        System.out.println(<span class="hljs-string">"topic02消费者 --- routingkey为aa.*："</span> + message);
    &#125;

    <span class="hljs-meta">@RabbitListener</span>(bindings = &#123;
            <span class="hljs-meta">@QueueBinding</span>(value = <span class="hljs-meta">@Queue</span>(name = <span class="hljs-string">"bootTopicQueue03"</span>),
                          exchange = <span class="hljs-meta">@Exchange</span>(name = <span class="hljs-string">"bootTopicExchange"</span>, type = <span class="hljs-string">"topic"</span>),
                          key = &#123;<span class="hljs-string">"aa.#"</span>&#125;)
    &#125;)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">topicReceive03</span><span class="hljs-params">(String message)</span></span>&#123;
        System.out.println(<span class="hljs-string">"topic03消费者 --- routingkey为aa.#："</span> + message);
    &#125;

&#125;</code></pre>

</font>

<p>主类</p>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqSpringbootReceiveApplication</span> </span>&#123;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		ConfigurableApplicationContext ac = SpringApplication.run(RabbitmqSpringbootReceiveApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;
		ReceiveService rs = (ReceiveService) ac.getBean(<span class="hljs-string">"receiveService"</span>);
<span class="hljs-comment">//		rs.receive();</span>
		<span class="hljs-comment">//使用了消息监听器接收消息，那么就不需要调用接收方法来接收消息</span>
	&#125;

&#125;</code></pre>

</font>

<p>send：</p>
<p>配置类</p>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;
    <span class="hljs-comment">//配置一个Direct类型的交换机</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">directExchange</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(<span class="hljs-string">"bootDirectExchange"</span>);
    &#125;
    <span class="hljs-comment">//配置一个队列</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">directQueue</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">"bootDirectQueue"</span>);
    &#125;
    <span class="hljs-comment">/*</span>
<span class="hljs-comment">     * @Description 配置一个交换机的绑定</span>
<span class="hljs-comment">     * @Param directQueue  需要绑定队列的对象，参数名必须要与某个@Bean的方法名完全相同，这样就会自动进行注入</span>
<span class="hljs-comment">     * @Param directExchange  需要绑定的交换机对象，参数名必须与某个@Bean的方法名完全相同，这样就会自动进行注入</span>
<span class="hljs-comment">     * @Param 参数3为routingkey的值</span>
<span class="hljs-comment">     **/</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">directBinding</span><span class="hljs-params">(Queue directQueue, DirectExchange directExchange)</span></span>&#123;
<span class="hljs-comment">//        return new Binding("bootDirectQueue", Binding.DestinationType.QUEUE, "bootDirectExchange",</span>
<span class="hljs-comment">//                "bootDirectRouting", null);</span>
        <span class="hljs-comment">//完成绑定</span>
        <span class="hljs-keyword">return</span> BindingBuilder.bind(directQueue).to(directExchange).with(<span class="hljs-string">"bootDirectRouting"</span>);
    &#125;

    <span class="hljs-comment">//必须确保交换机是一定存在的</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title">fanoutExchange</span><span class="hljs-params">()</span></span>&#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FanoutExchange(<span class="hljs-string">"bootFanoutExchange"</span>);
    &#125;;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TopicExchange <span class="hljs-title">topicExchange</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TopicExchange(<span class="hljs-string">"bootTopicExchange"</span>);
    &#125;
&#125;</code></pre>

</font>

<p>实现类</p>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-meta">@Service</span>(<span class="hljs-string">"sendService"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SendServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SendService</span> </span>&#123;
    <span class="hljs-comment">//注入amqp的模板类 利用这个对象来发送和接收消息</span>
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> AmqpTemplate amqpTemplate;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(String message)</span> </span>&#123;
        <span class="hljs-comment">/*</span>
<span class="hljs-comment">         * 发送消息</span>
<span class="hljs-comment">         * 参数1：为交换机名称</span>
<span class="hljs-comment">         * 参数2：为RoutingKey</span>
<span class="hljs-comment">         * 参数3：为具体的消息内容</span>
<span class="hljs-comment">         **/</span>
        amqpTemplate.convertAndSend(<span class="hljs-string">"bootDirectExchange"</span>, <span class="hljs-string">"bootDirectRouting"</span>, message);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendFanoutMessage</span><span class="hljs-params">(String message)</span> </span>&#123;
        amqpTemplate.convertAndSend(<span class="hljs-string">"bootFanoutExchange"</span>, <span class="hljs-string">""</span>, message);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendTopicMessage</span><span class="hljs-params">(String message)</span> </span>&#123;
        amqpTemplate.convertAndSend(<span class="hljs-string">"bootTopicExchange"</span>, <span class="hljs-string">"aa.bb.cc"</span>, message);
    &#125;

&#125;</code></pre>

</font>

<p>主类</p>
<font size = '5'>

<pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqSpringbootSendApplication</span> </span>&#123;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		ApplicationContext ac = SpringApplication.run(RabbitmqSpringbootSendApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;
		SendService sendService = (SendService) ac.getBean(<span class="hljs-string">"sendService"</span>);
<span class="hljs-comment">//		sendService.sendMessage("springboot与rabbitmq整合的测试信息");</span>
<span class="hljs-comment">//		sendService.sendFanoutMessage("springboot与rabbitmq整合的测试数据---fanout");</span>

		sendService.sendTopicMessage(<span class="hljs-string">"springboot与rabbitmq整合的测试数据---topic"</span>);
&#125;
&#125;</code></pre>

</font>

<h2 id="集群模式介绍"><a href="#集群模式介绍" class="headerlink" title="集群模式介绍"></a>集群模式介绍</h2><p>（如果只有一台机器很容易出现单点故障问题）</p>
<p>普通模式：建立临时通道。</p>
<p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/RabbitMQ/%E9%9B%86%E7%BE%A4%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F.PNG" srcset="/img/loading.gif" alt="集群普通模式"></p>
<p>镜像模式：高可用模式。</p>
<p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/RabbitMQ/%E9%9B%86%E7%BE%A4%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F.PNG" srcset="/img/loading.gif" alt="集群镜像模式"></p>
<p>这个时候，即使a宕机了，也可以用b中读取数据，a、b为相互镜像。</p>
<ol>
<li><p>准备两台linux的虚拟机，并修改hostname</p>
<p>执行</p>
<font size = '5'>

<pre><code class="hljs java">vi etc/hosts</code></pre>

<pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> A  localhost localhost.localdomain localhost4 localhost4.localdomain4 ::<span class="hljs-number">1</span>       A  localhost localhost.localdomain localhost6 localhost6.localdomain6 
 
<span class="hljs-number">192.168</span><span class="hljs-number">.222</span><span class="hljs-number">.129</span> A <span class="hljs-number">192.168</span><span class="hljs-number">.222</span><span class="hljs-number">.130</span> B</code></pre>

</font>

<p>确保 2 台机器相互 ping 同可以执行 ping A 和 ping B 命令进行测试 </p>
</li>
<li><p>安装rabbitmq（各种依赖包、Erlang、安装RabbitMQ）</p>
</li>
<li><p>配置cookie文件</p>
<p>保障不同节点可以互相通信的密钥，具体存放在</p>
<font size = '5'>

<pre><code class="hljs java">/<span class="hljs-keyword">var</span>/lib/rabbitmq/.erlang.cookie</code></pre>

</font>

<p>也可以使用</p>
<font size = '5'>

<pre><code class="hljs java">[root@A ~]# scp /var/lib/rabbitmq/.erlang.cookie 192.168.56.104:/var/lib/rabbitmq</code></pre>

</font>

<p>进行文件跨服务器的拷贝</p>
<p>Tips:</p>
<blockquote>
<p>由于这个文件的权限是只读因此无论是使用 vim 还是 scp 来实现 Cookie 文件的同步 都会失败，因此必须要修改这个文件的权限, 例如 chmod 777 /var/lib/rabbitmq/.erlang.cookie 当 Cookie 文件同步完成以后再修改权限回只读 例如 chmod 400 /var/lib/rabbitmq/.erlang.cookie </p>
</blockquote>
</li>
<li><p>组建集群</p>
<p>先启动RaabbitMQ服务</p>
<font size = '5'>

<pre><code class="hljs java">rabbitmqctl stop 
rabbitmq-server -detached   <span class="hljs-comment">//表示在后台运行</span></code></pre>

</font>

<p>将某个 RabbitMQ 加入到某个服务器节点 </p>
<font size = '5'>

<pre><code class="hljs java">rabbitmqctl stop_app rabbitmqctl join_cluster rabbit<span class="hljs-meta">@A</span> rabbitmqctl start_app</code></pre>

</font>

<p> rabbit@A 命令中的 A 为某个机器的 hostname，在 hostname 为 B 的机器中执行这些命令 </p>
<p>查看状态确认节点成功添加</p>
<font size = '5'>

<pre><code class="hljs java">[root@B ~]# rabbitmqctl cluster_status</code></pre>

</font>

<p>进行springboot的配置</p>
<font size = '5'>

<pre><code class="hljs java">#spring.rabbitmq.port=5672 #配置 RabbitMQ 的集群访问地址 spring.rabbitmq.addresses=192.168.222.129:5672,192.168.222.130:5672 #配置 RabbitMQ 服务器的访问账号 spring.rabbitmq.username=root #配置 RabbitMQ 服务器的访问密码 spring.rabbitmq.password=root</code></pre>

</font>
</li>
<li><p>进行策略的添加</p>
</li>
</ol>
<hr>
<pre><code class="hljs java">rabbitmqctl stop_app 

rabbitmqctl reset 

rabbitmqctl start_app 

<span class="hljs-comment">//可以使某个节点变回独立的节点</span></code></pre>






            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/07/07/Linux/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/06/18/servlet%E6%A2%B3%E7%90%86/">
                        <span class="hidden-mobile">servlet梳理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>






<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "RabbitMQ&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>


















</body>
</html>
