<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Lambda表达式和方法引用</title>
    <link href="/2020/05/13/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    <url>/2020/05/13/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>Lambda表达式和方法引用的整理</font></div><hr><h2 id="Lanbda表达式"><a href="#Lanbda表达式" class="headerlink" title="Lanbda表达式"></a>Lanbda表达式</h2><font size='4'>   ### 1、Lambda表达式的格式   <p><code>(o1,o2) -&gt; Integer.compare(o1,o2);</code><br>左边 —&gt; lambda表达式的形参列表，本质上也就是接口中抽象方法的形参列表<br>右边 —&gt; lambda体，也就是重写抽象方法的方法体   </p><h2 id="2、Lambda表达式的使用的六种情况："><a href="#2、Lambda表达式的使用的六种情况：" class="headerlink" title="2、Lambda表达式的使用的六种情况："></a>2、Lambda表达式的使用的六种情况：</h2><p>(1)语法格式一：无参，无返回值<br><font size='5'></p><pre><code>    @Testpublic void test1(){    //不使用Lambda表达式    Runnable r1 = new Runnable() {        @Override        public void run() {            System.out.println(&quot;不使用Lambda表达式&quot;);        }    };    r1.run();    System.out.println(&quot;***********************&quot;);    //使用Lambda表达式    Runnable r2 = () -&gt; {        System.out.println(&quot;使用Lambda表达式&quot;);    };    r2.run();}   </code></pre></font><p>(2)有一个参数，但是没有返回值<br><font size='5'></p><pre><code>@Testpublic void test2(){    //不使用Lambda表达式    Consumer&lt;String&gt; con = new Consumer&lt;String&gt;() {        @Override        public void accept(String s) {            System.out.println(s);        }    };    con.accept(&quot;不使用Lambda表达式&quot;);    System.out.println(&quot;*******************&quot;);    //使用Lambda表达式    Consumer&lt;String&gt; con1 = (String s) -&gt; {        System.out.println(s);    };    con1.accept(&quot;使用Lambda表达式&quot;);}   </code></pre></font><p>(3)数据类型可以省略，因为可以推断得出，称为类型推断<br><font size='5'></p><pre><code>@Testpublic void test3(){    //不使用Lambda表达式    Consumer&lt;String&gt; con1 = (String s) -&gt; {        System.out.println(s);    };    con1.accept(&quot;不使用Lambda表达式&quot;);    System.out.println(&quot;*******************&quot;);    //使用Lambda表达式    Consumer&lt;String&gt; con2 = (s) -&gt; {        System.out.println(s);    };    con2.accept(&quot;使用Lambda表达式&quot;);}</code></pre></font>   <p>(4)只需要一个参数的时候，小括号可以省略<br><font size='5'></p><pre><code>@Testpublic void test5(){    //不使用Lambda表达式    Consumer&lt;String&gt; con1 = (s) -&gt; {        System.out.println(s);    };    con1.accept(&quot;不使用Lambda表达式&quot;);    System.out.println(&quot;*******************&quot;);    //使用Lambda表达式    Consumer&lt;String&gt; con2 = s -&gt; {        System.out.println(s);    };    con2.accept(&quot;使用Lambda表达式&quot;);}</code></pre></font>   <p>(5)需要两个或两个以上的参数，多条执行语句，可以有返回值<br><font size='5'></p><pre><code>    @Testpublic void test6(){    //不使用Lambda表达式    Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;() {        @Override        public int compare(Integer o1, Integer o2) {            System.out.println(o1);            System.out.println(o2);            return o1.compareTo(o2);        }    };    System.out.println(com1.compare(12,21));    System.out.println(&quot;*****************************&quot;);    //使用Lambda表达式    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; {        System.out.println(o1);        System.out.println(o2);        return o1.compareTo(o2);    };    System.out.println(com2.compare(12,6));}</code></pre></font>   <p>(6)只有一条语句时，如果有返回值，return和大括号都可以省略（<strong>return必须省略</strong>）<br><font size='5'></p><pre><code>@Testpublic void test7(){    //不使用Lambda表达式    Comparator&lt;Integer&gt; com1 = (o1,o2) -&gt; {        return o1.compareTo(o2);    };    System.out.println(com1.compare(12,6));    System.out.println(&quot;*****************************&quot;);    //使用Lambda表达式    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; o1.compareTo(o2);    System.out.println(com2.compare(12,21));}</code></pre></font><p>综合的列子：<br>例子一：<br><font size='5'></p><pre><code>@Testpublic void test1(){    //不用Lambda表达式    happyTime(500, new Consumer&lt;Double&gt;() {        @Override        public void accept(Double aDouble) {            System.out.println(&quot;天上的星星有&quot; + aDouble);        }    });    System.out.println(&quot;********************&quot;);    //使用Lambda表达式    happyTime(400,nums -&gt; System.out.println(&quot;眼睛里有&quot; + nums + &quot;颗星星&quot;));}public void happyTime(double nums, Consumer&lt;Double&gt; con){    con.accept(nums);}   </code></pre></font><p>例子二：<br><font size='5'></p><pre><code>@Testpublic void test2(){    List&lt;String&gt; list = Arrays.asList(&quot;北京&quot;,&quot;南京&quot;,&quot;天津&quot;,&quot;东京&quot;,&quot;西京&quot;,&quot;普京&quot;);    List&lt;String&gt; filterStrs = filterString(list, new Predicate&lt;String&gt;() {        @Override        public boolean test(String s) {            return s.contains(&quot;京&quot;);        }    });    System.out.println(filterStrs);    List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains(&quot;京&quot;));    System.out.println(filterStrs1);}    //根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定    public List&lt;String&gt; filterString(List&lt;String&gt; list, Predicate&lt;String&gt; pre){        ArrayList&lt;String&gt; filterList = new ArrayList&lt;&gt;();        for(String s : list){            if(pre.test(s)){                filterList.add(s);            }        }        return filterList;    }}    </code></pre></font><p>总结：<br>&emsp;&emsp;-&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也可以省略<br>&emsp;&emsp;-&gt;右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对{}和return关键字</p><h3 id="3、lambda表达式的本质"><a href="#3、lambda表达式的本质" class="headerlink" title="3、lambda表达式的本质"></a>3、lambda表达式的本质</h3><p>作为函数式接口的<strong>实例</strong><br>&emsp;&emsp;所谓函数式接口也就是只声明了<strong>一个</strong>抽象方法的接口成为函数式接口，一般用@FunctionalInterface来注释，也可以用@FunctionalInterface来检验接口是否为函数式接口，如果不是函数式接口，会报错。<br>&emsp;&emsp;以前用匿名实现类表现的现在都可以用lambda表达式来写   </p><h3 id="4、关于函数式接口"><a href="#4、关于函数式接口" class="headerlink" title="4、关于函数式接口"></a>4、关于函数式接口</h3><p>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。<br>我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。<br><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.png" srcset="/img/loading.gif" alt="函数式接口"><br></font>   </p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><font size='4'>(1)使用情景   当传递给Lambda体的操作，已经有实现的方法了，就可以使用方法的引用   方法的引用：本质上就是Lambda表达式，而Lambda表达式时函数式接口的实例，所以，方法引用，也就是函数式接口的实例   使用格式：类（或对象）：：方法名   方法的引用使用要求：要求接口中抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同（针对于情况一和情况二）   <p>具体分为三种情况<br>情况一：对象 :: 实例方法<br><font size='5'></p><pre><code>//Consumer中的void accept(T t)//PrintStream中的void println(T t)@Testpublic void test1() {    Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);    con1.accept(&quot;北京&quot;);    System.out.println(&quot;*******************&quot;);    PrintStream ps = System.out;    Consumer&lt;String&gt; con2 = ps::println;    con2.accept(&quot;beijing&quot;);}   </code></pre></font><p>情况二：类 :: 静态方法<br><font size='5'></p><pre><code>//Comparator中的int compare(T t1,T t2)//Integer中的int compare(T t1,T t2)@Testpublic void test3() {    Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);    System.out.println(com1.compare(12,21));    System.out.println(&quot;*******************&quot;);    Comparator&lt;Integer&gt; com2 = Integer::compare;    System.out.println(com2.compare(12,3));}</code></pre></font>   <p>情况三：类 :: 实例方法  (有难度)<br><font size='5'>   </p><pre><code>// Comparator中的int comapre(T t1,T t2)// String中的int t1.compareTo(t2)@Testpublic void test5() {    Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);    System.out.println(com1.compare(&quot;abc&quot;,&quot;abd&quot;));    System.out.println(&quot;*******************&quot;);    Comparator&lt;String&gt; com2 = String :: compareTo;    System.out.println(com2.compare(&quot;abd&quot;,&quot;abm&quot;));}   //BiPredicate中的boolean test(T t1, T t2);//String中的boolean t1.equals(t2)@Testpublic void test6() {    BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);    System.out.println(pre1.test(&quot;abc&quot;,&quot;abc&quot;));    System.out.println(&quot;*******************&quot;);    BiPredicate&lt;String,String&gt; pre2 = String :: equals;    System.out.println(pre2.test(&quot;abc&quot;,&quot;abd&quot;));}</code></pre></font></font>   <hr><p><a href="https://www.bilibili.com/video/BV1Qb411g7cz?p=666" target="_blank" rel="noopener">资料来源</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JSON的简单了解 </title>
    <link href="/2020/05/13/JSON%E7%9A%84%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%20/"/>
    <url>/2020/05/13/JSON%E7%9A%84%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%20/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>JSON的简单了解</font></div><hr><h3 id="JSON是什么"><a href="#JSON是什么" class="headerlink" title="JSON是什么"></a>JSON是什么</h3><p>&emsp;&emsp;是一种基于JavaScript语法子集的开放标准数据交换格式。JSON是基于文本的，轻量级的，通常被认为易于读/写。</p><h3 id="语法格式要求"><a href="#语法格式要求" class="headerlink" title="语法格式要求"></a>语法格式要求</h3><font size='4'>&emsp;&emsp;在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：   <p>1、对象数组表示为键值对<br>2、数据由逗号分隔<br>3、花括号保存对象<br>4、方括号保存数组   </p><p>JSON键值对是用来保存JS对象的一种方式，例如：<br>{“age”:”3”}<br>JSON是JS对象的字符串的表示法，它使用文本表示一个JS对象的信息。本质是一个字符串。</font>   </p><h3 id="JSON和JavaScript对象互转"><a href="#JSON和JavaScript对象互转" class="headerlink" title="JSON和JavaScript对象互转"></a>JSON和JavaScript对象互转</h3><p><font size='4'>JSON和JS对象的互转:<br>JSON字符串 —&gt;   JS对象<br>使用JSON.parse()方法:</p><p>JS对象 —&gt; JSON字符串<br>使用JSON.stringify()方法<br><font size='5'></p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    var user = {        name : &quot;爱丽丝&quot;,        age : 3,        sex : &quot;女&quot;    };    //输出此对象    console.log(user);    //将js对象转换为JSON    var str = JSON.stringify(user);    // str的输出结果：{&quot;name&quot;:&quot;爱丽丝&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;女&quot;}    console.log(str);    var obj = JSON.parse(str);    //obj的输出结果：{name: &quot;爱丽丝&quot;, age: 3, sex: &quot;女&quot;}    console.log(obj);&lt;/script&gt;   </code></pre></font><p>由于前后端分离，数据交互就变得异常重要，而json就是很重要的一部分</font>   </p><h3 id="使用Jackson进行json的解析"><a href="#使用Jackson进行json的解析" class="headerlink" title="使用Jackson进行json的解析"></a>使用Jackson进行json的解析</h3><p><font size='4'>Json返回的是一个字符串，而市面上有很多第三方jar包可以实现此功能，例如<strong>jackson</strong>（可以去maven仓库找）:可以利用@ResponseBody就可以将对象转换为json返回<br><font size='5'></p><pre><code>@Controllerpublic class UserController {    @RequestMapping(&quot;/json1&quot;)    @ResponseBody    public String json1() throws JsonProcessingException {       //创建一个jackson的对象映射器，用来解析数据       ObjectMapper mapper = new ObjectMapper();       //创建一个对象       User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);       //将我们的对象解析成为json格式       String str = mapper.writeValueAsString(user);       //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便       return str;    }}</code></pre></font><p>结果可以返回json的字符串，但是会出现乱码的问题<br>解决方法一：<br>使用@RequestMapping注解中的produces属性来指定返回类型和编码格式<br><font size='5'></p><pre><code>//produces:指定响应体返回类型和编码@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;)</code></pre></font>   可以解决乱码问题   <p>解决办法二：<br>在springMVC中，直接进行统一的配置，通过配置StringHttpMessageConverter进行转换<br><font size='5'></p><pre><code>&lt;mvc:annotation-driven&gt;    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;       &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;           &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;       &lt;/bean&gt;       &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;           &lt;property name=&quot;objectMapper&quot;&gt;               &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;                   &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;               &lt;/bean&gt;           &lt;/property&gt;       &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;</code></pre></font> </font><h3 id="关于统一返回json字符串"><a href="#关于统一返回json字符串" class="headerlink" title="关于统一返回json字符串"></a>关于统一返回json字符串</h3><p><font size='4'>可以直接在类上使用，@RestController，这样所有的方法返回的都是json字符串了，而不用每一个方法上都添加@ResponseBody，这是在开发中常用的方法<br><font size='5'></p><pre><code>@RestControllerpublic class UserController {    //produces:指定响应体返回类型和编码    @RequestMapping(value = &quot;/json1&quot;)    public String json1() throws JsonProcessingException {       //创建一个jackson的对象映射器，用来解析数据       ObjectMapper mapper = new ObjectMapper();       //创建一个对象       User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);       //将我们的对象解析成为json格式       String str = mapper.writeValueAsString(user);       //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便       return str;    }}   </code></pre></font></font><h3 id="关于时间问题的处理"><a href="#关于时间问题的处理" class="headerlink" title="关于时间问题的处理"></a>关于时间问题的处理</h3><p><font size='4'>json在将时间返回为json数据时，会将时间转换为时间戳的形式进行显示<br>解决办法：取消timestamps的形式，还可以自定义时间格式<br><font size='5'></p><pre><code>@RequestMapping(&quot;/json4&quot;)public String json4() throws JsonProcessingException {    ObjectMapper mapper = new ObjectMapper();    //不使用时间戳的方式   在此步骤关闭时间戳    mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);    //自定义日期格式对象    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    //指定日期格式    mapper.setDateFormat(sdf);    Date date = new Date();    String str = mapper.writeValueAsString(date);    return str;}</code></pre></font></font><h3 id="一点小拓展"><a href="#一点小拓展" class="headerlink" title="一点小拓展"></a>一点小拓展</h3><p><font size='4'>&emsp;&emsp;可以将经常使用的代码封装到一个工具类中：<br><font size='5'></p><pre><code>package com.kuang.utils;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import java.text.SimpleDateFormat;public class JsonUtils {    public static String getJson(Object object) {       return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;);    }    public static String getJson(Object object,String dateFormat) {       ObjectMapper mapper = new ObjectMapper();       //不使用时间差的方式       mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);       //自定义日期格式对象       SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);       //指定日期格式       mapper.setDateFormat(sdf);       try {           return mapper.writeValueAsString(object);      } catch (JsonProcessingException e) {           e.printStackTrace();      }       return null;    }}   </code></pre></font>这样调用的时候就可以直接使用啦</font>   <hr><p><font size='4'>&emsp;&emsp;astjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。   </p><p>记得导入fastjson 的 pom依赖！（可以在maven仓库找）</p><p>fastjson 三个主要的类：</p><p>（1）JSONObject  代表 json 对象 </p><p>（2）JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。</p><p>（3）JSONArray   代表 json 对象数组：内部是有List接口中的方法来完成操作的。<br>例如代码演示：<br><font size='5'></p><pre><code>package com.kuang.controller;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.kuang.pojo.User;import java.util.ArrayList;import java.util.List;public class FastJsonDemo {    public static void main(String[] args) {       //创建一个对象       User user1 = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);       User user2 = new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;);       User user3 = new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;);       User user4 = new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;);       List&lt;User&gt; list = new ArrayList&lt;User&gt;();       list.add(user1);       list.add(user2);       list.add(user3);       list.add(user4);       System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;);       String str1 = JSON.toJSONString(list);       System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1);       String str2 = JSON.toJSONString(user1);       System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2);       System.out.println(&quot;\n****** JSON字符串 转 Java对象*******&quot;);       User jp_user1=JSON.parseObject(str2,User.class);       System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1);       System.out.println(&quot;\n****** Java对象 转 JSON对象 ******&quot;);       JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);       System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;));       System.out.println(&quot;\n****** JSON对象 转 Java对象 ******&quot;);       User to_java_user = JSON.toJavaObject(jsonObject1, User.class);       System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user);    }}</code></pre></font><hr><p>以上资料参考：<a href="https://mp.weixin.qq.com/s/RAqRKZJqsJ78HRrJg71R1g" target="_blank" rel="noopener">狂神说JAVA</a></font></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Maven的大概梳理</title>
    <link href="/2020/05/13/%E5%85%B3%E4%BA%8EMaven%E7%9A%84%E5%A4%A7%E6%A6%82%E6%A2%B3%E7%90%86/"/>
    <url>/2020/05/13/%E5%85%B3%E4%BA%8EMaven%E7%9A%84%E5%A4%A7%E6%A6%82%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>关于Maven的大概梳理</font></div><hr><h2 id="目前项目中存在的问题"><a href="#目前项目中存在的问题" class="headerlink" title="目前项目中存在的问题"></a>目前项目中存在的问题</h2><p><font size='4'>1、一个项目就是一个工程<br>2、项目中需要的jar包必须手动复制，粘贴到”WEB-INF/lib”目录下<br>所带来的问题是：同样的jar包重复出现，这样浪费空间也让空间比较臃肿，借助maven可以将jar包保存在仓库中<br>3、jar包需要别人替我们准备好，或者到官网上下载<br>而官网提供的jar包下载形式是不同的，很不方便，面临各种问题，而借助maven可以按照统一的规范下载<br>4、一个jar包以来的其他的jar包需要自己手动加入到项目中<br></font>   </p><h2 id="maven是什么？"><a href="#maven是什么？" class="headerlink" title="maven是什么？"></a>maven是什么？</h2><p><font size='4'>Maven是一款服务于<strong>java</strong>平台的自动化构建工具<br>关于构建：<br>web工程和编译结果在目录上的不同：<br><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/maven%E4%B8%ADweb%E5%B7%A5%E7%A8%8B%E5%92%8C%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C%E7%9B%AE%E5%BD%95%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C.PNG" srcset="/img/loading.gif" alt="web工程和编译结果在目录上的不同"><br>构建的各个环节：<br>[1]清理：将以前的得到的旧的class字节码文件删除，为下一次编译做准备<br>[2]编译：将java源程序编译成class字节码文件<br>[3]测试：自动测试，自动调用junit程序<br>[4]报告：测试程序执行的结果<br>[5]打包：动态web工程打包为war包，java工程打jar包<br>[6]安装：maven特定的概念————将打包得到的文件复制到仓库中的位置<br>[7]部署：将动态的web工程生成war包复制到servlet容器指定目录下，使其可以运行</font>   </p><h2 id="maven的核心概念"><a href="#maven的核心概念" class="headerlink" title="maven的核心概念"></a>maven的核心概念</h2><h3 id="1、约定的目录结构"><a href="#1、约定的目录结构" class="headerlink" title="1、约定的目录结构"></a>1、约定的目录结构</h3><p><font size='4'>例如：<br>        目录结构<br>            Hello<br>            |—src<br>            |—|—main<br>            |—|—|—java<br>            |—|—|—resources<br>            |—|—test<br>            |—|—|—java<br>            |—|—|—resources<br>            |—pom.xml   </p><p>(1)根目录：工程名<br>(2)scr目录：源码<br>(3)pom.xml文件：maven工程的核心配置文件<br>(4)main目录：存放主程序<br>(5)test目录：存放测试程序<br>(6)java目录：存放java源程序<br>(7)resource目录：存放框架或者其他工具的配置文件   </p><p>一般来说：约定 &gt; 配置 &gt; 编码   </p><p>maven常用的命令<br>(1)mvn clean:清理<br>(2)mvn compile:编译主程序<br>(3)mvn test-complie:编译测试程序<br>(4)mvn test:执行测试<br>(5)mvn package:打包<br>(6)mvn site:生成站点   </p><p>Tips：<br>&emsp;&emsp;当我们执行maven命令需要用到某些插件时，maven核心程序会先去本地仓库（家目录）中寻找<code>C:\Users\18369\.m2\repository</code>如果没有找到，就会自动联网，在中央仓库中下载。</font>   </p><h3 id="2、pom"><a href="#2、pom" class="headerlink" title="2、pom"></a>2、pom</h3><p><font size='4'>(1)Project Object Model:项目对象模型<br>(2)pom.xml是maven工程的核心配置文件</font>   </p><h3 id="3、坐标"><a href="#3、坐标" class="headerlink" title="3、坐标"></a>3、坐标</h3><p><font size='4'>(1)使用三个向量在仓库中定位唯一的一个maven工程（管理jar包的方式）<br>&emsp;&emsp;[1]groupid：公司或者组织域名倒序+项目名   </p><pre><code>&lt;groupId&gt;org.example&lt;/groupId&gt;</code></pre><p>&emsp;&emsp;[2]artifactId：模块名   </p><pre><code>&lt;artifactId&gt;springMVC_day02_02_fileupload&lt;/artifactId&gt;   </code></pre><p>&emsp;&emsp;[3]version：版本</p><pre><code>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;   </code></pre></font><h3 id="4、依赖"><a href="#4、依赖" class="headerlink" title="4、依赖"></a>4、依赖</h3><p><font size='4'>(1)maven解析依赖信息的时候，会到本地仓库中查找被以来的jar包，对于我们自己的maven工程，使用mvn install命令安装后就可以进入仓库了。<br>(2)依赖的范围：<br><font size='5'><code>&lt;scope&gt;test&lt;/scope&gt;</code>默认值是compile</font>   </p><p>&emsp;&emsp;[1]compile<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对主程序<strong>有效</strong>，测试程序<strong>有效</strong>，<strong>参与</strong>打包，<strong>参与</strong>部署<br>&emsp;&emsp;[2]test<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对主程序<strong>无效</strong>，测试程序<strong>有效</strong>，<strong>不参与</strong>打包，<strong>不参与</strong>部署<br>&emsp;&emsp;[3]provided<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对主程序<strong>有效</strong>，测试程序<strong>有效</strong>，<strong>不参与</strong>打包，<strong>不参与</strong>部署   </p><p>(3)依赖的传递性<br>&emsp;&emsp;[1]可以传递的依赖不必在每个工程中都重复声明<br>&emsp;&emsp;[2]<strong>非</strong>compile范围的依赖是传递不过来的   </p><p>(4)依赖的排除<br>&emsp;&emsp;[1]需要设置依赖排除的场合<br>&emsp;&emsp;[2]依赖排除的方式<br><font size='5'></p><pre><code>&lt;exclusions&gt;    &lt;exclusion&gt;        &lt;groupId&gt;commons-logging&lt;/groupId&gt;        &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;    &lt;/exclusion&gt;&lt;/exclusions&gt;   </code></pre></font><p>(5)依赖的原则<br>&emsp;&emsp;[1]作用：解决模块工程之间的jar包冲突问题<br>&emsp;&emsp;[2]原则上：路径距离不同时：路径最短者优先<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;路径距离相同时：先声明者（指dependency标签的声明顺序）优先<br>(6)统一管理依赖的版本<br>建议方式：<br>&emsp;&emsp;[1]使用properties标签，其中使用自定义标签，统一声明版本号<br>&emsp;&emsp;例如：<br><font size='5'></p><pre><code>&lt;properties&gt;    &lt;edu.kmust.spring.version&gt;4.1.1.RELEASE&lt;/edu.kmust.spring.version&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt; </code></pre></font>  &emsp;&emsp;[2]在需要统一的位置，使用${自定义标签名}引用声明的版本号   &emsp;&emsp;例如：   <font size='5'><pre><code>&lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;        &lt;!-- 引用版本号实现统一管理 --&gt;        &lt;version&gt;${edu.kmust.spring.version}&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;   </code></pre></font><p>&emsp;&emsp;[3]properties标签并不只是可以声明版本号，也可以进行其他的设置，凡是需要统一声明后再使用的都可以引用<br><font size='5'></p><pre><code>&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;   </code></pre></font></font></font>    </font>   <h3 id="5、仓库"><a href="#5、仓库" class="headerlink" title="5、仓库"></a>5、仓库</h3><p><font size='4'>(1)分类<br>[1]本地仓库：当前电脑上<br>[2]远程仓库<br>&emsp;&emsp;私服：为当前局域网中的maven工程服务<br>&emsp;&emsp;中央仓库：架设在Internet上为全世界的maven服务<br>&emsp;&emsp;中央仓库的镜像：架设在各个州，为中央仓库分流，减轻负担，提升访问速度   </p><p>(2)仓库中保存的内容<br>&emsp;&emsp;[1]maven自身所诉需要的插件<br>&emsp;&emsp;[2]第三方框架或者工具的jar包<br>&emsp;&emsp;[3]我们自己开发的maven工程</font>   </p><h3 id="6、生命周期-插件-目标"><a href="#6、生命周期-插件-目标" class="headerlink" title="6、生命周期/插件/目标"></a>6、生命周期/插件/目标</h3><p><font size='4'>&emsp;&emsp;各个构建环节的执行顺序，不可打乱，必须按照正确的顺序来执行。<br>&emsp;&emsp;不论执行生命周期的哪一阶段，都是从生命周期最初的位置开始执行的。<br>&emsp;&emsp;插件和目标<br>&emsp;&emsp;&emsp;[1]生命周期的各个阶段仅仅定义了要执行的任务是什么<br>&emsp;&emsp;&emsp;[2]各个阶段和插件的目标是对应的<br>&emsp;&emsp;&emsp;[3]相似的目标又特定的插件完成   </p></font>   <h3 id="7、继承"><a href="#7、继承" class="headerlink" title="7、继承"></a>7、继承</h3><font size='4'>继承可以解决的问题：由于test范围的依赖不能传递，所以必然会分散再各个模块的工程中，很容易造成版本不一致。   需求：统一管理各个模块工程中对某个（例如junit）依赖的版本。   解决思路：将junit的依赖统一提取到父工程中，在子工程中声明junit时不指定版本，就以父工程中的统一设定为准。   <p>具体步骤：<br>[1]创建一个maven的父工程，打包方式为<strong>pom</strong><br><font size='5'></p><pre><code>&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;&lt;artifactId&gt;Parent&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt;</code></pre></font><p>[2]在子工程中声明对父工程的引用<br><font size='5'></p><pre><code>&lt;!-- 子工程中声明父工程 --&gt;&lt;parent&gt;    &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;    &lt;artifactId&gt;Parent&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;!-- 以当前文件为基准的父工程pom.xml文件的相对路径 --&gt;    &lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt;</code></pre></font><p>[3]将子工程的坐标与父工程中相同的部分删除<br>例如：<code>&lt;gourpId&gt;  &lt;/gourpId&gt;</code>等（有黄色波浪下划线的部分）<br>[4]在父工程中统一管理junit的依赖<br><font size='5'></p><pre><code>&lt;!-- 配置依赖的管理 --&gt;&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.9&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;</code></pre></font><p>[5]在子工程中删除junit依赖的版本号部分<br>也就是：<code>&lt;version&gt;  &lt;/version&gt;</code><br>Tips：配置继承后，执行命令时要先安装父工程</p><h3 id="8、聚合"><a href="#8、聚合" class="headerlink" title="8、聚合"></a>8、聚合</h3><p>作用：一键安装各个模块工具<br>在一个总的聚合工具中配置各个参与聚合的模块<br><font size='5'></p><pre><code>&lt;!-- 配置聚合 --&gt;&lt;modules&gt;    &lt;!-- 指定各个子工程的相对路径 --&gt;    &lt;module&gt;../HelloFriend&lt;/module&gt;    &lt;module&gt;../MakeFriends&lt;/module&gt;    &lt;module&gt;../Hello&lt;/module&gt;&lt;/modules&gt;</code></pre></font>   使用方法：在聚合工程的pom.xml上右键 ---> run as ---> maven install</font>   <hr><p><a href="https://www.bilibili.com/video/BV1Pt411y7Rh?p=1" target="_blank" rel="noopener">资料来源</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于反射的知识点的整理</title>
    <link href="/2020/05/07/%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E6%95%B4%E7%90%86/"/>
    <url>/2020/05/07/%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<div align='center' ><font size='6'>关于反射的知识点的整理</font></div><hr><h2 id="关于java-lang-Class的理解"><a href="#关于java-lang-Class的理解" class="headerlink" title="关于java.lang.Class的理解"></a>关于java.lang.Class的理解</h2><font size='4'><h3 id="1、类的加载过程"><a href="#1、类的加载过程" class="headerlink" title="1、类的加载过程"></a>1、类的加载过程</h3><p>&emsp;&emsp;程序在运行过程中通过javac.exe命令之后，会生成一个或者多个字节码文件(以.class结尾)，接着当我们使用java.exe命令对某个字节码文件进行解释编译运行，此时就相当于将某个字节码文件加载到了内存中，此过程称之为类的加载，而加载到内存中的类，我们称之为运行时类，此时的运行时类就作为一个Class的实例存在。换句话说，Class的实例就对应着一个运行时类。</p><h3 id="2、哪些对象可以有Class的对象"><a href="#2、哪些对象可以有Class的对象" class="headerlink" title="2、哪些对象可以有Class的对象"></a>2、哪些对象可以有Class的对象</h3><p>(1)、 interface 接口</p><p>(2)、数组[]</p><p>(3)、enum 枚举</p><p>(4)、primitive type 基本数据类型</p><p>(5)、annotation 注解</p><p>(6)、class：外部类、成员(成员内部类、静态内部类)、局部内部类、匿名内部类</p><p>(7)、void</p><h3 id="3、关于获取Class类的实例的方法"><a href="#3、关于获取Class类的实例的方法" class="headerlink" title="3、关于获取Class类的实例的方法"></a>3、关于获取Class类的实例的方法</h3><p>关于其中使用到的<a href="附录：">^Person</a>类见附录</p><p>(1)、方式一：通过运行时属性来获取</p><pre><code>Class&lt;Person&gt; clazz1 = Person.class;    System.out.println(clazz1);</code></pre><p>(2)、方式二：通过运行时类的对象来获取</p><pre><code>Person p1 = new Person();    Class clazz2 = p1.getClass();       //此方法在Object中声明    System.out.println(clazz2);</code></pre><p>(3)、方式三：通过静态方法forName(String classPath)来获取</p><pre><code>Class clazz3 = Class.forName(&quot;Reflaction.Person&quot;);    System.out.println(clazz3);</code></pre><p>(4)、方式四：通过类的加载ClassLoader来获取</p><pre><code>ClassLoader classLoader = ReflactionTest.class.getClassLoader();    Class&lt;Person&gt; clazz4 = (Class&lt;Person&gt;) classLoader.loadClass(&quot;Reflaction.Person&quot;);    System.out.println(clazz4);</code></pre><h3 id="4、一点点关于数组的小思考"><a href="#4、一点点关于数组的小思考" class="headerlink" title="4、一点点关于数组的小思考"></a>4、一点点关于数组的小思考</h3><pre><code>int[] a = new int[10];int[] b = new int[100];Class a10 = a.getClass();Class b100 = b.getClass();System.out.println(a10 == b100);</code></pre><p>结果为：<strong>true</strong><br>原因是：只要数组的元素类型和维度(一维数组、二维数组这样的)一样，它们为同一个Class<br></font></p><hr><h3 id="以下为Person类的附录："><a href="#以下为Person类的附录：" class="headerlink" title="以下为Person类的附录："></a>以下为Person类的附录：</h3><pre><code>package Reflaction;/** * @author BunnyAndOak0 * */public class Person {        private String name;        public int age;        public String getName() {            return name;        }        public void setName(String name) {            this.name = name;        }        public int getAge() {            return age;        }        public void setAge(int age) {            this.age = age;        }        public Person() {            super();            // TODO Auto-generated constructor stub        }        private Person(String name) {            super();            this.name = name;        }        public Person(String name, int age) {            super();            this.name = name;            this.age = age;        }        @Override        public String toString() {            return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;        }        public void show() {            System.out.println(&quot;我是一个人！&quot;);        }        private String showNation(String nation) {            System.out.println(&quot;我的国籍是：&quot; + nation);            return nation;        }}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2020/05/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <url>/2020/05/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="想写一点关于博客语法的东西"><a href="#想写一点关于博客语法的东西" class="headerlink" title="想写一点关于博客语法的东西"></a>想写一点关于博客语法的东西</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/05/07/hello-world/"/>
    <url>/2020/05/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
