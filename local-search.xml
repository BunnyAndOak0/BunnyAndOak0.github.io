<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JSON的简单了解</title>
    <link href="/2020/05/12/JSON%E7%9A%84%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/"/>
    <url>/2020/05/12/JSON%E7%9A%84%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>JSON的简单了解</font></div><hr><h3 id="JSON是什么"><a href="#JSON是什么" class="headerlink" title="JSON是什么"></a>JSON是什么</h3><p>&emsp;&emsp;是一种基于JavaScript语法子集的开放标准数据交换格式。JSON是基于文本的，轻量级的，通常被认为易于读/写。</p><h3 id="语法格式要求"><a href="#语法格式要求" class="headerlink" title="语法格式要求"></a>语法格式要求</h3><font size='4'>&emsp;&emsp;在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：   1、对象数组表示为键值对   2、数据由逗号分隔   3、花括号保存对象   4、方括号保存数组   <p>JSON键值对是用来保存JS对象的一种方式，例如：<br>{“age”:”3”}<br>JSON是JS对象的字符串的表示法，它使用文本表示一个JS对象的信息。本质是一个字符串。</font>   </p><h3 id="JSON和JavaScript对象互转"><a href="#JSON和JavaScript对象互转" class="headerlink" title="JSON和JavaScript对象互转"></a>JSON和JavaScript对象互转</h3><p><font size='4'>JSON和JS对象的互转<br>JSON字符串 —&gt;   JS对象<br>使用JSON.parse()方法<br>JS对象 —&gt; JSON字符串<br>使用JSON.stringify()方法<br><font size='5'></p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    var user = {        name : &quot;爱丽丝&quot;,        age : 3,        sex : &quot;女&quot;    };    //输出此对象    console.log(user);    //将js对象转换为JSON    var str = JSON.stringify(user);    // str的输出结果：{&quot;name&quot;:&quot;爱丽丝&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;女&quot;}    console.log(str);    var obj = JSON.parse(str);    //obj的输出结果：{name: &quot;爱丽丝&quot;, age: 3, sex: &quot;女&quot;}    console.log(obj);&lt;/script&gt;   </code></pre></font><p>由于前后端分离，数据交互就变得异常重要，而json就是很重要的一部分</font>   </p><h3 id="使用Jackson进行json的解析"><a href="#使用Jackson进行json的解析" class="headerlink" title="使用Jackson进行json的解析"></a>使用Jackson进行json的解析</h3><p><font size='4'>Json返回的是一个字符串，而市面上有很多第三方jar包可以实现此功能，例如<strong>jackson</strong>（可以去maven仓库找）:可以利用@ResponseBody就可以将对象转换为json返回<br><font size='5'></p><pre><code>@Controllerpublic class UserController {    @RequestMapping(&quot;/json1&quot;)    @ResponseBody    public String json1() throws JsonProcessingException {       //创建一个jackson的对象映射器，用来解析数据       ObjectMapper mapper = new ObjectMapper();       //创建一个对象       User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);       //将我们的对象解析成为json格式       String str = mapper.writeValueAsString(user);       //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便       return str;    }}</code></pre></font><p>结果可以返回json的字符串，但是会出现乱码的问题<br>解决方法一：<br>使用@RequestMapping注解中的produces属性来指定返回类型和编码格式<br><font size='5'></p><pre><code>//produces:指定响应体返回类型和编码@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;)</code></pre></font>   可以解决乱码问题   <p>解决办法二：<br>在springMVC中，直接进行统一的配置，通过配置StringHttpMessageConverter进行转换<br><font size='5'></p><pre><code>&lt;mvc:annotation-driven&gt;    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;       &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;           &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;       &lt;/bean&gt;       &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;           &lt;property name=&quot;objectMapper&quot;&gt;               &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;                   &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;               &lt;/bean&gt;           &lt;/property&gt;       &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;</code></pre></font> </font><h3 id="关于统一返回json字符串"><a href="#关于统一返回json字符串" class="headerlink" title="关于统一返回json字符串"></a>关于统一返回json字符串</h3><p><font size='4'>可以直接在类上使用，@RestController，这样所有的方法返回的都是json字符串了，而不用每一个方法上都添加@ResponseBody，这是在开发中常用的方法<br><font size='5'></p><pre><code>@RestControllerpublic class UserController {    //produces:指定响应体返回类型和编码    @RequestMapping(value = &quot;/json1&quot;)    public String json1() throws JsonProcessingException {       //创建一个jackson的对象映射器，用来解析数据       ObjectMapper mapper = new ObjectMapper();       //创建一个对象       User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);       //将我们的对象解析成为json格式       String str = mapper.writeValueAsString(user);       //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便       return str;    }}   </code></pre></font></font><h3 id="关于时间问题的处理"><a href="#关于时间问题的处理" class="headerlink" title="关于时间问题的处理"></a>关于时间问题的处理</h3><p><font size='4'>json在将时间返回为json数据时，会将时间转换为时间戳的形式进行显示<br>解决办法：取消timestamps的形式，还可以自定义时间格式<br><font size='5'></p><pre><code>@RequestMapping(&quot;/json4&quot;)public String json4() throws JsonProcessingException {    ObjectMapper mapper = new ObjectMapper();    //不使用时间戳的方式   在此步骤关闭时间戳    mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);    //自定义日期格式对象    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    //指定日期格式    mapper.setDateFormat(sdf);    Date date = new Date();    String str = mapper.writeValueAsString(date);    return str;}</code></pre></font></font><h3 id="一点小拓展"><a href="#一点小拓展" class="headerlink" title="一点小拓展"></a>一点小拓展</h3><p><font size='4'>&emsp;&emsp;可以将经常使用的代码封装到一个工具类中：<br><font size='5'></p><pre><code>package com.kuang.utils;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import java.text.SimpleDateFormat;public class JsonUtils {    public static String getJson(Object object) {       return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;);    }    public static String getJson(Object object,String dateFormat) {       ObjectMapper mapper = new ObjectMapper();       //不使用时间差的方式       mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);       //自定义日期格式对象       SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);       //指定日期格式       mapper.setDateFormat(sdf);       try {           return mapper.writeValueAsString(object);      } catch (JsonProcessingException e) {           e.printStackTrace();      }       return null;    }}   </code></pre></font>这样调用的时候就可以直接使用啦</font>   <hr><p><font size='4'>&emsp;&emsp;astjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。   </p><p>记得导入fastjson 的 pom依赖！（可以在maven仓库找）</p><p>fastjson 三个主要的类：</p><p>（1）JSONObject  代表 json 对象 </p><p>（2）JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。</p><p>（3）JSONArray   代表 json 对象数组：内部是有List接口中的方法来完成操作的。<br>例如代码演示：<br><font size='5'></p><pre><code>package com.kuang.controller;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.kuang.pojo.User;import java.util.ArrayList;import java.util.List;public class FastJsonDemo {    public static void main(String[] args) {       //创建一个对象       User user1 = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);       User user2 = new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;);       User user3 = new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;);       User user4 = new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;);       List&lt;User&gt; list = new ArrayList&lt;User&gt;();       list.add(user1);       list.add(user2);       list.add(user3);       list.add(user4);       System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;);       String str1 = JSON.toJSONString(list);       System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1);       String str2 = JSON.toJSONString(user1);       System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2);       System.out.println(&quot;\n****** JSON字符串 转 Java对象*******&quot;);       User jp_user1=JSON.parseObject(str2,User.class);       System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1);       System.out.println(&quot;\n****** Java对象 转 JSON对象 ******&quot;);       JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);       System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;));       System.out.println(&quot;\n****** JSON对象 转 Java对象 ******&quot;);       User to_java_user = JSON.toJavaObject(jsonObject1, User.class);       System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user);    }}</code></pre></font><hr><p>以上资料参考：<a href="https://mp.weixin.qq.com/s/RAqRKZJqsJ78HRrJg71R1g" target="_blank" rel="noopener">狂神说JAVA</a></font></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于反射的知识点的整理</title>
    <link href="/2020/05/07/%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E6%95%B4%E7%90%86/"/>
    <url>/2020/05/07/%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<div align='center' ><font size='6'>关于反射的知识点的整理</font></div><hr><h2 id="关于java-lang-Class的理解"><a href="#关于java-lang-Class的理解" class="headerlink" title="关于java.lang.Class的理解"></a>关于java.lang.Class的理解</h2><font size='4'><h3 id="1、类的加载过程"><a href="#1、类的加载过程" class="headerlink" title="1、类的加载过程"></a>1、类的加载过程</h3><p>&emsp;&emsp;程序在运行过程中通过javac.exe命令之后，会生成一个或者多个字节码文件(以.class结尾)，接着当我们使用java.exe命令对某个字节码文件进行解释编译运行，此时就相当于将某个字节码文件加载到了内存中，此过程称之为类的加载，而加载到内存中的类，我们称之为运行时类，此时的运行时类就作为一个Class的实例存在。换句话说，Class的实例就对应着一个运行时类。</p><h3 id="2、哪些对象可以有Class的对象"><a href="#2、哪些对象可以有Class的对象" class="headerlink" title="2、哪些对象可以有Class的对象"></a>2、哪些对象可以有Class的对象</h3><p>(1)、 interface 接口</p><p>(2)、数组[]</p><p>(3)、enum 枚举</p><p>(4)、primitive type 基本数据类型</p><p>(5)、annotation 注解</p><p>(6)、class：外部类、成员(成员内部类、静态内部类)、局部内部类、匿名内部类</p><p>(7)、void</p><h3 id="3、关于获取Class类的实例的方法"><a href="#3、关于获取Class类的实例的方法" class="headerlink" title="3、关于获取Class类的实例的方法"></a>3、关于获取Class类的实例的方法</h3><p>关于其中使用到的<a href="附录：">^Person</a>类见附录</p><p>(1)、方式一：通过运行时属性来获取</p><pre><code>Class&lt;Person&gt; clazz1 = Person.class;    System.out.println(clazz1);</code></pre><p>(2)、方式二：通过运行时类的对象来获取</p><pre><code>Person p1 = new Person();    Class clazz2 = p1.getClass();       //此方法在Object中声明    System.out.println(clazz2);</code></pre><p>(3)、方式三：通过静态方法forName(String classPath)来获取</p><pre><code>Class clazz3 = Class.forName(&quot;Reflaction.Person&quot;);    System.out.println(clazz3);</code></pre><p>(4)、方式四：通过类的加载ClassLoader来获取</p><pre><code>ClassLoader classLoader = ReflactionTest.class.getClassLoader();    Class&lt;Person&gt; clazz4 = (Class&lt;Person&gt;) classLoader.loadClass(&quot;Reflaction.Person&quot;);    System.out.println(clazz4);</code></pre><h3 id="4、一点点关于数组的小思考"><a href="#4、一点点关于数组的小思考" class="headerlink" title="4、一点点关于数组的小思考"></a>4、一点点关于数组的小思考</h3><pre><code>int[] a = new int[10];int[] b = new int[100];Class a10 = a.getClass();Class b100 = b.getClass();System.out.println(a10 == b100);</code></pre><p>结果为：<strong>true</strong><br>原因是：只要数组的元素类型和维度(一维数组、二维数组这样的)一样，它们为同一个Class<br></font></p><hr><h3 id="以下为Person类的附录："><a href="#以下为Person类的附录：" class="headerlink" title="以下为Person类的附录："></a>以下为Person类的附录：</h3><pre><code>package Reflaction;/** * @author BunnyAndOak0 * */public class Person {        private String name;        public int age;        public String getName() {            return name;        }        public void setName(String name) {            this.name = name;        }        public int getAge() {            return age;        }        public void setAge(int age) {            this.age = age;        }        public Person() {            super();            // TODO Auto-generated constructor stub        }        private Person(String name) {            super();            this.name = name;        }        public Person(String name, int age) {            super();            this.name = name;            this.age = age;        }        @Override        public String toString() {            return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;        }        public void show() {            System.out.println(&quot;我是一个人！&quot;);        }        private String showNation(String nation) {            System.out.println(&quot;我的国籍是：&quot; + nation);            return nation;        }}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2020/05/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <url>/2020/05/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="想写一点关于博客语法的东西"><a href="#想写一点关于博客语法的东西" class="headerlink" title="想写一点关于博客语法的东西"></a>想写一点关于博客语法的东西</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/05/07/hello-world/"/>
    <url>/2020/05/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
