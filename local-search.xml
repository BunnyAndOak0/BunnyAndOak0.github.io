<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数组与集合</title>
    <link href="/2020/05/20/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88/"/>
    <url>/2020/05/20/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>Java集合梳理</font></div><h2 id="数组与集合"><a href="#数组与集合" class="headerlink" title="数组与集合"></a>数组与集合</h2><hr><p>说明：</p><p>​        集合和数组都是对多个数据进行存储操作的结构，简称java容器，而此时说的<strong>存储</strong>，指的是<strong>内存层面</strong>的存储，不涉及到持久层（.txt, .jpg, .avi, 数据库中等）的存储。</p><p>数组在存储多个数据方面的特点：</p><ul><li>一旦初始化以后，其长度就确定了，<strong>不可修改</strong>。</li><li>数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。比如：String[] arr;int[] arr1; Object[] arr2;</li><li>数组存储数据的特点：<strong>有序、可重复</strong>。对于无序、不可重复的需求，不能满足。</li><li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><hr><p>​         <strong>Java集合不能存放基本数据类型</strong> ,Java集合如Map、Set、List等所有集合只能存放引用类型数据，它们都是存放引用类型数据的容器，不能存放如int、long、float、double等基础类型的数据。</p><h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><pre><code class="hljs ```java">|----Collection接口：单列集合，用来存储一个一个的对象         |----List接口：存储有序的、可重复的数据。                           |----ArrayList、LinkedList、Vector         |----Set接口：存储无序的、不可重复的数据                  |----HashSet、LinkedHashSet、TreeSet|------Map接口：双列集合，用来存储一对(key - value)一对的数据           |----HashMap、LinkedHashMap、TreeMap、Hashtable、Properties</code></pre><p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE.png" srcset="/img/loading.gif" alt="集合框架图"></p><h3 id="Collection接口中的方法的使用"><a href="#Collection接口中的方法的使用" class="headerlink" title="Collection接口中的方法的使用"></a>Collection接口中的方法的使用</h3><pre><code class="hljs java">Collection coll = <span class="hljs-keyword">new</span> ArrayList();</code></pre><ol><li>add(Object e):将元素e添加到集合coll中</li></ol><pre><code class="hljs java">coll.add(<span class="hljs-string">"AA"</span>);      coll.add(<span class="hljs-string">"BB"</span>);      coll.add(<span class="hljs-number">123</span>);<span class="hljs-comment">//自动装箱</span>      coll.add(<span class="hljs-keyword">new</span> Date());</code></pre><ol start="2"><li>size():获取添加的元素的个数</li></ol><pre><code class="hljs java">System.out.println(coll.size());<span class="hljs-comment">//4</span></code></pre><ol start="3"><li>addAll(Collection coll1):将coll1集合中的元素添加到当前的集合中</li></ol><pre><code class="hljs java">Collection coll1 = <span class="hljs-keyword">new</span> ArrayList();     coll1.add(<span class="hljs-number">456</span>);     coll1.add(<span class="hljs-string">"CC"</span>);     coll.addAll(coll1);</code></pre><ol start="4"><li>clear():清空集合元素</li></ol><pre><code class="hljs java">coll.clear();</code></pre><ol start="5"><li>isEmpty():判断当前集合是否为空</li></ol><pre><code class="hljs ```java">System.out.println(coll.isEmpty());</code></pre><ol start="6"><li>contains(Object obj):判断当前集合中是否包含obj，<strong>在判断时会调用obj对象所在类的equals()。</strong></li><li>containsAll(Collection coll1):判断形参coll1中的所有元素是否都存在于当前集合中。</li><li>remove(Object obj):从当前集合中移除obj元素。</li><li>removeAll(Collection coll1):差集：从当前集合中移除coll1中所有的元素。</li><li>retainAll(Collection coll1):交集：获取当前集合和coll1集合的交集，<strong>并返回给当前集合</strong></li><li>equals(Object obj):要想返回true，需要当前集合和形参集合的元素都相同。也会调用对象的添加方法，如果其中的元素的有序的要求相同的添加顺序，因为它是有序的，如果其中的元素是无序的就要求内容相同。</li><li>hashCode():返回当前对象的哈希值。</li><li>集合 —&gt;数组：toArray()</li></ol><pre><code class="hljs java">Collection coll = <span class="hljs-keyword">new</span> ArrayList();      coll.add(<span class="hljs-number">123</span>);      coll.add(<span class="hljs-number">456</span>);      coll.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Jerry"</span>,<span class="hljs-number">20</span>));      coll.add(<span class="hljs-keyword">new</span> String(<span class="hljs-string">"Tom"</span>));      coll.add(<span class="hljs-keyword">false</span>);Object[] arr = coll.toArray();      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; arr.length;i++)&#123;          System.out.println(arr[i]);      &#125;</code></pre><ol start="14"><li>数组 —&gt;集合:调用Arrays类的静态方法asList()</li></ol><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"AA"</span>, <span class="hljs-string">"BB"</span>, <span class="hljs-string">"CC"</span>&#125;);      System.out.println(list);</code></pre><ol start="15"><li>iterator():返回Iterator接口的实例，用于遍历集合元素</li></ol><p>Tips：</p><p>使用Collection集合存储对象，要求对象所属的类满足：<br>向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要<strong>重写equals()</strong>。</p><h3 id="关于迭代器"><a href="#关于迭代器" class="headerlink" title="关于迭代器"></a>关于迭代器</h3><p><strong>集合元素的遍历操作，使用迭代器Iterator接口</strong></p><p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8E%9F%E7%90%86%E5%9B%BE.png" srcset="/img/loading.gif" alt="迭代器原理图"></p><ul><li>内部的方法：hasNext() 和  next()</li><li>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</li><li>内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()</li></ul><pre><code class="hljs java">Collection coll = <span class="hljs-keyword">new</span> ArrayList();      coll.add(<span class="hljs-number">123</span>);      coll.add(<span class="hljs-number">456</span>);      coll.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Jerry"</span>,<span class="hljs-number">20</span>));      coll.add(<span class="hljs-keyword">new</span> String(<span class="hljs-string">"Tom"</span>));      coll.add(<span class="hljs-keyword">false</span>);      Iterator iterator = coll.iterator();<span class="hljs-keyword">while</span>(iterator.hasNext())&#123;          <span class="hljs-comment">//next():①指针下移 ②将下移以后集合位置上的元素返回</span>          System.out.println(iterator.next());      &#125;</code></pre><p>Tips:错误写法：</p><pre><code class="hljs java"><span class="hljs-comment">//错误方式一：原因：next():①指针下移 ②将下移以后集合位置上的元素返回，这样相当于下移了两次</span>      Iterator iterator = coll.iterator();      <span class="hljs-keyword">while</span>((iterator.next()) != <span class="hljs-keyword">null</span>)&#123;          System.out.println(iterator.next());      &#125;<span class="hljs-comment">//错误方式二：</span>      <span class="hljs-comment">//集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</span>      <span class="hljs-keyword">while</span> (coll.iterator().hasNext())&#123;          System.out.println(coll.iterator().next());      &#125;</code></pre><p>Iterator中的remove()</p><p>Tips:  Iterator <strong>在工作的时候是不允许被迭代的对象被改变的</strong>。不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式。</p><p>删除元素：</p><pre><code class="hljs java"><span class="hljs-comment">//删除集合中"Tom"</span>      Iterator iterator = coll.iterator();      <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<span class="hljs-comment">// iterator.remove();</span>          Object obj = iterator.next();          <span class="hljs-keyword">if</span>(<span class="hljs-string">"Tom"</span>.equals(obj))&#123;              iterator.remove();<span class="hljs-comment">// iterator.remove();</span>          &#125;</code></pre><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p>jdk5.0新特性–增强for循环：(foreach循环)</p><p><strong>内部仍然调用了迭代器。</strong></p><pre><code class="hljs java">Collection coll = <span class="hljs-keyword">new</span> ArrayList();   coll.add(<span class="hljs-number">123</span>);   coll.add(<span class="hljs-number">456</span>);   coll.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Jerry"</span>,<span class="hljs-number">20</span>));   coll.add(<span class="hljs-keyword">new</span> String(<span class="hljs-string">"Tom"</span>));   coll.add(<span class="hljs-keyword">false</span>);   <span class="hljs-comment">//for(集合元素的类型 局部变量 : 集合对象)</span>      <span class="hljs-keyword">for</span>(Object obj : coll)&#123;       System.out.println(obj);   &#125;</code></pre><h2 id="Collection子接口-List接口"><a href="#Collection子接口-List接口" class="headerlink" title="Collection子接口-List接口"></a>Collection子接口-List接口</h2><p><strong>存储有序的，可以重复的数据</strong></p><h3 id="List接口框架"><a href="#List接口框架" class="headerlink" title="List接口框架"></a>List接口框架</h3><p>|—-Collection接口：单列集合，用来存储一个一个的对象</p><p>​                |—-List接口：存储有序的、可重复的数据。  –&gt;“动态”数组,替换原有的数组</p><p>​                            |—-ArrayList：作为List接口的主要实现类；<strong>线程不安全</strong>的，<strong>效率高</strong>；底层使用Object[] elementData存储</p><p>​                            |—-LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用<strong>双向链表</strong>存储</p><p>​                            |—-Vector：作为List接口的古老实现类；<strong>线程安全</strong>的，<strong>效率低</strong>；底层使用Object[] elementData存储</p><h3 id="各种源码分析"><a href="#各种源码分析" class="headerlink" title="各种源码分析"></a>各种源码分析</h3><p> ArrayList的源码分析：</p><p>jdk 7情况下</p><p>ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData</p><p>list.add(123);//elementData[0] = new Integer(123);</p><p>…</p><p>list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。</p><p>默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</p><p>结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</p><p> jdk 8中ArrayList的变化：</p><p>ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组</p><p>list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</p><p>…</p><p>后续的添加和扩容操作与jdk 7 无异。</p><p>LinkedList的源码分析：</p><p> LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null</p><p>list.add(123);//将123封装到Node中，创建了Node对象。</p><p>Vector的源码分析：</p><p>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</p><p>在扩容方面，默认扩容为原来的数组长度的2倍。</p><p>ArrayList、LinkedList、Vector三者的异同：</p><p>三个类都是实现了List接口，存储数据的特点：存储的都是有序、可重复的数据。</p><p>不同，见源码分析</p><h3 id="List接口中常用的方法"><a href="#List接口中常用的方法" class="headerlink" title="List接口中常用的方法"></a>List接口中常用的方法</h3><p>void add(int index, Object ele):在index位置插入ele元素<br>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来<br>Object get(int index):获取指定index位置的元素<br>int indexOf(Object obj):返回obj在集合中首次出现的位置<br>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置<br>Object remove(int index):移除指定index位置的元素，并返回此元素<br>Object set(int index, Object ele):设置指定index位置的元素为ele<br>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</p><h2 id="Collection的子接口-set接口"><a href="#Collection的子接口-set接口" class="headerlink" title="Collection的子接口-set接口"></a>Collection的子接口-set接口</h2><p>无序性：</p><p>不等于随机性，存储的数据在底层数组中，并非按照数组索引的顺序添加，而是根据数据的哈希值决定的，</p><p>不可重复性：保证的元素的添加按照equals()判断，不能返回true，ye’jiu’shi’shuo相通的元素只添加一个</p><h3 id="Set接口框架"><a href="#Set接口框架" class="headerlink" title="Set接口框架"></a>Set接口框架</h3><p>|—-Collection接口：单列集合，用来存储一个一个的对象</p><p>​                |—-Set接口：存储无序的、不可重复的数据   –&gt;高中讲的“集合”</p><p>​                                |—-HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值</p><p>​                                                |—-LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</p><p>​                                |—-TreeSet：可以照添加对象的指定属性，进行排序。</p><p>说明：</p><p>1、Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。</p><p>2、向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()</p><p>要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码</p><p>重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</p><h3 id="元素的添加过程"><a href="#元素的添加过程" class="headerlink" title="元素的添加过程"></a>元素的添加过程</h3><p>我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，<br>        此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断<br>        数组此位置上是否已经有元素：<br>            如果此位置上没有其他元素，则元素a添加成功。 —&gt;情况1<br>            如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：<br>                如果hash值不相同，则元素a添加成功。—&gt;情况2<br>                如果hash值相同，进而需要调用元素a所在类的equals()方法：<br>                       equals()返回true,元素a添加失败<br>                       equals()返回false,则元素a添加成功。—&gt;情况2</p><p>对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。<br>    jdk 7 :元素a放到数组中，指向原来的元素。<br>    jdk 8 :原来的元素在数组中，指向元素a<br>    总结：七上八下</p><p>HashSet底层：数组+链表的结构。</p><p>关于HashSet的使用：</p><p>LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个<br>数据和后一个数据。<br>优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;        Set set = <span class="hljs-keyword">new</span> LinkedHashSet();        set.add(<span class="hljs-number">456</span>);        set.add(<span class="hljs-number">123</span>);        set.add(<span class="hljs-number">123</span>);        set.add(<span class="hljs-string">"AA"</span>);        set.add(<span class="hljs-string">"CC"</span>);        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Tom"</span>,<span class="hljs-number">12</span>));        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Tom"</span>,<span class="hljs-number">12</span>));        set.add(<span class="hljs-number">129</span>);        Iterator iterator = set.iterator();        <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;            System.out.println(iterator.next());        &#125;    &#125;</code></pre><p>关于TreeSet的使用</p><p>1、向TreeSet中添加的数据，要求是<strong>相同类</strong>的对象。</p><p>2、两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator）</p><p>3、自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals().</p><p>4、定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals().</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;        Comparator com = <span class="hljs-keyword">new</span> Comparator() &#123;            <span class="hljs-comment">//按照年龄从小到大排列</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;                <span class="hljs-keyword">if</span>(o1 <span class="hljs-keyword">instanceof</span> User &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> User)&#123;                    User u1 = (User)o1;                    User u2 = (User)o2;                    <span class="hljs-keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不匹配"</span>);                &#125;            &#125;        &#125;;        TreeSet set = <span class="hljs-keyword">new</span> TreeSet(com);        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Tom"</span>,<span class="hljs-number">12</span>));        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jerry"</span>,<span class="hljs-number">32</span>));        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jim"</span>,<span class="hljs-number">2</span>));        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Mike"</span>,<span class="hljs-number">65</span>));        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Mary"</span>,<span class="hljs-number">33</span>));        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jack"</span>,<span class="hljs-number">33</span>));        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jack"</span>,<span class="hljs-number">56</span>));        Iterator iterator = set.iterator();        <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;            System.out.println(iterator.next());        &#125;    &#125;</code></pre><h2 id="双列集合框架-Map"><a href="#双列集合框架-Map" class="headerlink" title="双列集合框架-Map"></a>双列集合框架-Map</h2><p>Map接口框架</p><p>|—-Map:双列数据，存储key-value对的数据 </p><p>​            |—-HashMap:作为Map的<strong>主要实现类</strong>；<strong>线程不安全</strong>的，效率高；<strong>可以存储null的key和value</strong></p><pre><code>|----LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率高于HashMap。</code></pre><p>​            |—-TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序。底层使用红黑树</p><p>​            |—-Hashtable:作为古老的实现类；<strong>线程安全的</strong>，<strong>效率低</strong>；<strong>不能存储null的key和value</strong></p><p>​                                |—-Properties:常用来处理配置文件。key和value都是String类型</p><p>存储结构的理解：</p><p>Map中的key:无序的、不可重复的，使用Set存储所的key  —&gt; key所在的类要重写equals()和hashCode() （以HashMap为例)<br>Map中的value:无序的、可重复的，使用Collection存储所的value —&gt;value所在的类要重写equals()<br>一个键值对：key-value构成了一个Entry对象。<br>Map中的entry:无序的、不可重复的，使用Set存储所的entry</p><h3 id="HashMap的底层原理"><a href="#HashMap的底层原理" class="headerlink" title="HashMap的底层原理"></a>HashMap的底层原理</h3><p>HashMap map = new HashMap():</p><p>在实例化以后，底层创建了长度是16的一维数组Entry[] table。</p><p>…可能已经执行过多次put…</p><p>map.put(key1,value1):</p><p>首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</p><p>如果此位置上的数据为空，此时的key1-value1添加成功。 —-情况1</p><p>如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值：</p><p>如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。—-情况2</p><p>如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：</p><p>如果equals()返回false:此时key1-value1添加成功。—-情况3</p><p>如果equals()返回true:使用value1替换value2。补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。</p><p>在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p><p>jdk8 相较于jdk7在底层实现方面的不同：</p><p>new HashMap():底层没有创建一个长度为16的数组</p><p>jdk 8底层的数组是：Node[],而非Entry[]</p><p>首次调用put()方法时，底层创建长度为16的数组</p><p>jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。</p><p>形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）<br>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</p><p>HashMap底层典型属性的属性的说明：</p><p> DEFAULT_INITIAL_CAPACITY : HashMap的默认容量：16</p><p>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75</p><p>threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12</p><p>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8</p><p>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p> Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中<br> void putAll(Map m):将m中的所有key-value对存放到当前map中<br> Object remove(Object key)：移除指定key的key-value对，并返回value<br> void clear()：清空当前map中的所有数据<br> 元素查询的操作：<br> Object get(Object key)：获取指定key对应的value<br> boolean containsKey(Object key)：是否包含指定的key<br> boolean containsValue(Object value)：是否包含指定的value<br> int size()：返回map中key-value对的个数<br> boolean isEmpty()：判断当前map是否为空<br> boolean equals(Object obj)：判断当前map和参数对象obj是否相等<br> 元视图操作的方法：<br> Set keySet()：返回所有key构成的Set集合<br> Collection values()：返回所有value构成的Collection集合<br> Set entrySet()：返回所有key-value对构成的Set集合</p><pre><code class="hljs java"><span class="hljs-comment">//遍历所有的key-value</span>        <span class="hljs-comment">//方式一：entrySet()</span>        Set entrySet = map.entrySet();        Iterator iterator1 = entrySet.iterator();        <span class="hljs-keyword">while</span> (iterator1.hasNext())&#123;            Object obj = iterator1.next();            <span class="hljs-comment">//entrySet集合中的元素都是entry</span>            Map.Entry entry = (Map.Entry) obj;            System.out.println(entry.getKey() + <span class="hljs-string">"----&gt;"</span> + entry.getValue());        &#125;        System.out.println();        <span class="hljs-comment">//方式二：</span>        Set keySet = map.keySet();        Iterator iterator2 = keySet.iterator();        <span class="hljs-keyword">while</span>(iterator2.hasNext())&#123;            Object key = iterator2.next();            Object value = map.get(key);            System.out.println(key + <span class="hljs-string">"====="</span> + value);        &#125;</code></pre><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>向TreeMap中添加key-value，要求key必须是由同一个类创建的对象</p><p>因为要按照key进行排序：自然排序 、定制排序</p><p>定制排序：</p><pre><code class="hljs java"><span class="hljs-comment">//定制排序</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;        TreeMap map = <span class="hljs-keyword">new</span> TreeMap(<span class="hljs-keyword">new</span> Comparator() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;                <span class="hljs-keyword">if</span>(o1 <span class="hljs-keyword">instanceof</span> User &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> User)&#123;                    User u1 = (User)o1;                    User u2 = (User)o2;                    <span class="hljs-keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());                &#125;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的类型不匹配！"</span>);            &#125;        &#125;);        User u1 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Tom"</span>,<span class="hljs-number">23</span>);        User u2 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jerry"</span>,<span class="hljs-number">32</span>);        User u3 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jack"</span>,<span class="hljs-number">20</span>);        User u4 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Rose"</span>,<span class="hljs-number">18</span>);        map.put(u1,<span class="hljs-number">98</span>);        map.put(u2,<span class="hljs-number">89</span>);        map.put(u3,<span class="hljs-number">76</span>);        map.put(u4,<span class="hljs-number">100</span>);        Set entrySet = map.entrySet();        Iterator iterator1 = entrySet.iterator();        <span class="hljs-keyword">while</span> (iterator1.hasNext())&#123;            Object obj = iterator1.next();            Map.Entry entry = (Map.Entry) obj;            System.out.println(entry.getKey() + <span class="hljs-string">"----&gt;"</span> + entry.getValue());        &#125;    &#125;</code></pre><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p>Properties:常用来处理配置文件。key和value都是String类型</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;        FileInputStream fis = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            Properties pros = <span class="hljs-keyword">new</span> Properties();            fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"jdbc.properties"</span>);            pros.load(fis);<span class="hljs-comment">//加载流对应的文件</span>            String name = pros.getProperty(<span class="hljs-string">"name"</span>);            String password = pros.getProperty(<span class="hljs-string">"password"</span>);            System.out.println(<span class="hljs-string">"name = "</span> + name + <span class="hljs-string">", password = "</span> + password);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span>(fis != <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-keyword">try</span> &#123;                    fis.close();                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;</code></pre><h2 id="Connections工具类的使用"><a href="#Connections工具类的使用" class="headerlink" title="Connections工具类的使用"></a>Connections工具类的使用</h2><p>Connectionos是操作Collection和Map的工具类</p><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>reverse(List)：反转 List 中元素的顺序<br>shuffle(List)：对 List 集合元素进行随机排序<br>sort(List)：根据元素的自然顺序对指定 List 集合元素升序排序<br>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序<br>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换<br>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素<br>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素<br>Object min(Collection)<br>Object min(Collection，Comparator)<br>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数<br>void copy(List dest,List src)：将src中的内容复制到dest中<br>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所旧值</p><p>说明：ArrayList和HashMap都是线程不安全的，如果程序要求线程安全，我们可以将ArrayList、HashMap转换为线程的。<br>使用synchronizedList(List list） 和 synchronizedMap(Map map）</p><pre><code class="hljs java"><span class="hljs-comment">//返回的list1即为线程安全的List</span>        List list1 = Collections.synchronizedList(list);</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring———1</title>
    <link href="/2020/05/15/Spring%E2%80%94%E2%80%94%E2%80%941/"/>
    <url>/2020/05/15/Spring%E2%80%94%E2%80%94%E2%80%941/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>Spring梳理</font></div><hr><h2 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h2><p>​      Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control： 反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>方便解耦，简化开发 </li><li>AOP编程的支持 </li><li>声明式事务的支持 </li><li>方便程序的测试 </li><li>方便集成各种优秀框架 </li><li>降低 JavaEE API的使用难度 </li><li>Java源码是经典学习范例</li></ol><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>控制反转-Inversion Of Control </p><p>ioc的作用： </p><p>削减计算机程序的耦合(解除我们代码中的依赖关系)。 </p><h3 id="IOC解决程序耦合"><a href="#IOC解决程序耦合" class="headerlink" title="IOC解决程序耦合"></a>IOC解决程序耦合</h3><ol><li><p>准备必要的jar包</p></li><li><p>在根路径下创建一个xml文件（不可以是中文）,导入约束</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag"> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag"> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></li><li><p>让spring管理资源，也就是在配置文件中进行相应的配置，使其可以创建对象，并存入ioc容器中</p><p>使用了bean标签 </p><p>id属性：对象唯一标识</p><p>class属性：指定要创建对象的全限定类名</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置 service --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span> <span class="hljs-comment">&lt;!-- 配置 dao --&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountDao"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.dao.impl.AccountDaoImpl"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  <span class="hljs-comment">//1.获取核心容器对象</span><span class="hljs-comment">//        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");</span>        ClassPathXmlApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"bean.xml"</span>);        <span class="hljs-comment">//2.根据id获取Bean对象</span>        IAccountService as  = (IAccountService)ac.getBean(<span class="hljs-string">"accountService"</span>);        as.saveAccount();        <span class="hljs-comment">//手动关闭容器</span>        ac.close();    &#125;</code></pre><h3 id="IOC细节"><a href="#IOC细节" class="headerlink" title="IOC细节"></a>IOC细节</h3><ul><li>BeanFactory和 ApplicationContext 的区别 </li></ul><pre><code class="hljs xml">BeanFactory 才是 Spring 容器中的顶层接口。ApplicationContext 是它的子接口。BeanFactory 和 ApplicationContext 的区别： 创建对象的时间点不一样。   ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。   BeanFactory：什么使用什么时候创建对象。</code></pre><ul><li>ApplicationContext 接口的实现类 </li></ul><pre><code class="hljs xml">ClassPathXmlApplicationContext：它是从类的根路径下加载配置文件  推荐使用这种 FileSystemXmlApplicationContext：它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 AnnotationConfigApplicationContext: 当我们使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</code></pre><h3 id="ICO中bean标签管理对象的细节"><a href="#ICO中bean标签管理对象的细节" class="headerlink" title="ICO中bean标签管理对象的细节"></a>ICO中bean标签管理对象的细节</h3><p>创建bean的三种方式</p><ol><li>使用默认构造函数创建</li></ol><pre><code class="hljs xml">在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时。采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><ol start="2"><li>使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入IOC中）</li></ol><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 模拟一个工厂类（该类可能是存在于jar包中的，我们无法通过修改源码的方式来提供默认构造函数）</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> IAccountService <span class="hljs-title">getAccountService</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AccountServiceImpl();    &#125;&#125;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"instanceFactory"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.factory.InstanceFactory"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"instanceFactory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getAccountService"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><ol start="3"><li>使用工厂中的<strong>静态方法</strong>创建对象（使用某个类中的<strong>静态方法</strong>创建对象，并存入IOC中）</li></ol><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 模拟一个工厂类（该类可能是存在于jar包中的，我们无法通过修改源码的方式来提供默认构造函数）</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IAccountService <span class="hljs-title">getAccountService</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AccountServiceImpl();    &#125;&#125;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.factory.StaticFactory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getAccountService"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>bean标签的作用范围</p><pre><code class="hljs xml">bean标签的scope属性：作用：用于指定bean的作用范围取值： 常用的就是单例的和多例的singleton：单例的（默认值）prototype：多例的request：作用于web应用的请求范围session：作用于web应用的会话范围global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl"</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"prototype"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>bean标签的生命周期</p><pre><code class="hljs xml">bean对象的生命周期单例对象出生：当容器创建时对象出生活着：只要容器还在，对象一直活着死亡：容器销毁，对象消亡,destory需要手动调用总结：单例对象的生命周期和容器相同 多例对象出生：当我们使用对象时spring框架为我们创建活着：对象只要是在使用过程中就一直活着。死亡：当对象长时间不用，且没有别的对象引用时，由Java的垃圾回收器回收</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAccountService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountServiceImpl</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"对象创建了"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">saveAccount</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"service中的saveAccount方法执行了。。。"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"对象初始化了。。。"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"对象销毁了。。。"</span>);    &#125;&#125;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl"</span></span><span class="hljs-tag">          <span class="hljs-attr">scope</span>=<span class="hljs-string">"prototype"</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">"init"</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">"destroy"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><h3 id="spring的依赖注入"><a href="#spring的依赖注入" class="headerlink" title="spring的依赖注入"></a>spring的依赖注入</h3><p>​        依赖注入：Dependency Injection。它是 spring 框架核心 ioc 的具体实现。依赖注入：Dependency Injection。它是 spring 框架核心 ioc 的具体实现。依赖关系的管理都交给spring来维护，在当前类需要用到其他类的对象，有spring来提供，我们只需要在配置文件中说明</p><p>依赖注入能注入的数据有三类：基本类型和String，其他bean类型，复杂（集合）类型</p><p>注入方式有三种：</p><ol><li>使用构造函数   </li></ol><pre><code class="hljs xml">使用的标签:constructor-arg标签出现的位置：bean标签的内部标签中的属性type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始name：用于指定给构造函数中指定名称的参数赋值常用的=============以上三个用于指定给构造函数中哪个参数赋值===============================value：用于提供基本类型和String类型的数据ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。弊端：改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。</code></pre><pre><code class="hljs xml">bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt;        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"泰斯特"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"18"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"birthday"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"now"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置一个日期对象 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"now"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"java.util.Date"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>涉及到的类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAccountService</span> </span>&#123;    <span class="hljs-comment">//如果是经常变化的数据，并不适用于注入的方式</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> Date birthday;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountServiceImpl</span><span class="hljs-params">(String name,Integer age,Date birthday)</span></span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;        <span class="hljs-keyword">this</span>.birthday = birthday;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">saveAccount</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"service中的saveAccount方法执行了。。。"</span>+name+<span class="hljs-string">","</span>+age+<span class="hljs-string">","</span>+birthday);    &#125;&#125;</code></pre><ol start="2"><li>set方法注入（较为常用）</li></ol><pre><code class="hljs xml">涉及的标签：property        出现的位置：bean标签的内部        标签的属性            name：用于指定注入时所调用的set方法名称            value：用于提供基本类型和String类型的数据            ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象        优势：            创建对象时没有明确的限制，可以直接使用默认构造函数        弊端：            如果有某个成员必须有值，则获取对象是有可能set方法没有执行。</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService2"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl2"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"TEST"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"21"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"birthday"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"now"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>涉及的类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAccountService</span> </span>&#123;    <span class="hljs-comment">//如果是经常变化的数据，并不适用于注入的方式</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> Date birthday;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBirthday</span><span class="hljs-params">(Date birthday)</span> </span>&#123;        <span class="hljs-keyword">this</span>.birthday = birthday;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">saveAccount</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"service中的saveAccount方法执行了。。。"</span>+name+<span class="hljs-string">","</span>+age+<span class="hljs-string">","</span>+birthday);    &#125;&#125;</code></pre><ol start="3"><li>复杂类型/集合类型注入</li></ol><pre><code class="hljs xml">用于给List结构集合注入的标签：list array set用于个Map结构集合注入的标签:map  props结构相同，标签可以互换</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService3"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl3"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myStrs"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>AAA<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>BBB<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>CCC<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myList"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>AAA<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>BBB<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>CCC<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mySet"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>AAA<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>BBB<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>CCC<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myMap"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"testC"</span>&gt;</span>ccc<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"testD"</span>&gt;</span>ddd<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myProps"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"testA"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"aaa"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"testB"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>BBB<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>涉及的类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAccountService</span> </span>&#123;    <span class="hljs-keyword">private</span> String[] myStrs;    <span class="hljs-keyword">private</span> List&lt;String&gt; myList;    <span class="hljs-keyword">private</span> Set&lt;String&gt; mySet;    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; myMap;    <span class="hljs-keyword">private</span> Properties myProps;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMyStrs</span><span class="hljs-params">(String[] myStrs)</span> </span>&#123;        <span class="hljs-keyword">this</span>.myStrs = myStrs;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMyList</span><span class="hljs-params">(List&lt;String&gt; myList)</span> </span>&#123;        <span class="hljs-keyword">this</span>.myList = myList;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMySet</span><span class="hljs-params">(Set&lt;String&gt; mySet)</span> </span>&#123;        <span class="hljs-keyword">this</span>.mySet = mySet;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMyMap</span><span class="hljs-params">(Map&lt;String, String&gt; myMap)</span> </span>&#123;        <span class="hljs-keyword">this</span>.myMap = myMap;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMyProps</span><span class="hljs-params">(Properties myProps)</span> </span>&#123;        <span class="hljs-keyword">this</span>.myProps = myProps;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">saveAccount</span><span class="hljs-params">()</span></span>&#123;        System.out.println(Arrays.toString(myStrs));        System.out.println(myList);        System.out.println(mySet);        System.out.println(myMap);        System.out.println(myProps);    &#125;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java常用类——String、StringBuffer、StringBuilder</title>
    <link href="/2020/05/15/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E2%80%94%E2%80%94String%E3%80%81StringBuffer%E3%80%81StringBuilder/"/>
    <url>/2020/05/15/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E2%80%94%E2%80%94String%E3%80%81StringBuffer%E3%80%81StringBuilder/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>Java常用类——String、StringBuffer、StringBuilder</font></div>   <hr><font size='4'>   <h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>使用一对””引起来表示（java.lang.String类）<br>1、String声明为final，不可被继承<br>2、String实现了Serializable接口，表示字符串是支持可序列化的<br>emsp;emsp;实现了Comparable接口，表示String可以比较大小<br>3、内部定义了final char[] values用于存储字符串数据<br>4、String代表不可变的字符序列，简称：<strong>不可变性</strong><br>emsp;emsp;也就是说，当字符串重新赋值时，需要重写指定内存区域赋值，不可使用原有的values进行赋值<br>emsp;emsp;当对现有的字符串进行<strong>连接操作</strong>的时候，也需要重新指定内存区赋值，不可使用原有的value进行赋值<br>emsp;emsp;当调用String的<strong>replace()</strong>方法修改指定的字符或者字符串时，也需要指定内存区域，不能使用原有的value进行赋值<br>5、通过<strong>字面量</strong>的方式（例如： String s1 = “abc”;）给一个字符串赋值，此时，字符串声明在常量池中<br>6、字符串常量池中，<strong>不会存储相同的字符串</strong>    </p><h3 id="String实例化的方式"><a href="#String实例化的方式" class="headerlink" title="String实例化的方式"></a>String实例化的方式</h3><p>方式一：通过字面量定义的方式   </p><p>这种方式将javaEE声明在方法区中的字符串常量池中<br><font size='5'></p><pre><code>String s1 = &quot;javaEE&quot;;String s2 = &quot;javaEE&quot;;</code></pre></font><p>方式二：通过new + 构造器的方式   </p><p>引用中保存的是地址值，是数据在堆空间中开辟空间以后对应的地址值<br><font size='5'></p><pre><code>String s3 = new String(&quot;javaEE&quot;);String s4 = new String(&quot;javaEE&quot;);    </code></pre></font>   两者的==情况：   <font size='5'><pre><code>System.out.println(s1 == s2);//trueSystem.out.println(s1 == s3);//falseSystem.out.println(s1 == s4);//falseSystem.out.println(s3 == s4);//false </code></pre></font><p>细节上：   </p><p>1、常量与常量拼接的结果在常量池中，而且常量池中不会存在相同内容的常量<br>2、只要拼接时有一个时变量，结果就在堆中（例如当对现有的String进行再拼接时，其实是重新指定了内存区域的），如果不加final的话，因为加了final的变为常量<br><font size='5'></p><pre><code>String s1 = &quot;javaEEhadoop&quot;;final  String s2 = &quot;javaEE&quot;;String s3 = s2 + &quot;hadoop&quot;;System.out.println(s1 == s3);//true     </code></pre></font>   ![字面量赋值和new的区别](https://github.com/BunnyAndOak0/IMG/raw/master/images/%E5%AD%97%E9%9D%A2%E9%87%8F%E8%B5%8B%E5%80%BC%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB.png)      <p>Tips:<br>JVM中字符串常量池存放位置说明：<br>jdk 1.6 (jdk 6.0 ,java 6.0):字符串常量池存储在方法区（永久区）<br>jdk 1.7:字符串常量池存储在堆空间<br>jdk 1.8:字符串常量池存储在方法区（元空间）   </p><p>3、如果拼接结果调用intern()方法，返回值就在<strong>常量池</strong>中   </p><p>例如：<br><font size='5'></p><pre><code>public void test4(){    String s1 = &quot;javaEEhadoop&quot;;    String s2 = &quot;javaEE&quot;;    String s3 = s2 + &quot;hadoop&quot;;    System.out.println(s1 == s3);//false    final String s4 = &quot;javaEE&quot;;//s4:常量    String s5 = s4 + &quot;hadoop&quot;;    System.out.println(s1 == s5);//true}   </code></pre></font><p>使用intern()方法<br><font size='5'></p><pre><code>    public void test3(){    String s1 = &quot;javaEE&quot;;    String s2 = &quot;hadoop&quot;;    String s3 = &quot;javaEEhadoop&quot;;    String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;;    String s5 = s1 + &quot;hadoop&quot;;    String s6 = &quot;javaEE&quot; + s2;    String s7 = s1 + s2;    System.out.println(s3 == s4);//true    System.out.println(s3 == s5);//false    System.out.println(s3 == s6);//false    System.out.println(s3 == s7);//false    System.out.println(s5 == s6);//false    System.out.println(s5 == s7);//false    System.out.println(s6 == s7);//false    String s8 = s6.intern();//返回值得到的s8使用的常量值中已经存在的“javaEEhadoop”    System.out.println(s3 == s8);//true}   </code></pre></font><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>int length()：返回字符串的长度： return value.length<br>char charAt(int index)： 返回某索引处的字符return value[index]<br>boolean isEmpty()：判断是否是空字符串：return value.length == 0<br>String toLowerCase()：使用默认语言环境，将 String 中的所字符转换为小写<br>String toUpperCase()：使用默认语言环境，将 String 中的所字符转换为大写<br>String trim()：返回字符串的副本，忽略前导空白和尾部空白<br>boolean equals(Object obj)：比较字符串的内容是否相同<br>boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写<br>String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”<br>int compareTo(String anotherString)：比较两个字符串的大小<br>String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。<br>String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。<strong>左闭右开</strong>   </p><p>boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束<br>boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始<br>boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始<br>boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true<br>int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引<br>int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始<br>int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引<br>int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索   </p><p>注：indexOf和lastIndexOf方法如果未找到都是返回-1   </p><p>替换：<br>String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所 oldChar 得到的。<br>String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串。<br>String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所匹配给定的正则表达式的子字符串。<br>String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。<br>匹配:<br>boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。<br>切片：<br>String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。<br>String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。   </p><h3 id="String与其他类型的转换"><a href="#String与其他类型的转换" class="headerlink" title="String与其他类型的转换"></a>String与其他类型的转换</h3><p>1、String 与基本数据类型、包装类之间的转换。<br>String –&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)<br>基本数据类型、包装类 –&gt; String:调用String重载的valueOf(xxx)<br><font size='5'></p><pre><code>    @Testpublic void test1(){    String str1 = &quot;123&quot;;//   int num = (int)str1;//错误的    int num = Integer.parseInt(str1);    String str2 = String.valueOf(num);//&quot;123&quot;    String str3 = num + &quot;&quot;;    System.out.println(str1 == str3);    }}   </code></pre></font><p>2、String 与 char[]之间的转换<br>String –&gt; char[]:调用String的toCharArray()<br>char[] –&gt; String:<strong>调用String的构造器</strong>(ball ball you 不要再错在这里了！！！)<br><font size='5'></p><pre><code>public void test2(){    String str1 = &quot;abc123&quot;;  //题目： a21cb3    char[] charArray = str1.toCharArray();    for (int i = 0; i &lt; charArray.length; i++) {        System.out.println(charArray[i]);    }    char[] arr = new char[]{&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;};    String str2 = new String(arr);    System.out.println(str2);}   </code></pre></font><p>3、String 与 byte[]之间的转换<br>编码：String –&gt; byte[]:调用String的getBytes()<br>解码：byte[] –&gt; String:调用String的构造器   </p><p>编码：字符串 –&gt;字节  (看得懂 —&gt;看不懂的二进制数据)<br>解码：编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂）   </p><p>说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。<br><font size='5'></p><pre><code>public void test3() throws UnsupportedEncodingException {    String str1 = &quot;abc123中国&quot;;    byte[] bytes = str1.getBytes();//使用默认的字符集，进行编码。    System.out.println(Arrays.toString(bytes));    byte[] gbks = str1.getBytes(&quot;gbk&quot;);//使用gbk字符集进行编码。    System.out.println(Arrays.toString(gbks));    System.out.println(&quot;******************&quot;);    String str2 = new String(bytes);//使用默认的字符集，进行解码。    System.out.println(str2);    String str3 = new String(gbks);    System.out.println(str3);//出现乱码。原因：编码集和解码集不一致！    String str4 = new String(gbks, &quot;gbk&quot;);    System.out.println(str4);//没有出现乱码。原因：编码集和解码集一致！}   </code></pre></font><h3 id="与字符串相关的类"><a href="#与字符串相关的类" class="headerlink" title="与字符串相关的类"></a>与字符串相关的类</h3><p>与StringBuffer、StringBuilder之间的转换<br>String –&gt; StringBuffer、StringBuilder:调用StringBuffer、StringBuilder构造器<br>StringBuffer、StringBuilder –&gt; String:①调用String构造器；②StringBuffer、StringBuilder的toString()   </p><p>String、StringBuffer、StringBuilder三者的异同<br>String:不可变的字符序列；底层使用char[]存储<br>StringBuffer:可变的字符序列；<strong>线程安全</strong>的，<strong>效率低</strong>；底层使用char[]存储<br>StringBuilder:可变的字符序列；jdk5.0新增的，<strong>线程不安全</strong>的，<strong>效率高</strong>；底层使用char[]存储    </p><p>TIps：<br>源码分析：<br>String str = new String();//char[] value = new char[0];<br>tring str1 = new String(“abc”);//char[] value = new char[]{‘a’,’b’,’c’};<br>StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。<br>System.out.println(sb1.length());<br>sb1.append(‘a’);//value[0] = ‘a’;<br>sb1.append(‘b’);//value[1] = ‘b’;   </p><p>扩容问题:<br>如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。<br>默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。   </p><p>StringBuffer的常用方法：<br>StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接<br>StringBuffer delete(int start,int end)：删除指定位置的内容<br>StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str<br>StringBuffer insert(int offset, xxx)：在指定位置插入xxx<br>StringBuffer reverse() ：把当前字符序列逆转<br>public int indexOf(String str)<br>public String substring(int start,int end):返回一个从start开始到end索引结束的左闭右开区间的子字符串<br>public int length()<br>public char charAt(int n )<br>public void setCharAt(int n ,char ch)   </p><p>遍历：for() + charAt() / toString()   </p><p>对比String、StringBuffer、StringBuilder三者的效率：<br>从高到低排列：StringBuilder &gt; StringBuffer &gt; String   </p></font>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java常用类——Date、比较器、其他类</title>
    <link href="/2020/05/15/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E2%80%94%E2%80%94Date%E3%80%81%E6%AF%94%E8%BE%83%E5%99%A8%E3%80%81%E5%85%B6%E4%BB%96%E7%B1%BB/"/>
    <url>/2020/05/15/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E2%80%94%E2%80%94Date%E3%80%81%E6%AF%94%E8%BE%83%E5%99%A8%E3%80%81%E5%85%B6%E4%BB%96%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>Java常用类——Date、比较器、其他类</font></div> <hr><h2 id="JDK8之前的日期API"><a href="#JDK8之前的日期API" class="headerlink" title="JDK8之前的日期API"></a>JDK8之前的日期API</h2><h3 id="System类中的currentTimeMillis"><a href="#System类中的currentTimeMillis" class="headerlink" title="System类中的currentTimeMillis()"></a>System类中的currentTimeMillis()</h3><p><font size='4'>返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差，称为时间戳</font></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">long</span> time = System.currentTimeMillis();        <span class="hljs-comment">//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</span>        System.out.println(time);    &#125;</code></pre><h3 id="java-util-Date类和java-sql-Date类"><a href="#java-util-Date类和java-sql-Date类" class="headerlink" title="java.util.Date类和java.sql.Date类"></a>java.util.Date类和java.sql.Date类</h3><p>java.util.Date类 </p><p>&emsp;&emsp;&emsp;|—java.sql.Date类  </p><p>1、两个构造器的使用  </p><p> 构造器一：Date()：创建一个对应当前时间的Date对象  </p><p> 构造器二：创建指定毫秒数的Date对象</p><pre><code class="hljs jav">&#x2F;&#x2F;构造器一：Date()：创建一个对应当前时间的Date对象   Date date1 &#x3D; new Date();   System.out.println(date1.toString());&#x2F;&#x2F;Sat Feb 16 16:35:31 GMT+08:00 2019   System.out.println(date1.getTime());&#x2F;&#x2F;1550306204104</code></pre><p>2、两个方法的使用<br> toString():显示当前的年、月、日、时、分、秒<br> getTime():获取当前Date对象对应的毫秒数。（时间戳）</p><pre><code class="hljs jav">&#x2F;&#x2F;构造器二：创建指定毫秒数的Date对象   Date date2 &#x3D; new Date(155030620410L);   System.out.println(date2.toString());</code></pre><p>3、java.sql.Date对应着数据库中的日期类型的变量  </p><pre><code class="hljs ja">&#x2F;&#x2F;创建java.sql.Date对象   java.sql.Date date3 &#x3D; new java.sql.Date(35235325345L);   System.out.println(date3);&#x2F;&#x2F;1971-02-13     &#x2F;&#x2F;将java.util.Date对象转换为java.sql.Date对象   &#x2F;&#x2F;情况一：&#x2F;&#x2F;  Date date4 &#x3D; new java.sql.Date(2343243242323L);&#x2F;&#x2F;  java.sql.Date date5 &#x3D; (java.sql.Date) date4;   &#x2F;&#x2F;情况二：   Date date6 &#x3D; new Date();   java.sql.Date date7 &#x3D; new java.sql.Date(date6.getTime());</code></pre><h3 id="java-text-SimpleDataFormat类"><a href="#java-text-SimpleDataFormat类" class="headerlink" title="java.text.SimpleDataFormat类"></a>java.text.SimpleDataFormat类</h3><p>SimpleDateFormat对日期Date类的格式化和解析  </p><p> 1、格式化：日期 —&gt; 字符串  </p><p> 2、解析：格式化的逆过程，字符串 —&gt; 日期  </p><p> 3、SimpleDateFormat的实例化:new + 构造器</p><pre><code class="hljs ja">@Test   public void testSimpleDateFormat() throws ParseException &#123;       &#x2F;&#x2F;实例化SimpleDateFormat:使用默认的构造器       SimpleDateFormat sdf &#x3D; new SimpleDateFormat();       &#x2F;&#x2F;格式化：日期 ---&gt;字符串       Date date &#x3D; new Date();       System.out.println(date);       String format &#x3D; sdf.format(date);       System.out.println(format);       &#x2F;&#x2F;解析：格式化的逆过程，字符串 ---&gt; 日期       String str &#x3D; &quot;19-12-18 上午11:43&quot;;       Date date1 &#x3D; sdf.parse(str);       System.out.println(date1);       &#x2F;&#x2F;*************按照指定的方式格式化和解析：调用带参的构造器*****************&#x2F;&#x2F; SimpleDateFormat sdf1 &#x3D; new SimpleDateFormat(&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;);       SimpleDateFormat sdf1 &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);       &#x2F;&#x2F;格式化       String format1 &#x3D; sdf1.format(date);       System.out.println(format1);&#x2F;&#x2F;2019-02-18 11:48:27       &#x2F;&#x2F;解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现),       &#x2F;&#x2F;否则，抛异常       Date date2 &#x3D; sdf1.parse(&quot;2020-02-18 11:48:27&quot;);       System.out.println(date2);&#x2F;&#x2F;Tue Feb 18 11:48:27 CST 2020   &#125;</code></pre><h3 id="Calendar类：日历类、抽象类"><a href="#Calendar类：日历类、抽象类" class="headerlink" title="Calendar类：日历类、抽象类"></a>Calendar类：日历类、抽象类</h3><p>1、实例化  </p><p> 方式一：创建其子类（GregorianCalendar的对象  </p><p> 方式二：调用其静态方法getInstance()  </p><pre><code class="hljs ja">Calendar calendar &#x3D; Calendar.getInstance();&#x2F;&#x2F;System.out.println(calendar.getClass());</code></pre><p>2、常用方法  </p><p> get()</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> days = calendar.get(Calendar.DAY_OF_MONTH);System.out.println(days);System.out.println(calendar.get(Calendar.DAY_OF_YEAR));</code></pre><p>set()</p><pre><code class="hljs java"><span class="hljs-comment">//calendar可变性</span>calendar.set(Calendar.DAY_OF_MONTH,<span class="hljs-number">22</span>);days = calendar.get(Calendar.DAY_OF_MONTH);System.out.println(days);</code></pre><p>add()</p><pre><code class="hljs java">calendar.add(Calendar.DAY_OF_MONTH,-<span class="hljs-number">3</span>);days = calendar.get(Calendar.DAY_OF_MONTH);System.out.println(days);</code></pre><p>getTime():日历类—&gt; Date </p><pre><code class="hljs java">Date date = calendar.getTime();System.out.println(date);</code></pre><p>setTime():Date —&gt; 日历类</p><pre><code class="hljs java">Date date1 = <span class="hljs-keyword">new</span> Date();calendar.setTime(date1);days = calendar.get(Calendar.DAY_OF_MONTH);System.out.println(days);</code></pre><h3 id="JDK8中新的日期时API"><a href="#JDK8中新的日期时API" class="headerlink" title="JDK8中新的日期时API"></a>JDK8中新的日期时API</h3><p>迭代  </p><p> 第一代：jdk 1.0 Date类  </p><p> 第二代：jdk 1.1 Calendar类，一定程度上替换Date类  </p><p> 第三代：jdk 1.8 提出了新的一套API  </p><p> 存在问题  </p><p> 可变性：像日期和时间这样的类应该是不可变的。  </p><p> 偏移性：Date中的年份是从1900开始的，而月份都从0开始。  </p><p> 格式化：格式化只对Date用，Calendar则不行。  </p><p> 此外，它们也不是线程安全的；不能处理闰秒等。  </p><p> 1、LocalDate、LocalTime、LocalDateTime 的使用  </p><p> 说明：  </p><p> LocalDateTime相较于LocalDate、LocalTime，使用频率要高  </p><p> 类似于Calendar  </p><p> <img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/LocalDateTime.png" srcset="/img/loading.gif" alt="LocalDateTime">  </p><p> 2、Instant的使用  </p><p> 类似于 java.util.Date类  </p><p> <img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/Instant.png" srcset="/img/loading.gif" alt="Instant"></p><p> 3、DateTimeFormatter  </p><p> 格式化或解析日期、时间  </p><p> 类似于SimpleDateFormat </p><pre><code class="hljs java"><span class="hljs-comment">//  重点：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</span>DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd hh:mm:ss"</span>);<span class="hljs-comment">//格式化</span>String str4 = formatter3.format(LocalDateTime.now());System.out.println(str4);<span class="hljs-comment">//2019-02-18 03:52:09</span><span class="hljs-comment">//解析</span>TemporalAccessor accessor = formatter3.parse(<span class="hljs-string">"2019-02-18 03:52:09"</span>);System.out.println(accessor);</code></pre><p><img src="https://github.com/BunnyAndOak0/IMG/blob/master/images/DateTimeFormatter.png" srcset="/img/loading.gif" alt="DateTimeFormatter"></p><h2 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h2><p>System类  </p><p> System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。<br> 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。  </p><p> 方法：  </p><p> native long currentTimeMillis()  </p><p> void exit(int status)  </p><p> void gc()  </p><p> String getProperty(String key) </p><pre><code class="hljs java">String javaVersion = System.getProperty(<span class="hljs-string">"java.version"</span>);System.out.println(<span class="hljs-string">"java的version:"</span> + javaVersion);String javaHome = System.getProperty(<span class="hljs-string">"java.home"</span>);System.out.println(<span class="hljs-string">"java的home:"</span> + javaHome);</code></pre><p>Math类  </p><p> java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。  </p><p> BigInteger类、BigDecimal类  </p><p> java.math包的BigInteger可以表示不可变的任意精度的整数  </p><p> 要求数字精度比较高，用到java.math.BigDecimal类</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;        BigInteger bi = <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">"1243324112234324324325235245346567657653"</span>);        BigDecimal bd = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"12435.351"</span>);        BigDecimal bd2 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"11"</span>);        System.out.println(bi);<span class="hljs-comment">//1243324112234324324325235245346567657653</span>        <span class="hljs-comment">//  System.out.println(bd.divide(bd2));</span>        System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));<span class="hljs-comment">//1130.486</span>        System.out.println(bd.divide(bd2, <span class="hljs-number">25</span>, BigDecimal.ROUND_HALF_UP));<span class="hljs-comment">//1130.4864545454545454545454545</span>    &#125;</code></pre><h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p>使用场景  </p><p> Java中的对象，正常情况下，只能进行比较：== 或 != 。不能使用 &gt; 或 &lt; 的但是在开发场景中，我们需要对多个对象进行排序，就可以使用两个接口中的任何一个：Comparable 或 Comparator  </p><p> 1、Comparable接口的使用举例：自然排序  </p><p> 像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。  </p><p> 像String、包装类重写compareTo()方法以后，进行了从小到大的排列  </p><p> 重写compareTo(obj)的规则：  </p><p> &emsp;&emsp;如果当前对象this大于形参对象obj，则返回正整数，  </p><p> &emsp;&emsp;如果当前对象this小于形参对象obj，则返回负整数，  </p><p> &emsp;&emsp;如果当前对象this等于形参对象obj，则返回零。  </p><p> 对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。在compareTo(obj)方法中指明如何排序  </p><p> 例如：在String中</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;        String[] arr = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"AA"</span>,<span class="hljs-string">"CC"</span>,<span class="hljs-string">"KK"</span>,<span class="hljs-string">"MM"</span>,<span class="hljs-string">"GG"</span>,<span class="hljs-string">"JJ"</span>,<span class="hljs-string">"DD"</span>&#125;;        Arrays.sort(arr);        System.out.println(Arrays.toString(arr));    &#125;</code></pre><p>在自定义类中 </p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;        Goods[] arr = <span class="hljs-keyword">new</span> Goods[<span class="hljs-number">5</span>];        arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"lenovoMouse"</span>,<span class="hljs-number">34</span>);        arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"dellMouse"</span>,<span class="hljs-number">43</span>);        arr[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"xiaomiMouse"</span>,<span class="hljs-number">12</span>);        arr[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"huaweiMouse"</span>,<span class="hljs-number">65</span>);        arr[<span class="hljs-number">4</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"microsoftMouse"</span>,<span class="hljs-number">43</span>);        Arrays.sort(arr);        System.out.println(Arrays.toString(arr));    &#125;</code></pre><p>先实现Comparable接口： </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Goods</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">Comparable</span></span></code></pre><p>重新compareTo()方法：</p><pre><code class="hljs java"><span class="hljs-comment">//指明商品比较大小的方式:按照价格从低到高排序,再按照产品名称从高到低排序</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;<span class="hljs-comment">//  System.out.println("**************");</span>        <span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Goods)&#123;            Goods goods = (Goods)o;            <span class="hljs-comment">//方式一：</span>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.price &gt; goods.price)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.price &lt; goods.price)&#123;                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//    return 0;</span>               <span class="hljs-keyword">return</span> -<span class="hljs-keyword">this</span>.name.compareTo(goods.name);            &#125;            <span class="hljs-comment">//方式二：</span><span class="hljs-comment">//   return Double.compare(this.price,goods.price);</span>        &#125;<span class="hljs-comment">//   return 0;</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"传入的数据类型不一致！"</span>);    &#125;</code></pre><hr><p>2、Comparator接口的使用：定制排序 </p><p>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序  </p><p> 重写compare(Object o1,Object o2)方法，比较o1和o2的大小：  </p><p> 如果方法返回正整数，则表示o1大于o2；  </p><p> 如果返回0，表示相等；  </p><p> 返回负整数，表示o1小于o2。  </p><p> 例如Stirng类型定制排序： </p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;        String[] arr = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"AA"</span>,<span class="hljs-string">"CC"</span>,<span class="hljs-string">"KK"</span>,<span class="hljs-string">"MM"</span>,<span class="hljs-string">"GG"</span>,<span class="hljs-string">"JJ"</span>,<span class="hljs-string">"DD"</span>&#125;;        Arrays.sort(arr,<span class="hljs-keyword">new</span> Comparator()&#123;            <span class="hljs-comment">//按照字符串从大到小的顺序排列</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;                <span class="hljs-keyword">if</span>(o1 <span class="hljs-keyword">instanceof</span> String &amp;&amp; o2 <span class="hljs-keyword">instanceof</span>  String)&#123;                    String s1 = (String) o1;                    String s2 = (String) o2;                    <span class="hljs-keyword">return</span> -s1.compareTo(s2);                &#125;<span class="hljs-comment">// return 0;</span>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不一致"</span>);            &#125;        &#125;);        System.out.println(Arrays.toString(arr));    &#125;</code></pre><p>例如自定义类定制排序：</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span>&#123;        Goods[] arr = <span class="hljs-keyword">new</span> Goods[<span class="hljs-number">6</span>];        arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"lenovoMouse"</span>,<span class="hljs-number">34</span>);        arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"dellMouse"</span>,<span class="hljs-number">43</span>);        arr[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"xiaomiMouse"</span>,<span class="hljs-number">12</span>);        arr[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"huaweiMouse"</span>,<span class="hljs-number">65</span>);        arr[<span class="hljs-number">4</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"huaweiMouse"</span>,<span class="hljs-number">224</span>);        arr[<span class="hljs-number">5</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"microsoftMouse"</span>,<span class="hljs-number">43</span>);        Arrays.sort(arr, <span class="hljs-keyword">new</span> Comparator() &#123;            <span class="hljs-comment">//指明商品比较大小的方式:按照产品名称从低到高排序,再按照价格从高到低排序</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;                <span class="hljs-keyword">if</span>(o1 <span class="hljs-keyword">instanceof</span> Goods &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> Goods)&#123;                    Goods g1 = (Goods)o1;                    Goods g2 = (Goods)o2;                    <span class="hljs-keyword">if</span>(g1.getName().equals(g2.getName()))&#123;                        <span class="hljs-keyword">return</span> -Double.compare(g1.getPrice(),g2.getPrice());                    &#125;<span class="hljs-keyword">else</span>&#123;                        <span class="hljs-keyword">return</span> g1.getName().compareTo(g2.getName());                    &#125;                &#125;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不一致"</span>);            &#125;        &#125;);        System.out.println(Arrays.toString(arr));    &#125;</code></pre><p>例如，定义了comparator的比较方法之后：  </p><pre><code class="hljs java">Comparator com = <span class="hljs-keyword">new</span> Comparator() &#123;    <span class="hljs-comment">//指明商品比较大小的方式:照产品名称从低到高排序,再照价格从高到低排序</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;        <span class="hljs-keyword">if</span>(o1 <span class="hljs-keyword">instanceof</span> Goods &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> Goods)&#123;            Goods g1 = (Goods)o1;            Goods g2 = (Goods)o2;            <span class="hljs-keyword">if</span>(g1.getName().equals(g2.getName()))&#123;                <span class="hljs-keyword">return</span> -Double.compare(g1.getPrice(),g2.getPrice());            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">return</span> g1.getName().compareTo(g2.getName());            &#125;        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不一致"</span>);    &#125;&#125;</code></pre><p>使用场景：  </p><p> Arrays.sort(goods,com);  </p><p> Collections.sort(coll,com);  </p><p> new TreeSet(com); </p><hr><p>Comparable接口与Comparator的使用的对比：  </p><p> Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。  </p><p> Comparator接口属于临时性的比较</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程梳理</title>
    <link href="/2020/05/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <url>/2020/05/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>多线程梳理</font></div>   <hr><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>程序：<br>&emsp;&emsp;是为了完成特定任务，用某种语言编写的一组指令的集合，也就是一段静态代码。<br>进程：<br>&emsp;&emsp;是程序的一次执行过程，或是<strong>正在执行的一个程序</strong>。<br>线程：<br>&emsp;&emsp;进程可以细化为线程，也就是程序内部的一条执行的路径（可以作为调度和执行的单位，每个线程拥有独立的运行栈和计数器配就是pc）。<br>也就是说：进程可以细化为多个线程，而每个线程拥有自己独立的栈，程序计数器，多个线程共享同一个进程中的方法区和堆。<br>内存结构如图：<br><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" alt="内存结构">   </p><p>多线程的优点：提高程序的响应，提高CPU的利用率，改善程序结构<br>善用多线程的环境：需要执行两个或者多个任务，是要实现一些要等待的任务，需要在后台运行等。</p><h2 id="单核与多核-并发与并行"><a href="#单核与多核-并发与并行" class="headerlink" title="单核与多核 并发与并行"></a>单核与多核 并发与并行</h2><p>单核CPU：其实是一种假的多线程，因为在一个时间单元内，只能执行一个线程任务。<br>多核CPU：可以更好的发挥多线程的效率。<br>Tips：<br>&emsp;&emsp;一个java程序java.exe，至少有三个线程，main()主程序，gc()垃圾回收线程，异常处理线程。   </p><p>并行：多个CPU同时执行多个任务。<br>并发：一个CPU（采用时间片）同时执行多个任务。</font>   </p><h2 id="创建多线程的方式-总共四种"><a href="#创建多线程的方式-总共四种" class="headerlink" title="创建多线程的方式(总共四种)"></a>创建多线程的方式(总共四种)</h2><h3 id="方式一：继承于Thread类"><a href="#方式一：继承于Thread类" class="headerlink" title="方式一：继承于Thread类"></a>方式一：继承于Thread类</h3><p>1、创建一个继承于Thread类的子类<br>2、重写Thread类的run()方法 —&gt;  将要执行的操作生命在run()中即可<br>3、创建Thread类的子类的对象<br>4、通过此对象调用<strong>start()</strong>，调用的是start()，不是run()   </p><p>调用start()的时候，会启动当前线程，并调用当前线程的run()<br>Tips：<br>&emsp;&emsp;不可以直接调用run()方法，这样的话只会调用方法而不会启动线程<br>&emsp;&emsp;不可以在已启动的线程上再次调用start()，否则会报会报IllegalThreadStateException的异常</font>   </p><h3 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h3><p>1、创建一个实现了Runnable接口的类<br>2、实现类去实现Runnable中的抽象方法run()<br>3、创建实现类的对象<br>4、将此对象作为参数传递到Thread类的构造器中，创建Thead类的对象<br>5、通过Thread类的对象调用start()   </p><p>通过Thread类的对象调用start()的时候，线程会启动，并调用当线程的run()方法，也就是调用了Runnable类型的target里面的run()</font>   </p><font size='5'>两种线程方式的比较：</font>   <p>开发中优先选用<strong>Runnable接口</strong>的方式<br>原因：<br>1、实现类的方式没有类的单继承性局限<br>2、实现类的方式更适合来处理多个线程有共享数据的情况   </p><p>相同点：两种方式都需要重新run()方法，将线程要执行的逻辑声明在run()中<br>(联系：public class Thread implements Runnable)   </p><h3 id="方式三：实现Callable接口-JDK5-0新增"><a href="#方式三：实现Callable接口-JDK5-0新增" class="headerlink" title="方式三：实现Callable接口(JDK5.0新增)"></a>方式三：实现Callable接口(JDK5.0新增)</h3><p>Callable和Raunnable比较<br>1、call()可以有返回值的。<br>2、call()可以抛出异常，被外面的操作捕获，获取异常的信息<br>3、Callable是支持泛型的   </p><pre><code>//1.创建一个实现Callable的实现类class NumThread implements Callable{    //2.实现call方法，将此线程需要执行的操作声明在call()中    @Override    public Object call() throws Exception {        int sum = 0;        for (int i = 1; i &lt;= 100; i++) {            if(i % 2 == 0){                System.out.println(i);                sum += i;            }        }        return sum;    }}public class ThreadNew {    public static void main(String[] args) {        //3.创建Callable接口实现类的对象        NumThread numThread = new NumThread();        //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象        FutureTask futureTask = new FutureTask(numThread);        //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()        new Thread(futureTask).start();        try {            //6.获取Callable中call方法的返回值            //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。            Object sum = futureTask.get();            System.out.println(&quot;总和为：&quot; + sum);        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }    }}   </code></pre><h3 id="方式四：使用线程池-JDK5-0新增"><a href="#方式四：使用线程池-JDK5-0新增" class="headerlink" title="方式四：使用线程池(JDK5.0新增)"></a>方式四：使用线程池(JDK5.0新增)</h3><p>好处：<br>1、提高响应速度（减少了创建新线程的时间）<br>2、降低资源消耗（重复利用线程池中线程，不需要每次都创建）<br>3、便于线程管理<br>corePoolSize：核心池的大小<br>maximumPoolSize：最大线程数<br>keepAliveTime：线程没有任务时最多保持多长时间后会终止   </p><pre><code>class NumberThread implements Runnable{    @Override    public void run() {        for(int i = 0;i &lt;= 100;i++){            if(i % 2 == 0){                System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i);            }        }    }}class NumberThread1 implements Runnable{    @Override    public void run() {        for(int i = 0;i &lt;= 100;i++){            if(i % 2 != 0){                System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i);            }        }    }}public class ThreadPool {    public static void main(String[] args) {        //1. 提供指定线程数量的线程池        ExecutorService service = Executors.newFixedThreadPool(10);        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;        //设置线程池的属性//        System.out.println(service.getClass());//        service1.setCorePoolSize(15);//        service1.setKeepAliveTime();        //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象        service.execute(new NumberThread());//适合适用于Runnable        service.execute(new NumberThread1());//适合适用于Runnable//        service.submit(Callable callable);//适合使用于Callable        //3.关闭连接池        service.shutdown();    }}</code></pre><h2 id="Thread常用的方法："><a href="#Thread常用的方法：" class="headerlink" title="Thread常用的方法："></a>Thread常用的方法：</h2><p>1、start()：启动当前线程调用run()<br>2、run()：通常需要重写Thread类中的此方法，声明要执行的操作<br>3、currentThread()：<strong>静态方法</strong>，返回执行当前代码的线程<br>4、setName()/getName()：设置/获取当前线程的名字(设置线程名字也可以在构造器中进行)<br>5、setName()：设置当前线程的名字<br>6、yield()：释放当前cpu的执行权，例如：this.yield()，<strong>但是不释放锁</strong><br>7、join()：在线程a中调用b的join()方法，则a就会进入阻塞状态，直达b完全执行完之后，才会结束阻塞状态，也就是说将b线程加入到main线程中，只有b线程运行结束，才会接着往下走<br>8、stop()：已过时，强制结束当前线程<br>9、sleep(毫秒数)：让当前线程睡眠指定的毫秒数，此时，线程是阻塞状态<br>10、isAlive()：判断当前线程是否存活   </p><p>线程的优先级：<br>1、<br>MAX_PRIORITY：10<br>MIN _PRIORITY：1<br>NORM_PRIORITY：5  –&gt;默认优先级<br>2.如何获取和设置当前线程的优先级：<br>getPriority():获取线程的优先级<br>setPriority(int p):设置线程的优先级   </p><p>说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。   </p><p>线程通行：wait()/notify()/notifyAll()：此三个的方法定义在Object类中   </p><p>线程分为：守护线程、用户线程<br>守护线程依赖于用户线程例如：垃圾回收，通过thread.setDaemon(true);可以将用户线程变为守护线程，如果jvm中都为守护线程，则当前jvm将会退出   </p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" srcset="/img/loading.gif" alt="生命周期">   </p><p>状态包括：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING ,TEARMINATED<br>(sleep()不会释放锁，wait()会释放锁)</p><h2 id="解决线程"><a href="#解决线程" class="headerlink" title="解决线程"></a>解决线程</h2><p>解决线程安全问题会用到同步机制，有三种方式，但是效率会下降，因为使用同步机制时就相当于是一个单线程，只有一个线程参与，而其他的线程等待   </p><h3 id="方式一：使用同步代码块"><a href="#方式一：使用同步代码块" class="headerlink" title="方式一：使用同步代码块"></a>方式一：使用同步代码块</h3><pre><code>synchronized(同步监视器){    //需要被同步的代码} </code></pre><p>说明：<br>1.操作共享数据的代码，即为需要被同步的代码。  –&gt;不能包含代码多了，也不能包含代码少了。<br>2.共享数据：多个线程共同操作的变量。比如：共享数据。<br>3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。<br>要求：多个线程必须要共用同一把锁。<br>补充：在<strong>实现Runnable接口</strong>创建多线程的方式中，我们可以考虑使用this充当同步监视器。   </p><p>对于继承了Thread类来实现线程的方法来说，<strong>同步代码块</strong>中的同步监视器，慎用this来充当同步监视器，而考虑使用<strong>当前类</strong>来充当同步监视器   </p><pre><code>class Window2 extends Thread{    private static int ticket = 100;        private static Object obj = new Object();    @Override    public void run() {        while(true){            //正确的        // synchronized (obj){            synchronized (Window2.class){//Class clazz = Window2.class,Window2.class只会加载一次                //错误的方式：this代表着t1,t2,t3三个对象        // synchronized (this){                if(ticket &gt; 0){                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(getName() + &quot;：卖票，票号为：&quot; + ticket);                    ticket--;                }else{                    break;                }            }        }    }}public class WindowTest2 {    public static void main(String[] args) {        Window2 t1 = new Window2();        Window2 t2 = new Window2();        Window2 t3 = new Window2();</code></pre><p>​<br>            t1.setName(“窗口1”);<br>            t2.setName(“窗口2”);<br>            t3.setName(“窗口3”);</p><pre><code>        t1.start();        t2.start();        t3.start();    }}   </code></pre><p>对于<strong>实现Runnable接口</strong>实现多线程来说，<strong>同步代码块</strong>中的同步监视器可以为<strong>this</strong> </p><pre><code>class Window1 implements Runnable{private int ticket = 100;//Object obj = new Object();//Dog dog = new Dog();    @Override    public void run() {//        Object obj = new Object();        while(true){            synchronized (this){//此时的this:唯一的Window1的对象   //方式二：synchronized (dog) {                if (ticket &gt; 0) {                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(Thread.currentThread().getName() + &quot;:卖票，票号为：&quot; + ticket);                    ticket--;                } else {                    break;                }            }        }    }}public class WindowTest1 {    public static void main(String[] args) {        Window1 w = new Window1();        Thread t1 = new Thread(w);        Thread t2 = new Thread(w);        Thread t3 = new Thread(w);        t1.setName(&quot;窗口1&quot;);        t2.setName(&quot;窗口2&quot;);        t3.setName(&quot;窗口3&quot;);        t1.start();        t2.start();        t3.start();    }}class Dog{}       </code></pre><h3 id="方式二：使用同步方法"><a href="#方式二：使用同步方法" class="headerlink" title="方式二：使用同步方法"></a>方式二：使用同步方法</h3><p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。<br>说明：<br>1、同步方法仍然涉及同步监视器，只是不需要我们现实的声明<br>2、<strong>非静态</strong>的同步方法，同步监视器是：<strong>this</strong><br>&emsp;<strong>静态</strong>的同步方法，同步监视器是：<strong>当前类本身</strong>   </p><p>对于使用<strong>继承Thread类</strong>的方法来实现线程的方法来说，而使用<strong>同步方法</strong>时，需要用<strong>static synchronized</strong>来修饰<br>例如：   </p><pre><code>class Window4 extends Thread {    private static int ticket = 100;    @Override    public void run() {        while (true) {            show();        }    }    private static synchronized void show(){//同步监视器：Window4.class        //private synchronized void show(){ //同步监视器：t1,t2,t3。此种解决方式是错误的        if (ticket &gt; 0) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + ticket);            ticket--;        }    }}public class WindowTest4 {    public static void main(String[] args) {        Window4 t1 = new Window4();        Window4 t2 = new Window4();        Window4 t3 = new Window4();</code></pre><p>​<br>            t1.setName(“窗口1”);<br>            t2.setName(“窗口2”);<br>            t3.setName(“窗口3”);</p><pre><code>        t1.start();        t2.start();        t3.start();    }}</code></pre><p>对于<strong>实现Runnable接口</strong>实现多线程来说，同步监视器可以为<strong>this</strong>，使用<strong>同步方法</strong>时，要用<strong>sychronized</strong>来修饰方法<br>例如：   </p><pre><code>class Window3 implements Runnable {    private int ticket = 100;    @Override    public void run() {        while (true) {            show();        }    }    private synchronized void show(){//同步监视器：this        //synchronized (this){            if (ticket &gt; 0) {                try {                    Thread.sleep(100);                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(Thread.currentThread().getName() + &quot;:卖票，票号为：&quot; + ticket);                ticket--;            }        //}    }}public class WindowTest3 {    public static void main(String[] args) {        Window3 w = new Window3();        Thread t1 = new Thread(w);        Thread t2 = new Thread(w);        Thread t3 = new Thread(w);        t1.setName(&quot;窗口1&quot;);        t2.setName(&quot;窗口2&quot;);        t3.setName(&quot;窗口3&quot;);        t1.start();        t2.start();        t3.start();    }}</code></pre><h3 id="方式三：使用Lock锁-JDK5-0新增"><a href="#方式三：使用Lock锁-JDK5-0新增" class="headerlink" title="方式三：使用Lock锁(JDK5.0新增)"></a>方式三：使用Lock锁(JDK5.0新增)</h3><p>没有使用同步监视器，因为其自身就是一个同步监视器<br>1、实例化ReentrantLock<br>2、调用锁定方法lock()<br>3、调用解锁方法unlock()   </p><p>例如：   </p><pre><code>class Window implements Runnable{    private int ticket = 100;    //1.实例化ReentrantLock    private ReentrantLock lock = new ReentrantLock();    @Override    public void run() {        while(true){            try{                //2.调用锁定方法lock()                lock.lock();                if(ticket &gt; 0){                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(Thread.currentThread().getName() + &quot;：售票，票号为：&quot; + ticket);                    ticket--;                }else{                    break;                }            }finally {                //3.调用解锁方法：unlock()                lock.unlock();            }        }    }}public class LockTest {    public static void main(String[] args) {        Window w = new Window();        Thread t1 = new Thread(w);        Thread t2 = new Thread(w);        Thread t3 = new Thread(w);        t1.setName(&quot;窗口1&quot;);        t2.setName(&quot;窗口2&quot;);        t3.setName(&quot;窗口3&quot;);        t1.start();        t2.start();        t3.start();    }}    </code></pre><p>Tips:<br>synchronized和lock的异同：<br>相同：二者都可以解决线程安全问题<br>不同：synchronized机制在执行完响应的代码之后会<strong>自动释放同步监视器(锁)</strong>，而Lock需要调用方法来<strong>手动启动lock()</strong>,同时结束之后也需要<strong>手动实现unlock()</strong>     </p><p>同步机制的利弊：<br>好处：解决了线程的安全问题。<br>弊端：操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的资源，就形成了线程的思索   </p><p>说明：死锁出现后，不会出现异常，不会出现提示，只是所有的线程都处于堵塞状态，无法继续   </p><pre><code>public class ThreadTest {    public static void main(String[] args) {        StringBuffer s1 = new StringBuffer();        StringBuffer s2 = new StringBuffer();        new Thread(){            @Override            public void run() {                synchronized (s1){                    s1.append(&quot;a&quot;);                    s2.append(&quot;1&quot;);                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    synchronized (s2){                        s1.append(&quot;b&quot;);                        s2.append(&quot;2&quot;);                        System.out.println(s1);                        System.out.println(s2);                    }                }            }        }.start();        new Thread(new Runnable() {            @Override            public void run() {                synchronized (s2){                    s1.append(&quot;c&quot;);                    s2.append(&quot;3&quot;);                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    synchronized (s1){                        s1.append(&quot;d&quot;);                        s2.append(&quot;4&quot;);                        System.out.println(s1);                        System.out.println(s2);                    }                }            }        }).start();    }}</code></pre><h2 id="使用同步机制将单例模式的懒汉式改为线程安全的"><a href="#使用同步机制将单例模式的懒汉式改为线程安全的" class="headerlink" title="使用同步机制将单例模式的懒汉式改为线程安全的"></a>使用同步机制将单例模式的懒汉式改为线程安全的</h2><pre><code>public class BankTest {}class Bank{    private Bank(){}    private static Bank instance = null;    public static Bank getInstance(){        //方式一：效率稍差//        synchronized (Bank.class) {//            if(instance == null){////                instance = new Bank();//            }//            return instance;//        }        //方式二：效率更高        if(instance == null){            synchronized (Bank.class) {                if(instance == null){                    instance = new Bank();                }            }        }        return instance;    }}</code></pre><h2 id="关于线程通信"><a href="#关于线程通信" class="headerlink" title="关于线程通信"></a>关于线程通信</h2><p>三个方法：<br>wait()：使当前线程进入阻塞，并释放同步监视器<br>notify()：唤醒被wait()的一个线程，如果多个线程被wait就唤醒优先级高的那个<br>notifyAll()：唤醒所有的被wait()的方法   </p><p>说明：<br>1、wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中<br>2、wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器，否则，会出现IllegalMonitorStateException异常<br>3、wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。   </p><p>sleep() 和 wait()的异同<br>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。<br>不同点：<br>(1)两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()<br>(2)调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中<br>(3)关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。   </p><p>例如：   </p><pre><code>class Number implements Runnable{    private int number = 1;    private Object obj = new Object();    @Override    public void run() {        while(true){            synchronized (obj) {                obj.notify();                if(number &lt;= 100){                    try {                        Thread.sleep(10);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(Thread.currentThread().getName() + &quot;:&quot; + number);                    number++;                    try {                        //使得调用如下wait()方法的线程进入阻塞状态                        obj.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }else{                    break;                }            }        }    }}public class CommunicationTest {    public static void main(String[] args) {        Number number = new Number();        Thread t1 = new Thread(number);        Thread t2 = new Thread(number);        t1.setName(&quot;线程1&quot;);        t2.setName(&quot;线程2&quot;);        t1.start();        t2.start();    }}</code></pre><h2 id="经典的生产者消费者问题"><a href="#经典的生产者消费者问题" class="headerlink" title="经典的生产者消费者问题"></a>经典的生产者消费者问题</h2><pre><code>class Clerk{    private int productCount = 0;    //生产产品    public synchronized void produceProduct() {        if(productCount &lt; 20){            productCount++;            System.out.println(Thread.currentThread().getName() + &quot;:开始生产第&quot; + productCount + &quot;个产品&quot;);            notify();        }else{            //等待            try {                wait();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    //消费产品    public synchronized void consumeProduct() {        if(productCount &gt; 0){            System.out.println(Thread.currentThread().getName() + &quot;:开始消费第&quot; + productCount + &quot;个产品&quot;);            productCount--;            notify();        }else{            //等待            try {                wait();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}class Producer extends Thread{//生产者    private Clerk clerk;    public Producer(Clerk clerk) {        this.clerk = clerk;    }    @Override    public void run() {        System.out.println(getName() + &quot;:开始生产产品.....&quot;);        while(true){            try {                Thread.sleep(10);            } catch (InterruptedException e) {                e.printStackTrace();            }            clerk.produceProduct();        }    }}class Consumer extends Thread{//消费者    private Clerk clerk;    public Consumer(Clerk clerk) {        this.clerk = clerk;    }    @Override    public void run() {        System.out.println(getName() + &quot;:开始消费产品.....&quot;);        while(true){            try {                Thread.sleep(20);            } catch (InterruptedException e) {                e.printStackTrace();            }            clerk.consumeProduct();        }    }}public class ProductTest {    public static void main(String[] args) {        Clerk clerk = new Clerk();        Producer p1 = new Producer(clerk);        p1.setName(&quot;生产者1&quot;);        Consumer c1 = new Consumer(clerk);        c1.setName(&quot;消费者1&quot;);        Consumer c2 = new Consumer(clerk);        c2.setName(&quot;消费者2&quot;);        p1.start();        c1.start();        c2.start();    }}</code></pre><p><a href="https://www.bilibili.com/video/BV1Qb411g7cz?p=413" target="_blank" rel="noopener">资料来源</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JSON的简单了解</title>
    <link href="/2020/05/14/JSON%E7%9A%84%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/"/>
    <url>/2020/05/14/JSON%E7%9A%84%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>JSON的简单了解</font></div><hr><h3 id="JSON是什么"><a href="#JSON是什么" class="headerlink" title="JSON是什么"></a>JSON是什么</h3><p>&emsp;&emsp;是一种基于JavaScript语法子集的开放标准数据交换格式。JSON是基于文本的，轻量级的，通常被认为易于读/写。</p><h3 id="语法格式要求"><a href="#语法格式要求" class="headerlink" title="语法格式要求"></a>语法格式要求</h3><font size='4'>&emsp;&emsp;在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：   1、对象数组表示为键值对   2、数据由逗号分隔   3、花括号保存对象   4、方括号保存数组   <p>JSON键值对是用来保存JS对象的一种方式，例如：<br>{“age”:”3”}<br>JSON是JS对象的字符串的表示法，它使用文本表示一个JS对象的信息。本质是一个字符串。</font>   </p><h3 id="JSON和JavaScript对象互转"><a href="#JSON和JavaScript对象互转" class="headerlink" title="JSON和JavaScript对象互转"></a>JSON和JavaScript对象互转</h3><p><font size='4'>JSON和JS对象的互转:<br>JSON字符串 —&gt;   JS对象<br>使用JSON.parse()方法:</p><p>JS对象 —&gt; JSON字符串<br>使用JSON.stringify()方法<br><font size='5'></p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    var user = {        name : &quot;爱丽丝&quot;,        age : 3,        sex : &quot;女&quot;    };    //输出此对象    console.log(user);    //将js对象转换为JSON    var str = JSON.stringify(user);    // str的输出结果：{&quot;name&quot;:&quot;爱丽丝&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;女&quot;}    console.log(str);    var obj = JSON.parse(str);    //obj的输出结果：{name: &quot;爱丽丝&quot;, age: 3, sex: &quot;女&quot;}    console.log(obj);&lt;/script&gt;   </code></pre></font><p>由于前后端分离，数据交互就变得异常重要，而json就是很重要的一部分</font>   </p><h3 id="使用Jackson进行json的解析"><a href="#使用Jackson进行json的解析" class="headerlink" title="使用Jackson进行json的解析"></a>使用Jackson进行json的解析</h3><p><font size='4'>Json返回的是一个字符串，而市面上有很多第三方jar包可以实现此功能，例如<strong>jackson</strong>（可以去maven仓库找）:可以利用@ResponseBody就可以将对象转换为json返回<br><font size='5'></p><pre><code>@Controllerpublic class UserController {    @RequestMapping(&quot;/json1&quot;)    @ResponseBody    public String json1() throws JsonProcessingException {       //创建一个jackson的对象映射器，用来解析数据       ObjectMapper mapper = new ObjectMapper();       //创建一个对象       User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);       //将我们的对象解析成为json格式       String str = mapper.writeValueAsString(user);       //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便       return str;    }}</code></pre></font><p>结果可以返回json的字符串，但是会出现乱码的问题<br>解决方法一：<br>使用@RequestMapping注解中的produces属性来指定返回类型和编码格式<br><font size='5'></p><pre><code>//produces:指定响应体返回类型和编码@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;)</code></pre></font>   可以解决乱码问题   <p>解决办法二：<br>在springMVC中，直接进行统一的配置，通过配置StringHttpMessageConverter进行转换<br><font size='5'></p><pre><code>&lt;mvc:annotation-driven&gt;    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;       &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;           &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;       &lt;/bean&gt;       &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;           &lt;property name=&quot;objectMapper&quot;&gt;               &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;                   &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;               &lt;/bean&gt;           &lt;/property&gt;       &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;</code></pre></font> </font><h3 id="关于统一返回json字符串"><a href="#关于统一返回json字符串" class="headerlink" title="关于统一返回json字符串"></a>关于统一返回json字符串</h3><p><font size='4'>可以直接在类上使用，@RestController，这样所有的方法返回的都是json字符串了，而不用每一个方法上都添加@ResponseBody，这是在开发中常用的方法<br><font size='5'></p><pre><code>@RestControllerpublic class UserController {    //produces:指定响应体返回类型和编码    @RequestMapping(value = &quot;/json1&quot;)    public String json1() throws JsonProcessingException {       //创建一个jackson的对象映射器，用来解析数据       ObjectMapper mapper = new ObjectMapper();       //创建一个对象       User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);       //将我们的对象解析成为json格式       String str = mapper.writeValueAsString(user);       //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便       return str;    }}   </code></pre></font></font><h3 id="关于时间问题的处理"><a href="#关于时间问题的处理" class="headerlink" title="关于时间问题的处理"></a>关于时间问题的处理</h3><p><font size='4'>json在将时间返回为json数据时，会将时间转换为时间戳的形式进行显示<br>解决办法：取消timestamps的形式，还可以自定义时间格式<br><font size='5'></p><pre><code>@RequestMapping(&quot;/json4&quot;)public String json4() throws JsonProcessingException {    ObjectMapper mapper = new ObjectMapper();    //不使用时间戳的方式   在此步骤关闭时间戳    mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);    //自定义日期格式对象    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    //指定日期格式    mapper.setDateFormat(sdf);    Date date = new Date();    String str = mapper.writeValueAsString(date);    return str;}</code></pre></font></font><h3 id="一点小拓展"><a href="#一点小拓展" class="headerlink" title="一点小拓展"></a>一点小拓展</h3><p><font size='4'>&emsp;&emsp;可以将经常使用的代码封装到一个工具类中：<br><font size='5'></p><pre><code>package com.kuang.utils;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import java.text.SimpleDateFormat;public class JsonUtils {    public static String getJson(Object object) {       return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;);    }    public static String getJson(Object object,String dateFormat) {       ObjectMapper mapper = new ObjectMapper();       //不使用时间差的方式       mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);       //自定义日期格式对象       SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);       //指定日期格式       mapper.setDateFormat(sdf);       try {           return mapper.writeValueAsString(object);      } catch (JsonProcessingException e) {           e.printStackTrace();      }       return null;    }}   </code></pre></font>这样调用的时候就可以直接使用啦</font>   <hr><p><font size='4'>&emsp;&emsp;astjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。   </p><p>记得导入fastjson 的 pom依赖！（可以在maven仓库找）</p><p>fastjson 三个主要的类：</p><p>（1）JSONObject  代表 json 对象 </p><p>（2）JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。</p><p>（3）JSONArray   代表 json 对象数组：内部是有List接口中的方法来完成操作的。<br>例如代码演示：<br><font size='5'></p><pre><code>package com.kuang.controller;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.kuang.pojo.User;import java.util.ArrayList;import java.util.List;public class FastJsonDemo {    public static void main(String[] args) {       //创建一个对象       User user1 = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);       User user2 = new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;);       User user3 = new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;);       User user4 = new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;);       List&lt;User&gt; list = new ArrayList&lt;User&gt;();       list.add(user1);       list.add(user2);       list.add(user3);       list.add(user4);       System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;);       String str1 = JSON.toJSONString(list);       System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1);       String str2 = JSON.toJSONString(user1);       System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2);       System.out.println(&quot;\n****** JSON字符串 转 Java对象*******&quot;);       User jp_user1=JSON.parseObject(str2,User.class);       System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1);       System.out.println(&quot;\n****** Java对象 转 JSON对象 ******&quot;);       JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);       System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;));       System.out.println(&quot;\n****** JSON对象 转 Java对象 ******&quot;);       User to_java_user = JSON.toJavaObject(jsonObject1, User.class);       System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user);    }}</code></pre></font><hr><p>以上资料参考：<a href="https://mp.weixin.qq.com/s/RAqRKZJqsJ78HRrJg71R1g" target="_blank" rel="noopener">狂神说JAVA</a></font></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式和方法引用</title>
    <link href="/2020/05/13/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    <url>/2020/05/13/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>Lambda表达式和方法引用的整理</font></div><hr><h2 id="Lanbda表达式"><a href="#Lanbda表达式" class="headerlink" title="Lanbda表达式"></a>Lanbda表达式</h2><font size='4'><h3 id="1、Lambda表达式的格式"><a href="#1、Lambda表达式的格式" class="headerlink" title="1、Lambda表达式的格式"></a>1、Lambda表达式的格式</h3><p><code>(o1,o2) -&gt; Integer.compare(o1,o2);</code><br>左边 —&gt; lambda表达式的形参列表，本质上也就是接口中抽象方法的形参列表<br>右边 —&gt; lambda体，也就是重写抽象方法的方法体   </p><h3 id="2、Lambda表达式的使用的六种情况："><a href="#2、Lambda表达式的使用的六种情况：" class="headerlink" title="2、Lambda表达式的使用的六种情况："></a>2、Lambda表达式的使用的六种情况：</h3><p>(1)语法格式一：无参，无返回值<br><font size='5'></p><pre><code>    @Testpublic void test1(){    //不使用Lambda表达式    Runnable r1 = new Runnable() {        @Override        public void run() {            System.out.println(&quot;不使用Lambda表达式&quot;);        }    };    r1.run();    System.out.println(&quot;***********************&quot;);    //使用Lambda表达式    Runnable r2 = () -&gt; {        System.out.println(&quot;使用Lambda表达式&quot;);    };    r2.run();}   </code></pre></font><p>(2)有一个参数，但是没有返回值<br><font size='5'></p><pre><code>@Testpublic void test2(){    //不使用Lambda表达式    Consumer&lt;String&gt; con = new Consumer&lt;String&gt;() {        @Override        public void accept(String s) {            System.out.println(s);        }    };    con.accept(&quot;不使用Lambda表达式&quot;);    System.out.println(&quot;*******************&quot;);    //使用Lambda表达式    Consumer&lt;String&gt; con1 = (String s) -&gt; {        System.out.println(s);    };    con1.accept(&quot;使用Lambda表达式&quot;);}   </code></pre></font><p>(3)数据类型可以省略，因为可以推断得出，称为类型推断<br><font size='5'></p><pre><code>@Testpublic void test3(){    //不使用Lambda表达式    Consumer&lt;String&gt; con1 = (String s) -&gt; {        System.out.println(s);    };    con1.accept(&quot;不使用Lambda表达式&quot;);    System.out.println(&quot;*******************&quot;);    //使用Lambda表达式    Consumer&lt;String&gt; con2 = (s) -&gt; {        System.out.println(s);    };    con2.accept(&quot;使用Lambda表达式&quot;);}</code></pre></font>   <p>(4)只需要一个参数的时候，小括号可以省略<br><font size='5'></p><pre><code>@Testpublic void test5(){    //不使用Lambda表达式    Consumer&lt;String&gt; con1 = (s) -&gt; {        System.out.println(s);    };    con1.accept(&quot;不使用Lambda表达式&quot;);    System.out.println(&quot;*******************&quot;);    //使用Lambda表达式    Consumer&lt;String&gt; con2 = s -&gt; {        System.out.println(s);    };    con2.accept(&quot;使用Lambda表达式&quot;);}</code></pre></font>   <p>(5)需要两个或两个以上的参数，多条执行语句，可以有返回值<br><font size='5'></p><pre><code>    @Testpublic void test6(){    //不使用Lambda表达式    Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;() {        @Override        public int compare(Integer o1, Integer o2) {            System.out.println(o1);            System.out.println(o2);            return o1.compareTo(o2);        }    };    System.out.println(com1.compare(12,21));    System.out.println(&quot;*****************************&quot;);    //使用Lambda表达式    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; {        System.out.println(o1);        System.out.println(o2);        return o1.compareTo(o2);    };    System.out.println(com2.compare(12,6));}</code></pre></font>   <p>(6)只有一条语句时，如果有返回值，return和大括号都可以省略（<strong>return必须省略</strong>）<br><font size='5'></p><pre><code>@Testpublic void test7(){    //不使用Lambda表达式    Comparator&lt;Integer&gt; com1 = (o1,o2) -&gt; {        return o1.compareTo(o2);    };    System.out.println(com1.compare(12,6));    System.out.println(&quot;*****************************&quot;);    //使用Lambda表达式    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; o1.compareTo(o2);    System.out.println(com2.compare(12,21));}</code></pre></font><p>综合的列子：<br>例子一：<br><font size='5'></p><pre><code>@Testpublic void test1(){    //不用Lambda表达式    happyTime(500, new Consumer&lt;Double&gt;() {        @Override        public void accept(Double aDouble) {            System.out.println(&quot;天上的星星有&quot; + aDouble);        }    });    System.out.println(&quot;********************&quot;);    //使用Lambda表达式    happyTime(400,nums -&gt; System.out.println(&quot;眼睛里有&quot; + nums + &quot;颗星星&quot;));}public void happyTime(double nums, Consumer&lt;Double&gt; con){    con.accept(nums);}   </code></pre></font><p>例子二：<br><font size='5'></p><pre><code>@Testpublic void test2(){    List&lt;String&gt; list = Arrays.asList(&quot;北京&quot;,&quot;南京&quot;,&quot;天津&quot;,&quot;东京&quot;,&quot;西京&quot;,&quot;普京&quot;);    List&lt;String&gt; filterStrs = filterString(list, new Predicate&lt;String&gt;() {        @Override        public boolean test(String s) {            return s.contains(&quot;京&quot;);        }    });    System.out.println(filterStrs);    List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains(&quot;京&quot;));    System.out.println(filterStrs1);}    //根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定    public List&lt;String&gt; filterString(List&lt;String&gt; list, Predicate&lt;String&gt; pre){        ArrayList&lt;String&gt; filterList = new ArrayList&lt;&gt;();        for(String s : list){            if(pre.test(s)){                filterList.add(s);            }        }        return filterList;    }}    </code></pre></font><p>总结：<br>&emsp;&emsp;-&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也可以省略<br>&emsp;&emsp;-&gt;右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对{}和return关键字</p><h3 id="3、lambda表达式的本质"><a href="#3、lambda表达式的本质" class="headerlink" title="3、lambda表达式的本质"></a>3、lambda表达式的本质</h3><p>作为函数式接口的<strong>实例</strong><br>&emsp;&emsp;所谓函数式接口也就是只声明了<strong>一个</strong>抽象方法的接口成为函数式接口，一般用@FunctionalInterface来注释，也可以用@FunctionalInterface来检验接口是否为函数式接口，如果不是函数式接口，会报错。<br>&emsp;&emsp;以前用匿名实现类表现的现在都可以用lambda表达式来写   </p><h3 id="4、关于函数式接口"><a href="#4、关于函数式接口" class="headerlink" title="4、关于函数式接口"></a>4、关于函数式接口</h3><p>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。<br>我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。<br><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.png" srcset="/img/loading.gif" alt="函数式接口"><br></font>   </p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><font size='4'>(1)使用情景   当传递给Lambda体的操作，已经有实现的方法了，就可以使用方法的引用   方法的引用：本质上就是Lambda表达式，而Lambda表达式时函数式接口的实例，所以，方法引用，也就是函数式接口的实例   使用格式：类（或对象）：：方法名   方法的引用使用要求：要求接口中抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同（针对于情况一和情况二）   <p>具体分为三种情况<br>情况一：对象 :: 实例方法<br><font size='5'></p><pre><code>//Consumer中的void accept(T t)//PrintStream中的void println(T t)@Testpublic void test1() {    Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);    con1.accept(&quot;北京&quot;);    System.out.println(&quot;*******************&quot;);    PrintStream ps = System.out;    Consumer&lt;String&gt; con2 = ps::println;    con2.accept(&quot;beijing&quot;);}   </code></pre></font><p>情况二：类 :: 静态方法<br><font size='5'></p><pre><code>//Comparator中的int compare(T t1,T t2)//Integer中的int compare(T t1,T t2)@Testpublic void test3() {    Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);    System.out.println(com1.compare(12,21));    System.out.println(&quot;*******************&quot;);    Comparator&lt;Integer&gt; com2 = Integer::compare;    System.out.println(com2.compare(12,3));}</code></pre></font>   <p>情况三：类 :: 实例方法  (有难度)<br><font size='5'>   </p><pre><code>// Comparator中的int comapre(T t1,T t2)// String中的int t1.compareTo(t2)@Testpublic void test5() {    Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);    System.out.println(com1.compare(&quot;abc&quot;,&quot;abd&quot;));    System.out.println(&quot;*******************&quot;);    Comparator&lt;String&gt; com2 = String :: compareTo;    System.out.println(com2.compare(&quot;abd&quot;,&quot;abm&quot;));}   //BiPredicate中的boolean test(T t1, T t2);//String中的boolean t1.equals(t2)@Testpublic void test6() {    BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);    System.out.println(pre1.test(&quot;abc&quot;,&quot;abc&quot;));    System.out.println(&quot;*******************&quot;);    BiPredicate&lt;String,String&gt; pre2 = String :: equals;    System.out.println(pre2.test(&quot;abc&quot;,&quot;abd&quot;));}</code></pre></font></font>   <hr><p><a href="https://www.bilibili.com/video/BV1Qb411g7cz?p=666" target="_blank" rel="noopener">资料来源</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Maven的大概梳理</title>
    <link href="/2020/05/13/%E5%85%B3%E4%BA%8EMaven%E7%9A%84%E5%A4%A7%E6%A6%82%E6%A2%B3%E7%90%86/"/>
    <url>/2020/05/13/%E5%85%B3%E4%BA%8EMaven%E7%9A%84%E5%A4%A7%E6%A6%82%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>关于Maven的大概梳理</font></div><hr><h2 id="目前项目中存在的问题"><a href="#目前项目中存在的问题" class="headerlink" title="目前项目中存在的问题"></a>目前项目中存在的问题</h2><p><font size='4'>1、一个项目就是一个工程<br>2、项目中需要的jar包必须手动复制，粘贴到”WEB-INF/lib”目录下<br>所带来的问题是：同样的jar包重复出现，这样浪费空间也让空间比较臃肿，借助maven可以将jar包保存在仓库中<br>3、jar包需要别人替我们准备好，或者到官网上下载<br>而官网提供的jar包下载形式是不同的，很不方便，面临各种问题，而借助maven可以按照统一的规范下载<br>4、一个jar包以来的其他的jar包需要自己手动加入到项目中<br></font>   </p><h2 id="maven是什么？"><a href="#maven是什么？" class="headerlink" title="maven是什么？"></a>maven是什么？</h2><p><font size='4'>Maven是一款服务于<strong>java</strong>平台的自动化构建工具<br>关于构建：<br>web工程和编译结果在目录上的不同：<br><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/maven%E4%B8%ADweb%E5%B7%A5%E7%A8%8B%E5%92%8C%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C%E7%9B%AE%E5%BD%95%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C.PNG" srcset="/img/loading.gif" alt="web工程和编译结果在目录上的不同"><br>构建的各个环节：<br>[1]清理：将以前的得到的旧的class字节码文件删除，为下一次编译做准备<br>[2]编译：将java源程序编译成class字节码文件<br>[3]测试：自动测试，自动调用junit程序<br>[4]报告：测试程序执行的结果<br>[5]打包：动态web工程打包为war包，java工程打jar包<br>[6]安装：maven特定的概念————将打包得到的文件复制到仓库中的位置<br>[7]部署：将动态的web工程生成war包复制到servlet容器指定目录下，使其可以运行</font>   </p><h2 id="maven的核心概念"><a href="#maven的核心概念" class="headerlink" title="maven的核心概念"></a>maven的核心概念</h2><h3 id="1、约定的目录结构"><a href="#1、约定的目录结构" class="headerlink" title="1、约定的目录结构"></a>1、约定的目录结构</h3><p><font size='4'>例如：<br>        目录结构<br>            Hello<br>            |—src<br>            |—|—main<br>            |—|—|—java<br>            |—|—|—resources<br>            |—|—test<br>            |—|—|—java<br>            |—|—|—resources<br>            |—pom.xml   </p><p>(1)根目录：工程名<br>(2)scr目录：源码<br>(3)pom.xml文件：maven工程的核心配置文件<br>(4)main目录：存放主程序<br>(5)test目录：存放测试程序<br>(6)java目录：存放java源程序<br>(7)resource目录：存放框架或者其他工具的配置文件   </p><p>一般来说：约定 &gt; 配置 &gt; 编码   </p><p>maven常用的命令<br>(1)mvn clean:清理<br>(2)mvn compile:编译主程序<br>(3)mvn test-complie:编译测试程序<br>(4)mvn test:执行测试<br>(5)mvn package:打包<br>(6)mvn site:生成站点   </p><p>Tips：<br>&emsp;&emsp;当我们执行maven命令需要用到某些插件时，maven核心程序会先去本地仓库（家目录）中寻找<code>C:\Users\18369\.m2\repository</code>如果没有找到，就会自动联网，在中央仓库中下载。</font>   </p><h3 id="2、pom"><a href="#2、pom" class="headerlink" title="2、pom"></a>2、pom</h3><p><font size='4'>(1)Project Object Model:项目对象模型<br>(2)pom.xml是maven工程的核心配置文件</font>   </p><h3 id="3、坐标"><a href="#3、坐标" class="headerlink" title="3、坐标"></a>3、坐标</h3><p><font size='4'>(1)使用三个向量在仓库中定位唯一的一个maven工程（管理jar包的方式）<br>&emsp;&emsp;[1]groupid：公司或者组织域名倒序+项目名   </p><pre><code>&lt;groupId&gt;org.example&lt;/groupId&gt;</code></pre><p>&emsp;&emsp;[2]artifactId：模块名   </p><pre><code>&lt;artifactId&gt;springMVC_day02_02_fileupload&lt;/artifactId&gt;   </code></pre><p>&emsp;&emsp;[3]version：版本</p><pre><code>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;   </code></pre></font><h3 id="4、依赖"><a href="#4、依赖" class="headerlink" title="4、依赖"></a>4、依赖</h3><p><font size='4'>(1)maven解析依赖信息的时候，会到本地仓库中查找被以来的jar包，对于我们自己的maven工程，使用mvn install命令安装后就可以进入仓库了。<br>(2)依赖的范围：<br><font size='5'><code>&lt;scope&gt;test&lt;/scope&gt;</code>默认值是compile</font>   </p><p>&emsp;&emsp;[1]compile<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对主程序<strong>有效</strong>，测试程序<strong>有效</strong>，<strong>参与</strong>打包，<strong>参与</strong>部署<br>&emsp;&emsp;[2]test<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对主程序<strong>无效</strong>，测试程序<strong>有效</strong>，<strong>不参与</strong>打包，<strong>不参与</strong>部署<br>&emsp;&emsp;[3]provided<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对主程序<strong>有效</strong>，测试程序<strong>有效</strong>，<strong>不参与</strong>打包，<strong>不参与</strong>部署   </p><p>(3)依赖的传递性<br>&emsp;&emsp;[1]可以传递的依赖不必在每个工程中都重复声明<br>&emsp;&emsp;[2]<strong>非</strong>compile范围的依赖是传递不过来的   </p><p>(4)依赖的排除<br>&emsp;&emsp;[1]需要设置依赖排除的场合<br>&emsp;&emsp;[2]依赖排除的方式<br><font size='5'></p><pre><code>&lt;exclusions&gt;    &lt;exclusion&gt;        &lt;groupId&gt;commons-logging&lt;/groupId&gt;        &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;    &lt;/exclusion&gt;&lt;/exclusions&gt;   </code></pre></font><p>(5)依赖的原则<br>&emsp;&emsp;[1]作用：解决模块工程之间的jar包冲突问题<br>&emsp;&emsp;[2]原则上：路径距离不同时：路径最短者优先<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;路径距离相同时：先声明者（指dependency标签的声明顺序）优先<br>(6)统一管理依赖的版本<br>建议方式：<br>&emsp;&emsp;[1]使用properties标签，其中使用自定义标签，统一声明版本号<br>&emsp;&emsp;例如：<br><font size='5'></p><pre><code>&lt;properties&gt;    &lt;edu.kmust.spring.version&gt;4.1.1.RELEASE&lt;/edu.kmust.spring.version&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt; </code></pre></font>  &emsp;&emsp;[2]在需要统一的位置，使用${自定义标签名}引用声明的版本号   &emsp;&emsp;例如：   <font size='5'><pre><code>&lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;        &lt;!-- 引用版本号实现统一管理 --&gt;        &lt;version&gt;${edu.kmust.spring.version}&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;   </code></pre></font><p>&emsp;&emsp;[3]properties标签并不只是可以声明版本号，也可以进行其他的设置，凡是需要统一声明后再使用的都可以引用<br><font size='5'></p><pre><code>&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;   </code></pre></font></font></font>    </font>   <h3 id="5、仓库"><a href="#5、仓库" class="headerlink" title="5、仓库"></a>5、仓库</h3><p><font size='4'>(1)分类<br>[1]本地仓库：当前电脑上<br>[2]远程仓库<br>&emsp;&emsp;私服：为当前局域网中的maven工程服务<br>&emsp;&emsp;中央仓库：架设在Internet上为全世界的maven服务<br>&emsp;&emsp;中央仓库的镜像：架设在各个州，为中央仓库分流，减轻负担，提升访问速度   </p><p>(2)仓库中保存的内容<br>&emsp;&emsp;[1]maven自身所诉需要的插件<br>&emsp;&emsp;[2]第三方框架或者工具的jar包<br>&emsp;&emsp;[3]我们自己开发的maven工程</font>   </p><h3 id="6、生命周期-插件-目标"><a href="#6、生命周期-插件-目标" class="headerlink" title="6、生命周期/插件/目标"></a>6、生命周期/插件/目标</h3><p><font size='4'>&emsp;&emsp;各个构建环节的执行顺序，不可打乱，必须按照正确的顺序来执行。<br>&emsp;&emsp;不论执行生命周期的哪一阶段，都是从生命周期最初的位置开始执行的。<br>&emsp;&emsp;插件和目标<br>&emsp;&emsp;&emsp;[1]生命周期的各个阶段仅仅定义了要执行的任务是什么<br>&emsp;&emsp;&emsp;[2]各个阶段和插件的目标是对应的<br>&emsp;&emsp;&emsp;[3]相似的目标又特定的插件完成   </p></font>   <h3 id="7、继承"><a href="#7、继承" class="headerlink" title="7、继承"></a>7、继承</h3><font size='4'>继承可以解决的问题：由于test范围的依赖不能传递，所以必然会分散再各个模块的工程中，很容易造成版本不一致。   需求：统一管理各个模块工程中对某个（例如junit）依赖的版本。   解决思路：将junit的依赖统一提取到父工程中，在子工程中声明junit时不指定版本，就以父工程中的统一设定为准。   <p>具体步骤：<br>[1]创建一个maven的父工程，打包方式为<strong>pom</strong><br><font size='5'></p><pre><code>&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;&lt;artifactId&gt;Parent&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt;</code></pre></font><p>[2]在子工程中声明对父工程的引用<br><font size='5'></p><pre><code>&lt;!-- 子工程中声明父工程 --&gt;&lt;parent&gt;    &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;    &lt;artifactId&gt;Parent&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;!-- 以当前文件为基准的父工程pom.xml文件的相对路径 --&gt;    &lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt;</code></pre></font><p>[3]将子工程的坐标与父工程中相同的部分删除<br>例如：<code>&lt;gourpId&gt;  &lt;/gourpId&gt;</code>等（有黄色波浪下划线的部分）<br>[4]在父工程中统一管理junit的依赖<br><font size='5'></p><pre><code>&lt;!-- 配置依赖的管理 --&gt;&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.9&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;</code></pre></font><p>[5]在子工程中删除junit依赖的版本号部分<br>也就是：<code>&lt;version&gt;  &lt;/version&gt;</code><br>Tips：配置继承后，执行命令时要先安装父工程</p><h3 id="8、聚合"><a href="#8、聚合" class="headerlink" title="8、聚合"></a>8、聚合</h3><p>作用：一键安装各个模块工具<br>在一个总的聚合工具中配置各个参与聚合的模块<br><font size='5'></p><pre><code>&lt;!-- 配置聚合 --&gt;&lt;modules&gt;    &lt;!-- 指定各个子工程的相对路径 --&gt;    &lt;module&gt;../HelloFriend&lt;/module&gt;    &lt;module&gt;../MakeFriends&lt;/module&gt;    &lt;module&gt;../Hello&lt;/module&gt;&lt;/modules&gt;</code></pre></font>   使用方法：在聚合工程的pom.xml上右键 ---> run as ---> maven install</font>   <hr><p><a href="https://www.bilibili.com/video/BV1Pt411y7Rh?p=1" target="_blank" rel="noopener">资料来源</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于反射的知识点的整理</title>
    <link href="/2020/05/07/%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E6%95%B4%E7%90%86/"/>
    <url>/2020/05/07/%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<div align='center' ><font size='6'>关于反射的知识点的整理</font></div><hr><h2 id="关于java-lang-Class的理解"><a href="#关于java-lang-Class的理解" class="headerlink" title="关于java.lang.Class的理解"></a>关于java.lang.Class的理解</h2><font size='4'><h3 id="1、类的加载过程"><a href="#1、类的加载过程" class="headerlink" title="1、类的加载过程"></a>1、类的加载过程</h3><p>&emsp;&emsp;程序在运行过程中通过javac.exe命令之后，会生成一个或者多个字节码文件(以.class结尾)，接着当我们使用java.exe命令对某个字节码文件进行解释编译运行，此时就相当于将某个字节码文件加载到了内存中，此过程称之为类的加载，而加载到内存中的类，我们称之为运行时类，此时的运行时类就作为一个Class的实例存在。换句话说，Class的实例就对应着一个运行时类。</p><h3 id="2、哪些对象可以有Class的对象"><a href="#2、哪些对象可以有Class的对象" class="headerlink" title="2、哪些对象可以有Class的对象"></a>2、哪些对象可以有Class的对象</h3><p>(1)、 interface 接口</p><p>(2)、数组[]</p><p>(3)、enum 枚举</p><p>(4)、primitive type 基本数据类型</p><p>(5)、annotation 注解</p><p>(6)、class：外部类、成员(成员内部类、静态内部类)、局部内部类、匿名内部类</p><p>(7)、void</p><h3 id="3、关于获取Class类的实例的方法"><a href="#3、关于获取Class类的实例的方法" class="headerlink" title="3、关于获取Class类的实例的方法"></a>3、关于获取Class类的实例的方法</h3><p>关于其中使用到的<a href="附录：">^Person</a>类见附录</p><p>(1)、方式一：通过运行时属性来获取</p><pre><code>Class&lt;Person&gt; clazz1 = Person.class;    System.out.println(clazz1);</code></pre><p>(2)、方式二：通过运行时类的对象来获取</p><pre><code>Person p1 = new Person();    Class clazz2 = p1.getClass();       //此方法在Object中声明    System.out.println(clazz2);</code></pre><p>(3)、方式三：通过静态方法forName(String classPath)来获取</p><pre><code>Class clazz3 = Class.forName(&quot;Reflaction.Person&quot;);    System.out.println(clazz3);</code></pre><p>(4)、方式四：通过类的加载ClassLoader来获取</p><pre><code>ClassLoader classLoader = ReflactionTest.class.getClassLoader();    Class&lt;Person&gt; clazz4 = (Class&lt;Person&gt;) classLoader.loadClass(&quot;Reflaction.Person&quot;);    System.out.println(clazz4);</code></pre><h3 id="4、一点点关于数组的小思考"><a href="#4、一点点关于数组的小思考" class="headerlink" title="4、一点点关于数组的小思考"></a>4、一点点关于数组的小思考</h3><pre><code>int[] a = new int[10];int[] b = new int[100];Class a10 = a.getClass();Class b100 = b.getClass();System.out.println(a10 == b100);</code></pre><p>结果为：<strong>true</strong><br>原因是：只要数组的元素类型和维度(一维数组、二维数组这样的)一样，它们为同一个Class<br></font></p><hr><h3 id="以下为Person类的附录："><a href="#以下为Person类的附录：" class="headerlink" title="以下为Person类的附录："></a>以下为Person类的附录：</h3><pre><code>package Reflaction;/** * @author BunnyAndOak0 * */public class Person {        private String name;        public int age;        public String getName() {            return name;        }        public void setName(String name) {            this.name = name;        }        public int getAge() {            return age;        }        public void setAge(int age) {            this.age = age;        }        public Person() {            super();            // TODO Auto-generated constructor stub        }        private Person(String name) {            super();            this.name = name;        }        public Person(String name, int age) {            super();            this.name = name;            this.age = age;        }        @Override        public String toString() {            return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;        }        public void show() {            System.out.println(&quot;我是一个人！&quot;);        }        private String showNation(String nation) {            System.out.println(&quot;我的国籍是：&quot; + nation);            return nation;        }}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2020/05/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <url>/2020/05/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="想写一点关于博客语法的东西"><a href="#想写一点关于博客语法的东西" class="headerlink" title="想写一点关于博客语法的东西"></a>想写一点关于博客语法的东西</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/05/07/hello-world/"/>
    <url>/2020/05/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
