<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java常用类——String、StringBuffer、StringBuilder</title>
    <link href="/2020/05/15/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E2%80%94%E2%80%94String%E3%80%81StringBuffer%E3%80%81StringBuilder/"/>
    <url>/2020/05/15/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E2%80%94%E2%80%94String%E3%80%81StringBuffer%E3%80%81StringBuilder/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>Java常用类——String、StringBuffer、StringBuilder</font></div>   <hr><font size='4'>   <h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>使用一对””引起来表示（java.lang.String类）<br>1、String声明为final，不可被继承<br>2、String实现了Serializable接口，表示字符串是支持可序列化的<br>emsp;emsp;实现了Comparable接口，表示String可以比较大小<br>3、内部定义了final char[] values用于存储字符串数据<br>4、String代表不可变的字符序列，简称：<strong>不可变性</strong><br>emsp;emsp;也就是说，当字符串重新赋值时，需要重写指定内存区域赋值，不可使用原有的values进行赋值<br>emsp;emsp;当对现有的字符串进行<strong>连接操作</strong>的时候，也需要重新指定内存区赋值，不可使用原有的value进行赋值<br>emsp;emsp;当调用String的<strong>replace()</strong>方法修改指定的字符或者字符串时，也需要指定内存区域，不能使用原有的value进行赋值<br>5、通过<strong>字面量</strong>的方式（例如： String s1 = “abc”;）给一个字符串赋值，此时，字符串声明在常量池中<br>6、字符串常量池中，<strong>不会存储相同的字符串</strong>    </p><h3 id="String实例化的方式"><a href="#String实例化的方式" class="headerlink" title="String实例化的方式"></a>String实例化的方式</h3><p>方式一：通过字面量定义的方式   </p><p>这种方式将javaEE声明在方法区中的字符串常量池中<br><font size='5'></p><pre><code>String s1 = &quot;javaEE&quot;;String s2 = &quot;javaEE&quot;;</code></pre></font><p>方式二：通过new + 构造器的方式   </p><p>引用中保存的是地址值，是数据在堆空间中开辟空间以后对应的地址值<br><font size='5'></p><pre><code>String s3 = new String(&quot;javaEE&quot;);String s4 = new String(&quot;javaEE&quot;);    </code></pre></font>   两者的==情况：   <font size='5'><pre><code>System.out.println(s1 == s2);//trueSystem.out.println(s1 == s3);//falseSystem.out.println(s1 == s4);//falseSystem.out.println(s3 == s4);//false </code></pre></font><p>细节上：   </p><p>1、常量与常量拼接的结果在常量池中，而且常量池中不会存在相同内容的常量<br>2、只要拼接时有一个时变量，结果就在堆中（例如当对现有的String进行再拼接时，其实是重新指定了内存区域的），如果不加final的话，因为加了final的变为常量<br><font size='5'></p><pre><code>String s1 = &quot;javaEEhadoop&quot;;final  String s2 = &quot;javaEE&quot;;String s3 = s2 + &quot;hadoop&quot;;System.out.println(s1 == s3);//true     </code></pre></font>   ![字面量赋值和new的区别](https://github.com/BunnyAndOak0/IMG/raw/master/images/%E5%AD%97%E9%9D%A2%E9%87%8F%E8%B5%8B%E5%80%BC%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB.png)      <p>Tips:<br>JVM中字符串常量池存放位置说明：<br>jdk 1.6 (jdk 6.0 ,java 6.0):字符串常量池存储在方法区（永久区）<br>jdk 1.7:字符串常量池存储在堆空间<br>jdk 1.8:字符串常量池存储在方法区（元空间）   </p><p>3、如果拼接结果调用intern()方法，返回值就在<strong>常量池</strong>中   </p><p>例如：<br><font size='5'></p><pre><code>public void test4(){    String s1 = &quot;javaEEhadoop&quot;;    String s2 = &quot;javaEE&quot;;    String s3 = s2 + &quot;hadoop&quot;;    System.out.println(s1 == s3);//false    final String s4 = &quot;javaEE&quot;;//s4:常量    String s5 = s4 + &quot;hadoop&quot;;    System.out.println(s1 == s5);//true}   </code></pre></font><p>使用intern()方法<br><font size='5'></p><pre><code>    public void test3(){    String s1 = &quot;javaEE&quot;;    String s2 = &quot;hadoop&quot;;    String s3 = &quot;javaEEhadoop&quot;;    String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;;    String s5 = s1 + &quot;hadoop&quot;;    String s6 = &quot;javaEE&quot; + s2;    String s7 = s1 + s2;    System.out.println(s3 == s4);//true    System.out.println(s3 == s5);//false    System.out.println(s3 == s6);//false    System.out.println(s3 == s7);//false    System.out.println(s5 == s6);//false    System.out.println(s5 == s7);//false    System.out.println(s6 == s7);//false    String s8 = s6.intern();//返回值得到的s8使用的常量值中已经存在的“javaEEhadoop”    System.out.println(s3 == s8);//true}   </code></pre></font><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>int length()：返回字符串的长度： return value.length<br>char charAt(int index)： 返回某索引处的字符return value[index]<br>boolean isEmpty()：判断是否是空字符串：return value.length == 0<br>String toLowerCase()：使用默认语言环境，将 String 中的所字符转换为小写<br>String toUpperCase()：使用默认语言环境，将 String 中的所字符转换为大写<br>String trim()：返回字符串的副本，忽略前导空白和尾部空白<br>boolean equals(Object obj)：比较字符串的内容是否相同<br>boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写<br>String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”<br>int compareTo(String anotherString)：比较两个字符串的大小<br>String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。<br>String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。<strong>左闭右开</strong>   </p><p>boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束<br>boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始<br>boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始<br>boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true<br>int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引<br>int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始<br>int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引<br>int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索   </p><p>注：indexOf和lastIndexOf方法如果未找到都是返回-1   </p><p>替换：<br>String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所 oldChar 得到的。<br>String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串。<br>String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所匹配给定的正则表达式的子字符串。<br>String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。<br>匹配:<br>boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。<br>切片：<br>String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。<br>String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。   </p><h3 id="String与其他类型的转换"><a href="#String与其他类型的转换" class="headerlink" title="String与其他类型的转换"></a>String与其他类型的转换</h3><p>1、String 与基本数据类型、包装类之间的转换。<br>String –&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)<br>基本数据类型、包装类 –&gt; String:调用String重载的valueOf(xxx)<br><font size='5'></p><pre><code>    @Testpublic void test1(){    String str1 = &quot;123&quot;;//   int num = (int)str1;//错误的    int num = Integer.parseInt(str1);    String str2 = String.valueOf(num);//&quot;123&quot;    String str3 = num + &quot;&quot;;    System.out.println(str1 == str3);    }}   </code></pre></font><p>2、String 与 char[]之间的转换<br>String –&gt; char[]:调用String的toCharArray()<br>char[] –&gt; String:<strong>调用String的构造器</strong>(ball ball you 不要再错在这里了！！！)<br><font size='5'></p><pre><code>public void test2(){    String str1 = &quot;abc123&quot;;  //题目： a21cb3    char[] charArray = str1.toCharArray();    for (int i = 0; i &lt; charArray.length; i++) {        System.out.println(charArray[i]);    }    char[] arr = new char[]{&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;};    String str2 = new String(arr);    System.out.println(str2);}   </code></pre></font><p>3、String 与 byte[]之间的转换<br>编码：String –&gt; byte[]:调用String的getBytes()<br>解码：byte[] –&gt; String:调用String的构造器   </p><p>编码：字符串 –&gt;字节  (看得懂 —&gt;看不懂的二进制数据)<br>解码：编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂）   </p><p>说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。<br><font size='5'></p><pre><code>public void test3() throws UnsupportedEncodingException {    String str1 = &quot;abc123中国&quot;;    byte[] bytes = str1.getBytes();//使用默认的字符集，进行编码。    System.out.println(Arrays.toString(bytes));    byte[] gbks = str1.getBytes(&quot;gbk&quot;);//使用gbk字符集进行编码。    System.out.println(Arrays.toString(gbks));    System.out.println(&quot;******************&quot;);    String str2 = new String(bytes);//使用默认的字符集，进行解码。    System.out.println(str2);    String str3 = new String(gbks);    System.out.println(str3);//出现乱码。原因：编码集和解码集不一致！    String str4 = new String(gbks, &quot;gbk&quot;);    System.out.println(str4);//没有出现乱码。原因：编码集和解码集一致！}   </code></pre></font><h3 id="与字符串相关的类"><a href="#与字符串相关的类" class="headerlink" title="与字符串相关的类"></a>与字符串相关的类</h3><p>与StringBuffer、StringBuilder之间的转换<br>String –&gt; StringBuffer、StringBuilder:调用StringBuffer、StringBuilder构造器<br>StringBuffer、StringBuilder –&gt; String:①调用String构造器；②StringBuffer、StringBuilder的toString()   </p><p>String、StringBuffer、StringBuilder三者的异同<br>String:不可变的字符序列；底层使用char[]存储<br>StringBuffer:可变的字符序列；<strong>线程安全</strong>的，<strong>效率低</strong>；底层使用char[]存储<br>StringBuilder:可变的字符序列；jdk5.0新增的，<strong>线程不安全</strong>的，<strong>效率高</strong>；底层使用char[]存储    </p><p>TIps：<br>源码分析：<br>String str = new String();//char[] value = new char[0];<br>tring str1 = new String(“abc”);//char[] value = new char[]{‘a’,’b’,’c’};<br>StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。<br>System.out.println(sb1.length());<br>sb1.append(‘a’);//value[0] = ‘a’;<br>sb1.append(‘b’);//value[1] = ‘b’;   </p><p>扩容问题:<br>如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。<br>默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。   </p><p>StringBuffer的常用方法：<br>StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接<br>StringBuffer delete(int start,int end)：删除指定位置的内容<br>StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str<br>StringBuffer insert(int offset, xxx)：在指定位置插入xxx<br>StringBuffer reverse() ：把当前字符序列逆转<br>public int indexOf(String str)<br>public String substring(int start,int end):返回一个从start开始到end索引结束的左闭右开区间的子字符串<br>public int length()<br>public char charAt(int n )<br>public void setCharAt(int n ,char ch)   </p><p>遍历：for() + charAt() / toString()   </p><p>对比String、StringBuffer、StringBuilder三者的效率：<br>从高到低排列：StringBuilder &gt; StringBuffer &gt; String   </p></font>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java常用类——Date、比较器、其他类</title>
    <link href="/2020/05/15/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E2%80%94%E2%80%94Date%E3%80%81%E6%AF%94%E8%BE%83%E5%99%A8%E3%80%81%E5%85%B6%E4%BB%96%E7%B1%BB/"/>
    <url>/2020/05/15/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E2%80%94%E2%80%94Date%E3%80%81%E6%AF%94%E8%BE%83%E5%99%A8%E3%80%81%E5%85%B6%E4%BB%96%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>Java常用类——Date、比较器、其他类</font></div> <hr><h2 id="JDK8之前的日期API"><a href="#JDK8之前的日期API" class="headerlink" title="JDK8之前的日期API"></a>JDK8之前的日期API</h2><h3 id="System类中的currentTimeMillis"><a href="#System类中的currentTimeMillis" class="headerlink" title="System类中的currentTimeMillis()"></a>System类中的currentTimeMillis()</h3><p><font size='4'>返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差，称为时间戳</font></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">long</span> time = System.currentTimeMillis();        <span class="hljs-comment">//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</span>        System.out.println(time);    &#125;</code></pre><h3 id="java-util-Date类和java-sql-Date类"><a href="#java-util-Date类和java-sql-Date类" class="headerlink" title="java.util.Date类和java.sql.Date类"></a>java.util.Date类和java.sql.Date类</h3><p>java.util.Date类 </p><p>&emsp;&emsp;&emsp;|—java.sql.Date类  </p><p>1、两个构造器的使用  </p><p> 构造器一：Date()：创建一个对应当前时间的Date对象  </p><p> 构造器二：创建指定毫秒数的Date对象</p><pre><code class="hljs jav">&#x2F;&#x2F;构造器一：Date()：创建一个对应当前时间的Date对象   Date date1 &#x3D; new Date();   System.out.println(date1.toString());&#x2F;&#x2F;Sat Feb 16 16:35:31 GMT+08:00 2019   System.out.println(date1.getTime());&#x2F;&#x2F;1550306204104</code></pre><p>2、两个方法的使用<br> toString():显示当前的年、月、日、时、分、秒<br> getTime():获取当前Date对象对应的毫秒数。（时间戳）</p><pre><code class="hljs jav">&#x2F;&#x2F;构造器二：创建指定毫秒数的Date对象   Date date2 &#x3D; new Date(155030620410L);   System.out.println(date2.toString());</code></pre><p>3、java.sql.Date对应着数据库中的日期类型的变量  </p><pre><code class="hljs ja">&#x2F;&#x2F;创建java.sql.Date对象   java.sql.Date date3 &#x3D; new java.sql.Date(35235325345L);   System.out.println(date3);&#x2F;&#x2F;1971-02-13     &#x2F;&#x2F;将java.util.Date对象转换为java.sql.Date对象   &#x2F;&#x2F;情况一：&#x2F;&#x2F;  Date date4 &#x3D; new java.sql.Date(2343243242323L);&#x2F;&#x2F;  java.sql.Date date5 &#x3D; (java.sql.Date) date4;   &#x2F;&#x2F;情况二：   Date date6 &#x3D; new Date();   java.sql.Date date7 &#x3D; new java.sql.Date(date6.getTime());</code></pre><h3 id="java-text-SimpleDataFormat类"><a href="#java-text-SimpleDataFormat类" class="headerlink" title="java.text.SimpleDataFormat类"></a>java.text.SimpleDataFormat类</h3><p>SimpleDateFormat对日期Date类的格式化和解析  </p><p> 1、格式化：日期 —&gt; 字符串  </p><p> 2、解析：格式化的逆过程，字符串 —&gt; 日期  </p><p> 3、SimpleDateFormat的实例化:new + 构造器</p><pre><code class="hljs ja">@Test   public void testSimpleDateFormat() throws ParseException &#123;       &#x2F;&#x2F;实例化SimpleDateFormat:使用默认的构造器       SimpleDateFormat sdf &#x3D; new SimpleDateFormat();       &#x2F;&#x2F;格式化：日期 ---&gt;字符串       Date date &#x3D; new Date();       System.out.println(date);       String format &#x3D; sdf.format(date);       System.out.println(format);       &#x2F;&#x2F;解析：格式化的逆过程，字符串 ---&gt; 日期       String str &#x3D; &quot;19-12-18 上午11:43&quot;;       Date date1 &#x3D; sdf.parse(str);       System.out.println(date1);       &#x2F;&#x2F;*************按照指定的方式格式化和解析：调用带参的构造器*****************&#x2F;&#x2F; SimpleDateFormat sdf1 &#x3D; new SimpleDateFormat(&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;);       SimpleDateFormat sdf1 &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);       &#x2F;&#x2F;格式化       String format1 &#x3D; sdf1.format(date);       System.out.println(format1);&#x2F;&#x2F;2019-02-18 11:48:27       &#x2F;&#x2F;解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现),       &#x2F;&#x2F;否则，抛异常       Date date2 &#x3D; sdf1.parse(&quot;2020-02-18 11:48:27&quot;);       System.out.println(date2);&#x2F;&#x2F;Tue Feb 18 11:48:27 CST 2020   &#125;</code></pre><h3 id="Calendar类：日历类、抽象类"><a href="#Calendar类：日历类、抽象类" class="headerlink" title="Calendar类：日历类、抽象类"></a>Calendar类：日历类、抽象类</h3><p>1、实例化  </p><p> 方式一：创建其子类（GregorianCalendar的对象  </p><p> 方式二：调用其静态方法getInstance()  </p><pre><code class="hljs ja">Calendar calendar &#x3D; Calendar.getInstance();&#x2F;&#x2F;System.out.println(calendar.getClass());</code></pre><p>2、常用方法  </p><p> get()</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> days = calendar.get(Calendar.DAY_OF_MONTH);System.out.println(days);System.out.println(calendar.get(Calendar.DAY_OF_YEAR));</code></pre><p>set()</p><pre><code class="hljs java"><span class="hljs-comment">//calendar可变性</span>calendar.set(Calendar.DAY_OF_MONTH,<span class="hljs-number">22</span>);days = calendar.get(Calendar.DAY_OF_MONTH);System.out.println(days);</code></pre><p>add()</p><pre><code class="hljs java">calendar.add(Calendar.DAY_OF_MONTH,-<span class="hljs-number">3</span>);days = calendar.get(Calendar.DAY_OF_MONTH);System.out.println(days);</code></pre><p>getTime():日历类—&gt; Date </p><pre><code class="hljs java">Date date = calendar.getTime();System.out.println(date);</code></pre><p>setTime():Date —&gt; 日历类</p><pre><code class="hljs java">Date date1 = <span class="hljs-keyword">new</span> Date();calendar.setTime(date1);days = calendar.get(Calendar.DAY_OF_MONTH);System.out.println(days);</code></pre><h3 id="JDK8中新的日期时API"><a href="#JDK8中新的日期时API" class="headerlink" title="JDK8中新的日期时API"></a>JDK8中新的日期时API</h3><p>迭代  </p><p> 第一代：jdk 1.0 Date类  </p><p> 第二代：jdk 1.1 Calendar类，一定程度上替换Date类  </p><p> 第三代：jdk 1.8 提出了新的一套API  </p><p> 存在问题  </p><p> 可变性：像日期和时间这样的类应该是不可变的。  </p><p> 偏移性：Date中的年份是从1900开始的，而月份都从0开始。  </p><p> 格式化：格式化只对Date用，Calendar则不行。  </p><p> 此外，它们也不是线程安全的；不能处理闰秒等。  </p><p> 1、LocalDate、LocalTime、LocalDateTime 的使用  </p><p> 说明：  </p><p> LocalDateTime相较于LocalDate、LocalTime，使用频率要高  </p><p> 类似于Calendar  </p><p> <img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/LocalDateTime.png" srcset="/img/loading.gif" alt="LocalDateTime">  </p><p> 2、Instant的使用  </p><p> 类似于 java.util.Date类  </p><p> <img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/Instant.png" srcset="/img/loading.gif" alt="Instant"></p><p> 3、DateTimeFormatter  </p><p> 格式化或解析日期、时间  </p><p> 类似于SimpleDateFormat </p><pre><code class="hljs java"><span class="hljs-comment">//  重点：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</span>DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd hh:mm:ss"</span>);<span class="hljs-comment">//格式化</span>String str4 = formatter3.format(LocalDateTime.now());System.out.println(str4);<span class="hljs-comment">//2019-02-18 03:52:09</span><span class="hljs-comment">//解析</span>TemporalAccessor accessor = formatter3.parse(<span class="hljs-string">"2019-02-18 03:52:09"</span>);System.out.println(accessor);</code></pre><p><img src="https://github.com/BunnyAndOak0/IMG/blob/master/images/DateTimeFormatter.png" srcset="/img/loading.gif" alt="DateTimeFormatter"></p><h2 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h2><p>System类  </p><p> System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。<br> 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。  </p><p> 方法：  </p><p> native long currentTimeMillis()  </p><p> void exit(int status)  </p><p> void gc()  </p><p> String getProperty(String key) </p><pre><code class="hljs java">String javaVersion = System.getProperty(<span class="hljs-string">"java.version"</span>);System.out.println(<span class="hljs-string">"java的version:"</span> + javaVersion);String javaHome = System.getProperty(<span class="hljs-string">"java.home"</span>);System.out.println(<span class="hljs-string">"java的home:"</span> + javaHome);</code></pre><p>Math类  </p><p> java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。  </p><p> BigInteger类、BigDecimal类  </p><p> java.math包的BigInteger可以表示不可变的任意精度的整数  </p><p> 要求数字精度比较高，用到java.math.BigDecimal类</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;        BigInteger bi = <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">"1243324112234324324325235245346567657653"</span>);        BigDecimal bd = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"12435.351"</span>);        BigDecimal bd2 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"11"</span>);        System.out.println(bi);<span class="hljs-comment">//1243324112234324324325235245346567657653</span>        <span class="hljs-comment">//  System.out.println(bd.divide(bd2));</span>        System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));<span class="hljs-comment">//1130.486</span>        System.out.println(bd.divide(bd2, <span class="hljs-number">25</span>, BigDecimal.ROUND_HALF_UP));<span class="hljs-comment">//1130.4864545454545454545454545</span>    &#125;</code></pre><h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p>使用场景  </p><p> Java中的对象，正常情况下，只能进行比较：== 或 != 。不能使用 &gt; 或 &lt; 的但是在开发场景中，我们需要对多个对象进行排序，就可以使用两个接口中的任何一个：Comparable 或 Comparator  </p><p> 1、Comparable接口的使用举例：自然排序  </p><p> 像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。  </p><p> 像String、包装类重写compareTo()方法以后，进行了从小到大的排列  </p><p> 重写compareTo(obj)的规则：  </p><p> &emsp;&emsp;如果当前对象this大于形参对象obj，则返回正整数，  </p><p> &emsp;&emsp;如果当前对象this小于形参对象obj，则返回负整数，  </p><p> &emsp;&emsp;如果当前对象this等于形参对象obj，则返回零。  </p><p> 对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。在compareTo(obj)方法中指明如何排序  </p><p> 例如：在String中</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;        String[] arr = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"AA"</span>,<span class="hljs-string">"CC"</span>,<span class="hljs-string">"KK"</span>,<span class="hljs-string">"MM"</span>,<span class="hljs-string">"GG"</span>,<span class="hljs-string">"JJ"</span>,<span class="hljs-string">"DD"</span>&#125;;        Arrays.sort(arr);        System.out.println(Arrays.toString(arr));    &#125;</code></pre><p>在自定义类中 </p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;        Goods[] arr = <span class="hljs-keyword">new</span> Goods[<span class="hljs-number">5</span>];        arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"lenovoMouse"</span>,<span class="hljs-number">34</span>);        arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"dellMouse"</span>,<span class="hljs-number">43</span>);        arr[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"xiaomiMouse"</span>,<span class="hljs-number">12</span>);        arr[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"huaweiMouse"</span>,<span class="hljs-number">65</span>);        arr[<span class="hljs-number">4</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"microsoftMouse"</span>,<span class="hljs-number">43</span>);        Arrays.sort(arr);        System.out.println(Arrays.toString(arr));    &#125;</code></pre><p>先实现Comparable接口： </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Goods</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">Comparable</span></span></code></pre><p>重新compareTo()方法：</p><pre><code class="hljs java"><span class="hljs-comment">//指明商品比较大小的方式:按照价格从低到高排序,再按照产品名称从高到低排序</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;<span class="hljs-comment">//  System.out.println("**************");</span>        <span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Goods)&#123;            Goods goods = (Goods)o;            <span class="hljs-comment">//方式一：</span>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.price &gt; goods.price)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.price &lt; goods.price)&#123;                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//    return 0;</span>               <span class="hljs-keyword">return</span> -<span class="hljs-keyword">this</span>.name.compareTo(goods.name);            &#125;            <span class="hljs-comment">//方式二：</span><span class="hljs-comment">//   return Double.compare(this.price,goods.price);</span>        &#125;<span class="hljs-comment">//   return 0;</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"传入的数据类型不一致！"</span>);    &#125;</code></pre><hr><p>2、Comparator接口的使用：定制排序 </p><p>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序  </p><p> 重写compare(Object o1,Object o2)方法，比较o1和o2的大小：  </p><p> 如果方法返回正整数，则表示o1大于o2；  </p><p> 如果返回0，表示相等；  </p><p> 返回负整数，表示o1小于o2。  </p><p> 例如Stirng类型定制排序： </p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;        String[] arr = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"AA"</span>,<span class="hljs-string">"CC"</span>,<span class="hljs-string">"KK"</span>,<span class="hljs-string">"MM"</span>,<span class="hljs-string">"GG"</span>,<span class="hljs-string">"JJ"</span>,<span class="hljs-string">"DD"</span>&#125;;        Arrays.sort(arr,<span class="hljs-keyword">new</span> Comparator()&#123;            <span class="hljs-comment">//按照字符串从大到小的顺序排列</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;                <span class="hljs-keyword">if</span>(o1 <span class="hljs-keyword">instanceof</span> String &amp;&amp; o2 <span class="hljs-keyword">instanceof</span>  String)&#123;                    String s1 = (String) o1;                    String s2 = (String) o2;                    <span class="hljs-keyword">return</span> -s1.compareTo(s2);                &#125;<span class="hljs-comment">// return 0;</span>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不一致"</span>);            &#125;        &#125;);        System.out.println(Arrays.toString(arr));    &#125;</code></pre><p>例如自定义类定制排序：</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span>&#123;        Goods[] arr = <span class="hljs-keyword">new</span> Goods[<span class="hljs-number">6</span>];        arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"lenovoMouse"</span>,<span class="hljs-number">34</span>);        arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"dellMouse"</span>,<span class="hljs-number">43</span>);        arr[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"xiaomiMouse"</span>,<span class="hljs-number">12</span>);        arr[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"huaweiMouse"</span>,<span class="hljs-number">65</span>);        arr[<span class="hljs-number">4</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"huaweiMouse"</span>,<span class="hljs-number">224</span>);        arr[<span class="hljs-number">5</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"microsoftMouse"</span>,<span class="hljs-number">43</span>);        Arrays.sort(arr, <span class="hljs-keyword">new</span> Comparator() &#123;            <span class="hljs-comment">//指明商品比较大小的方式:按照产品名称从低到高排序,再按照价格从高到低排序</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;                <span class="hljs-keyword">if</span>(o1 <span class="hljs-keyword">instanceof</span> Goods &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> Goods)&#123;                    Goods g1 = (Goods)o1;                    Goods g2 = (Goods)o2;                    <span class="hljs-keyword">if</span>(g1.getName().equals(g2.getName()))&#123;                        <span class="hljs-keyword">return</span> -Double.compare(g1.getPrice(),g2.getPrice());                    &#125;<span class="hljs-keyword">else</span>&#123;                        <span class="hljs-keyword">return</span> g1.getName().compareTo(g2.getName());                    &#125;                &#125;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不一致"</span>);            &#125;        &#125;);        System.out.println(Arrays.toString(arr));    &#125;</code></pre><p>例如，定义了comparator的比较方法之后：  </p><pre><code class="hljs java">Comparator com = <span class="hljs-keyword">new</span> Comparator() &#123;    <span class="hljs-comment">//指明商品比较大小的方式:照产品名称从低到高排序,再照价格从高到低排序</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;        <span class="hljs-keyword">if</span>(o1 <span class="hljs-keyword">instanceof</span> Goods &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> Goods)&#123;            Goods g1 = (Goods)o1;            Goods g2 = (Goods)o2;            <span class="hljs-keyword">if</span>(g1.getName().equals(g2.getName()))&#123;                <span class="hljs-keyword">return</span> -Double.compare(g1.getPrice(),g2.getPrice());            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">return</span> g1.getName().compareTo(g2.getName());            &#125;        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不一致"</span>);    &#125;&#125;</code></pre><p>使用场景：  </p><p> Arrays.sort(goods,com);  </p><p> Collections.sort(coll,com);  </p><p> new TreeSet(com); </p><hr><p>Comparable接口与Comparator的使用的对比：  </p><p> Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。  </p><p> Comparator接口属于临时性的比较</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程梳理</title>
    <link href="/2020/05/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <url>/2020/05/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>多线程梳理</font></div>   <hr><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><font size='4'>程序：<br>&emsp;&emsp;是为了完成特定任务，用某种语言编写的一组指令的集合，也就是一段静态代码。<br>进程：<br>&emsp;&emsp;是程序的一次执行过程，或是<strong>正在执行的一个程序</strong>。<br>线程：<br>&emsp;&emsp;进程可以细化为线程，也就是程序内部的一条执行的路径（可以作为调度和执行的单位，每个线程拥有独立的运行栈和计数器配就是pc）。<br>也就是说：进程可以细化为多个线程，而每个线程拥有自己独立的栈，程序计数器，多个线程共享同一个进程中的方法区和堆。<br>内存结构如图：<br><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" alt="内存结构">   </p><p>多线程的优点：提高程序的响应，提高CPU的利用率，改善程序结构<br>善用多线程的环境：需要执行两个或者多个任务，是要实现一些要等待的任务，需要在后台运行等。</p><h2 id="单核与多核-并发与并行"><a href="#单核与多核-并发与并行" class="headerlink" title="单核与多核 并发与并行"></a>单核与多核 并发与并行</h2><p>单核CPU：其实是一种假的多线程，因为在一个时间单元内，只能执行一个线程任务。<br>多核CPU：可以更好的发挥多线程的效率。<br>Tips：<br>&emsp;&emsp;一个java程序java.exe，至少有三个线程，main()主程序，gc()垃圾回收线程，异常处理线程。   </p><p>并行：多个CPU同时执行多个任务。<br>并发：一个CPU（采用时间片）同时执行多个任务。</font>   </p><h2 id="创建多线程的方式-总共四种"><a href="#创建多线程的方式-总共四种" class="headerlink" title="创建多线程的方式(总共四种)"></a>创建多线程的方式(总共四种)</h2><h3 id="方式一：继承于Thread类"><a href="#方式一：继承于Thread类" class="headerlink" title="方式一：继承于Thread类"></a>方式一：继承于Thread类</h3><font size='4'>   <p>1、创建一个继承于Thread类的子类<br>2、重写Thread类的run()方法 —&gt;  将要执行的操作生命在run()中即可<br>3、创建Thread类的子类的对象<br>4、通过此对象调用<strong>start()</strong>，调用的是start()，不是run()   </p><p>调用start()的时候，会启动当前线程，并调用当前线程的run()<br>Tips：<br>&emsp;&emsp;不可以直接调用run()方法，这样的话只会调用方法而不会启动线程<br>&emsp;&emsp;不可以在已启动的线程上再次调用start()，否则会报会报IllegalThreadStateException的异常</font>   </p><h3 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h3><font size='4'>  <p>1、创建一个实现了Runnable接口的类<br>2、实现类去实现Runnable中的抽象方法run()<br>3、创建实现类的对象<br>4、将此对象作为参数传递到Thread类的构造器中，创建Thead类的对象<br>5、通过Thread类的对象调用start()   </p><p>通过Thread类的对象调用start()的时候，线程会启动，并调用当线程的run()方法，也就是调用了Runnable类型的target里面的run()</font>   </p><font size='5'>两种线程方式的比较：</font>   <font size='4'>   <p>开发中优先选用<strong>Runnable接口</strong>的方式<br>原因：<br>1、实现类的方式没有类的单继承性局限<br>2、实现类的方式更适合来处理多个线程有共享数据的情况   </p><p>相同点：两种方式都需要重新run()方法，将线程要执行的逻辑声明在run()中<br>(联系：public class Thread implements Runnable)   </p><h3 id="方式三：实现Callable接口-JDK5-0新增"><a href="#方式三：实现Callable接口-JDK5-0新增" class="headerlink" title="方式三：实现Callable接口(JDK5.0新增)"></a>方式三：实现Callable接口(JDK5.0新增)</h3><p>Callable和Raunnable比较<br>1、call()可以有返回值的。<br>2、call()可以抛出异常，被外面的操作捕获，获取异常的信息<br>3、Callable是支持泛型的<br><font size='5'></p><pre><code>//1.创建一个实现Callable的实现类class NumThread implements Callable{    //2.实现call方法，将此线程需要执行的操作声明在call()中    @Override    public Object call() throws Exception {        int sum = 0;        for (int i = 1; i &lt;= 100; i++) {            if(i % 2 == 0){                System.out.println(i);                sum += i;            }        }        return sum;    }}public class ThreadNew {    public static void main(String[] args) {        //3.创建Callable接口实现类的对象        NumThread numThread = new NumThread();        //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象        FutureTask futureTask = new FutureTask(numThread);        //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()        new Thread(futureTask).start();        try {            //6.获取Callable中call方法的返回值            //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。            Object sum = futureTask.get();            System.out.println(&quot;总和为：&quot; + sum);        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }    }}   </code></pre></font>   <h3 id="方式四：使用线程池-JDK5-0新增"><a href="#方式四：使用线程池-JDK5-0新增" class="headerlink" title="方式四：使用线程池(JDK5.0新增)"></a>方式四：使用线程池(JDK5.0新增)</h3><p>好处：<br>1、提高响应速度（减少了创建新线程的时间）<br>2、降低资源消耗（重复利用线程池中线程，不需要每次都创建）<br>3、便于线程管理<br>corePoolSize：核心池的大小<br>maximumPoolSize：最大线程数<br>keepAliveTime：线程没有任务时最多保持多长时间后会终止<br><font size='5'></p><pre><code>class NumberThread implements Runnable{    @Override    public void run() {        for(int i = 0;i &lt;= 100;i++){            if(i % 2 == 0){                System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i);            }        }    }}class NumberThread1 implements Runnable{    @Override    public void run() {        for(int i = 0;i &lt;= 100;i++){            if(i % 2 != 0){                System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i);            }        }    }}public class ThreadPool {    public static void main(String[] args) {        //1. 提供指定线程数量的线程池        ExecutorService service = Executors.newFixedThreadPool(10);        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;        //设置线程池的属性//        System.out.println(service.getClass());//        service1.setCorePoolSize(15);//        service1.setKeepAliveTime();        //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象        service.execute(new NumberThread());//适合适用于Runnable        service.execute(new NumberThread1());//适合适用于Runnable//        service.submit(Callable callable);//适合使用于Callable        //3.关闭连接池        service.shutdown();    }}</code></pre></font></font>   <h2 id="Thread常用的方法："><a href="#Thread常用的方法：" class="headerlink" title="Thread常用的方法："></a>Thread常用的方法：</h2><p><font size='4'>1、start()：启动当前线程调用run()<br>2、run()：通常需要重写Thread类中的此方法，声明要执行的操作<br>3、currentThread()：<strong>静态方法</strong>，返回执行当前代码的线程<br>4、setName()/getName()：设置/获取当前线程的名字(设置线程名字也可以在构造器中进行)<br>5、setName()：设置当前线程的名字<br>6、yield()：释放当前cpu的执行权，例如：this.yield()，<strong>但是不释放锁</strong><br>7、join()：在线程a中调用b的join()方法，则a就会进入阻塞状态，直达b完全执行完之后，才会结束阻塞状态，也就是说将b线程加入到main线程中，只有b线程运行结束，才会接着往下走<br>8、stop()：已过时，强制结束当前线程<br>9、sleep(毫秒数)：让当前线程睡眠指定的毫秒数，此时，线程是阻塞状态<br>10、isAlive()：判断当前线程是否存活   </p><p>线程的优先级：<br>1、<br>MAX_PRIORITY：10<br>MIN _PRIORITY：1<br>NORM_PRIORITY：5  –&gt;默认优先级<br>2.如何获取和设置当前线程的优先级：<br>getPriority():获取线程的优先级<br>setPriority(int p):设置线程的优先级   </p><p>说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。   </p><p>线程通行：wait()/notify()/notifyAll()：此三个的方法定义在Object类中   </p><p>线程分为：守护线程、用户线程<br>守护线程依赖于用户线程例如：垃圾回收，通过thread.setDaemon(true);可以将用户线程变为守护线程，如果jvm中都为守护线程，则当前jvm将会退出   </p></font>   <h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" srcset="/img/loading.gif" alt="生命周期">   </p><p><font size='4'>状态包括：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING ,TEARMINATED<br>(sleep()不会释放锁，wait()会释放锁)<font>   </p><h2 id="解决线程"><a href="#解决线程" class="headerlink" title="解决线程"></a>解决线程</h2><p><font size='4'>解决线程安全问题会用到同步机制，有三种方式，但是效率会下降，因为使用同步机制时就相当于是一个单线程，只有一个线程参与，而其他的线程等待   </p><h3 id="方式一：使用同步代码块"><a href="#方式一：使用同步代码块" class="headerlink" title="方式一：使用同步代码块"></a>方式一：使用同步代码块</h3><font size='5'><pre><code>synchronized(同步监视器){    //需要被同步的代码} </code></pre></font>   说明：   1.操作共享数据的代码，即为需要被同步的代码。  -->不能包含代码多了，也不能包含代码少了。   2.共享数据：多个线程共同操作的变量。比如：共享数据。   3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。   要求：多个线程必须要共用同一把锁。    补充：在**实现Runnable接口**创建多线程的方式中，我们可以考虑使用this充当同步监视器。   <p>对于继承了Thread类来实现线程的方法来说，<strong>同步代码块</strong>中的同步监视器，慎用this来充当同步监视器，而考虑使用<strong>当前类</strong>来充当同步监视器<br><font size='5'>   </p><pre><code>class Window2 extends Thread{    private static int ticket = 100;        private static Object obj = new Object();    @Override    public void run() {        while(true){            //正确的        // synchronized (obj){            synchronized (Window2.class){//Class clazz = Window2.class,Window2.class只会加载一次                //错误的方式：this代表着t1,t2,t3三个对象        // synchronized (this){                if(ticket &gt; 0){                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(getName() + &quot;：卖票，票号为：&quot; + ticket);                    ticket--;                }else{                    break;                }            }        }    }}public class WindowTest2 {    public static void main(String[] args) {        Window2 t1 = new Window2();        Window2 t2 = new Window2();        Window2 t3 = new Window2();        t1.setName(&quot;窗口1&quot;);        t2.setName(&quot;窗口2&quot;);        t3.setName(&quot;窗口3&quot;);        t1.start();        t2.start();        t3.start();    }}   </code></pre></font>   <p>对于<strong>实现Runnable接口</strong>实现多线程来说，<strong>同步代码块</strong>中的同步监视器可以为<strong>this</strong><br><font size='5'></p><pre><code>class Window1 implements Runnable{private int ticket = 100;//Object obj = new Object();//Dog dog = new Dog();    @Override    public void run() {//        Object obj = new Object();        while(true){            synchronized (this){//此时的this:唯一的Window1的对象   //方式二：synchronized (dog) {                if (ticket &gt; 0) {                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(Thread.currentThread().getName() + &quot;:卖票，票号为：&quot; + ticket);                    ticket--;                } else {                    break;                }            }        }    }}public class WindowTest1 {    public static void main(String[] args) {        Window1 w = new Window1();        Thread t1 = new Thread(w);        Thread t2 = new Thread(w);        Thread t3 = new Thread(w);        t1.setName(&quot;窗口1&quot;);        t2.setName(&quot;窗口2&quot;);        t3.setName(&quot;窗口3&quot;);        t1.start();        t2.start();        t3.start();    }}class Dog{}       </code></pre></font><h3 id="方式二：使用同步方法"><a href="#方式二：使用同步方法" class="headerlink" title="方式二：使用同步方法"></a>方式二：使用同步方法</h3><p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。<br>说明：<br>1、同步方法仍然涉及同步监视器，只是不需要我们现实的声明<br>2、<strong>非静态</strong>的同步方法，同步监视器是：<strong>this</strong><br>&emsp;<strong>静态</strong>的同步方法，同步监视器是：<strong>当前类本身</strong>   </p><p>对于使用<strong>继承Thread类</strong>的方法来实现线程的方法来说，而使用<strong>同步方法</strong>时，需要用<strong>static synchronized</strong>来修饰<br>例如：<br><font size='5'>  </p><pre><code>class Window4 extends Thread {    private static int ticket = 100;    @Override    public void run() {        while (true) {            show();        }    }    private static synchronized void show(){//同步监视器：Window4.class        //private synchronized void show(){ //同步监视器：t1,t2,t3。此种解决方式是错误的        if (ticket &gt; 0) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + ticket);            ticket--;        }    }}public class WindowTest4 {    public static void main(String[] args) {        Window4 t1 = new Window4();        Window4 t2 = new Window4();        Window4 t3 = new Window4();        t1.setName(&quot;窗口1&quot;);        t2.setName(&quot;窗口2&quot;);        t3.setName(&quot;窗口3&quot;);        t1.start();        t2.start();        t3.start();    }}</code></pre></font>  <p>对于<strong>实现Runnable接口</strong>实现多线程来说，同步监视器可以为<strong>this</strong>，使用<strong>同步方法</strong>时，要用<strong>sychronized</strong>来修饰方法<br>例如：<br><font size='5'></p><pre><code>class Window3 implements Runnable {    private int ticket = 100;    @Override    public void run() {        while (true) {            show();        }    }    private synchronized void show(){//同步监视器：this        //synchronized (this){            if (ticket &gt; 0) {                try {                    Thread.sleep(100);                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(Thread.currentThread().getName() + &quot;:卖票，票号为：&quot; + ticket);                ticket--;            }        //}    }}public class WindowTest3 {    public static void main(String[] args) {        Window3 w = new Window3();        Thread t1 = new Thread(w);        Thread t2 = new Thread(w);        Thread t3 = new Thread(w);        t1.setName(&quot;窗口1&quot;);        t2.setName(&quot;窗口2&quot;);        t3.setName(&quot;窗口3&quot;);        t1.start();        t2.start();        t3.start();    }}</code></pre></font>   <h3 id="方式三：使用Lock锁-JDK5-0新增"><a href="#方式三：使用Lock锁-JDK5-0新增" class="headerlink" title="方式三：使用Lock锁(JDK5.0新增)"></a>方式三：使用Lock锁(JDK5.0新增)</h3><p>没有使用同步监视器，因为其自身就是一个同步监视器<br>1、实例化ReentrantLock<br>2、调用锁定方法lock()<br>3、调用解锁方法unlock()   </p><p>例如：<br><font size='5'>   </p><pre><code>class Window implements Runnable{    private int ticket = 100;    //1.实例化ReentrantLock    private ReentrantLock lock = new ReentrantLock();    @Override    public void run() {        while(true){            try{                //2.调用锁定方法lock()                lock.lock();                if(ticket &gt; 0){                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(Thread.currentThread().getName() + &quot;：售票，票号为：&quot; + ticket);                    ticket--;                }else{                    break;                }            }finally {                //3.调用解锁方法：unlock()                lock.unlock();            }        }    }}public class LockTest {    public static void main(String[] args) {        Window w = new Window();        Thread t1 = new Thread(w);        Thread t2 = new Thread(w);        Thread t3 = new Thread(w);        t1.setName(&quot;窗口1&quot;);        t2.setName(&quot;窗口2&quot;);        t3.setName(&quot;窗口3&quot;);        t1.start();        t2.start();        t3.start();    }}    </code></pre></font>   <p>Tips:<br>synchronized和lock的异同：<br>相同：二者都可以解决线程安全问题<br>不同：synchronized机制在执行完响应的代码之后会<strong>自动释放同步监视器(锁)</strong>，而Lock需要调用方法来<strong>手动启动lock()</strong>,同时结束之后也需要<strong>手动实现unlock()</strong>     </p><p>同步机制的利弊：<br>好处：解决了线程的安全问题。<br>弊端：操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的资源，就形成了线程的思索   </p><p>说明：死锁出现后，不会出现异常，不会出现提示，只是所有的线程都处于堵塞状态，无法继续<br><font size='5'></p><pre><code>public class ThreadTest {    public static void main(String[] args) {        StringBuffer s1 = new StringBuffer();        StringBuffer s2 = new StringBuffer();        new Thread(){            @Override            public void run() {                synchronized (s1){                    s1.append(&quot;a&quot;);                    s2.append(&quot;1&quot;);                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    synchronized (s2){                        s1.append(&quot;b&quot;);                        s2.append(&quot;2&quot;);                        System.out.println(s1);                        System.out.println(s2);                    }                }            }        }.start();        new Thread(new Runnable() {            @Override            public void run() {                synchronized (s2){                    s1.append(&quot;c&quot;);                    s2.append(&quot;3&quot;);                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    synchronized (s1){                        s1.append(&quot;d&quot;);                        s2.append(&quot;4&quot;);                        System.out.println(s1);                        System.out.println(s2);                    }                }            }        }).start();    }}</code></pre></font>   <h2 id="使用同步机制将单例模式的懒汉式改为线程安全的"><a href="#使用同步机制将单例模式的懒汉式改为线程安全的" class="headerlink" title="使用同步机制将单例模式的懒汉式改为线程安全的"></a>使用同步机制将单例模式的懒汉式改为线程安全的</h2><font size='5'><pre><code>public class BankTest {}class Bank{    private Bank(){}    private static Bank instance = null;    public static Bank getInstance(){        //方式一：效率稍差//        synchronized (Bank.class) {//            if(instance == null){////                instance = new Bank();//            }//            return instance;//        }        //方式二：效率更高        if(instance == null){            synchronized (Bank.class) {                if(instance == null){                    instance = new Bank();                }            }        }        return instance;    }}</code></pre></font><h2 id="关于线程通信"><a href="#关于线程通信" class="headerlink" title="关于线程通信"></a>关于线程通信</h2><p>三个方法：<br>wait()：使当前线程进入阻塞，并释放同步监视器<br>notify()：唤醒被wait()的一个线程，如果多个线程被wait就唤醒优先级高的那个<br>notifyAll()：唤醒所有的被wait()的方法   </p><p>说明：<br>1、wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中<br>2、wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器，否则，会出现IllegalMonitorStateException异常<br>3、wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。   </p><p>sleep() 和 wait()的异同<br>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。<br>不同点：<br>(1)两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()<br>(2)调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中<br>(3)关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。   </p><p>例如：<br><font size='5'></p><pre><code>class Number implements Runnable{    private int number = 1;    private Object obj = new Object();    @Override    public void run() {        while(true){            synchronized (obj) {                obj.notify();                if(number &lt;= 100){                    try {                        Thread.sleep(10);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(Thread.currentThread().getName() + &quot;:&quot; + number);                    number++;                    try {                        //使得调用如下wait()方法的线程进入阻塞状态                        obj.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }else{                    break;                }            }        }    }}public class CommunicationTest {    public static void main(String[] args) {        Number number = new Number();        Thread t1 = new Thread(number);        Thread t2 = new Thread(number);        t1.setName(&quot;线程1&quot;);        t2.setName(&quot;线程2&quot;);        t1.start();        t2.start();    }}</code></pre></gont>   <h2 id="经典的生产者消费者问题"><a href="#经典的生产者消费者问题" class="headerlink" title="经典的生产者消费者问题"></a>经典的生产者消费者问题</h2><font size='5'><pre><code>class Clerk{    private int productCount = 0;    //生产产品    public synchronized void produceProduct() {        if(productCount &lt; 20){            productCount++;            System.out.println(Thread.currentThread().getName() + &quot;:开始生产第&quot; + productCount + &quot;个产品&quot;);            notify();        }else{            //等待            try {                wait();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    //消费产品    public synchronized void consumeProduct() {        if(productCount &gt; 0){            System.out.println(Thread.currentThread().getName() + &quot;:开始消费第&quot; + productCount + &quot;个产品&quot;);            productCount--;            notify();        }else{            //等待            try {                wait();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}class Producer extends Thread{//生产者    private Clerk clerk;    public Producer(Clerk clerk) {        this.clerk = clerk;    }    @Override    public void run() {        System.out.println(getName() + &quot;:开始生产产品.....&quot;);        while(true){            try {                Thread.sleep(10);            } catch (InterruptedException e) {                e.printStackTrace();            }            clerk.produceProduct();        }    }}class Consumer extends Thread{//消费者    private Clerk clerk;    public Consumer(Clerk clerk) {        this.clerk = clerk;    }    @Override    public void run() {        System.out.println(getName() + &quot;:开始消费产品.....&quot;);        while(true){            try {                Thread.sleep(20);            } catch (InterruptedException e) {                e.printStackTrace();            }            clerk.consumeProduct();        }    }}public class ProductTest {    public static void main(String[] args) {        Clerk clerk = new Clerk();        Producer p1 = new Producer(clerk);        p1.setName(&quot;生产者1&quot;);        Consumer c1 = new Consumer(clerk);        c1.setName(&quot;消费者1&quot;);        Consumer c2 = new Consumer(clerk);        c2.setName(&quot;消费者2&quot;);        p1.start();        c1.start();        c2.start();    }}</code></pre></font></font>   <p><a href="https://www.bilibili.com/video/BV1Qb411g7cz?p=413" target="_blank" rel="noopener">资料来源</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JSON的简单了解</title>
    <link href="/2020/05/14/JSON%E7%9A%84%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/"/>
    <url>/2020/05/14/JSON%E7%9A%84%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>JSON的简单了解</font></div><hr><h3 id="JSON是什么"><a href="#JSON是什么" class="headerlink" title="JSON是什么"></a>JSON是什么</h3><p>&emsp;&emsp;是一种基于JavaScript语法子集的开放标准数据交换格式。JSON是基于文本的，轻量级的，通常被认为易于读/写。</p><h3 id="语法格式要求"><a href="#语法格式要求" class="headerlink" title="语法格式要求"></a>语法格式要求</h3><font size='4'>&emsp;&emsp;在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：   1、对象数组表示为键值对   2、数据由逗号分隔   3、花括号保存对象   4、方括号保存数组   <p>JSON键值对是用来保存JS对象的一种方式，例如：<br>{“age”:”3”}<br>JSON是JS对象的字符串的表示法，它使用文本表示一个JS对象的信息。本质是一个字符串。</font>   </p><h3 id="JSON和JavaScript对象互转"><a href="#JSON和JavaScript对象互转" class="headerlink" title="JSON和JavaScript对象互转"></a>JSON和JavaScript对象互转</h3><p><font size='4'>JSON和JS对象的互转:<br>JSON字符串 —&gt;   JS对象<br>使用JSON.parse()方法:</p><p>JS对象 —&gt; JSON字符串<br>使用JSON.stringify()方法<br><font size='5'></p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    var user = {        name : &quot;爱丽丝&quot;,        age : 3,        sex : &quot;女&quot;    };    //输出此对象    console.log(user);    //将js对象转换为JSON    var str = JSON.stringify(user);    // str的输出结果：{&quot;name&quot;:&quot;爱丽丝&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;女&quot;}    console.log(str);    var obj = JSON.parse(str);    //obj的输出结果：{name: &quot;爱丽丝&quot;, age: 3, sex: &quot;女&quot;}    console.log(obj);&lt;/script&gt;   </code></pre></font><p>由于前后端分离，数据交互就变得异常重要，而json就是很重要的一部分</font>   </p><h3 id="使用Jackson进行json的解析"><a href="#使用Jackson进行json的解析" class="headerlink" title="使用Jackson进行json的解析"></a>使用Jackson进行json的解析</h3><p><font size='4'>Json返回的是一个字符串，而市面上有很多第三方jar包可以实现此功能，例如<strong>jackson</strong>（可以去maven仓库找）:可以利用@ResponseBody就可以将对象转换为json返回<br><font size='5'></p><pre><code>@Controllerpublic class UserController {    @RequestMapping(&quot;/json1&quot;)    @ResponseBody    public String json1() throws JsonProcessingException {       //创建一个jackson的对象映射器，用来解析数据       ObjectMapper mapper = new ObjectMapper();       //创建一个对象       User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);       //将我们的对象解析成为json格式       String str = mapper.writeValueAsString(user);       //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便       return str;    }}</code></pre></font><p>结果可以返回json的字符串，但是会出现乱码的问题<br>解决方法一：<br>使用@RequestMapping注解中的produces属性来指定返回类型和编码格式<br><font size='5'></p><pre><code>//produces:指定响应体返回类型和编码@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;)</code></pre></font>   可以解决乱码问题   <p>解决办法二：<br>在springMVC中，直接进行统一的配置，通过配置StringHttpMessageConverter进行转换<br><font size='5'></p><pre><code>&lt;mvc:annotation-driven&gt;    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;       &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;           &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;       &lt;/bean&gt;       &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;           &lt;property name=&quot;objectMapper&quot;&gt;               &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;                   &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;               &lt;/bean&gt;           &lt;/property&gt;       &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;</code></pre></font> </font><h3 id="关于统一返回json字符串"><a href="#关于统一返回json字符串" class="headerlink" title="关于统一返回json字符串"></a>关于统一返回json字符串</h3><p><font size='4'>可以直接在类上使用，@RestController，这样所有的方法返回的都是json字符串了，而不用每一个方法上都添加@ResponseBody，这是在开发中常用的方法<br><font size='5'></p><pre><code>@RestControllerpublic class UserController {    //produces:指定响应体返回类型和编码    @RequestMapping(value = &quot;/json1&quot;)    public String json1() throws JsonProcessingException {       //创建一个jackson的对象映射器，用来解析数据       ObjectMapper mapper = new ObjectMapper();       //创建一个对象       User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);       //将我们的对象解析成为json格式       String str = mapper.writeValueAsString(user);       //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便       return str;    }}   </code></pre></font></font><h3 id="关于时间问题的处理"><a href="#关于时间问题的处理" class="headerlink" title="关于时间问题的处理"></a>关于时间问题的处理</h3><p><font size='4'>json在将时间返回为json数据时，会将时间转换为时间戳的形式进行显示<br>解决办法：取消timestamps的形式，还可以自定义时间格式<br><font size='5'></p><pre><code>@RequestMapping(&quot;/json4&quot;)public String json4() throws JsonProcessingException {    ObjectMapper mapper = new ObjectMapper();    //不使用时间戳的方式   在此步骤关闭时间戳    mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);    //自定义日期格式对象    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    //指定日期格式    mapper.setDateFormat(sdf);    Date date = new Date();    String str = mapper.writeValueAsString(date);    return str;}</code></pre></font></font><h3 id="一点小拓展"><a href="#一点小拓展" class="headerlink" title="一点小拓展"></a>一点小拓展</h3><p><font size='4'>&emsp;&emsp;可以将经常使用的代码封装到一个工具类中：<br><font size='5'></p><pre><code>package com.kuang.utils;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import java.text.SimpleDateFormat;public class JsonUtils {    public static String getJson(Object object) {       return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;);    }    public static String getJson(Object object,String dateFormat) {       ObjectMapper mapper = new ObjectMapper();       //不使用时间差的方式       mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);       //自定义日期格式对象       SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);       //指定日期格式       mapper.setDateFormat(sdf);       try {           return mapper.writeValueAsString(object);      } catch (JsonProcessingException e) {           e.printStackTrace();      }       return null;    }}   </code></pre></font>这样调用的时候就可以直接使用啦</font>   <hr><p><font size='4'>&emsp;&emsp;astjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。   </p><p>记得导入fastjson 的 pom依赖！（可以在maven仓库找）</p><p>fastjson 三个主要的类：</p><p>（1）JSONObject  代表 json 对象 </p><p>（2）JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。</p><p>（3）JSONArray   代表 json 对象数组：内部是有List接口中的方法来完成操作的。<br>例如代码演示：<br><font size='5'></p><pre><code>package com.kuang.controller;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.kuang.pojo.User;import java.util.ArrayList;import java.util.List;public class FastJsonDemo {    public static void main(String[] args) {       //创建一个对象       User user1 = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);       User user2 = new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;);       User user3 = new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;);       User user4 = new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;);       List&lt;User&gt; list = new ArrayList&lt;User&gt;();       list.add(user1);       list.add(user2);       list.add(user3);       list.add(user4);       System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;);       String str1 = JSON.toJSONString(list);       System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1);       String str2 = JSON.toJSONString(user1);       System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2);       System.out.println(&quot;\n****** JSON字符串 转 Java对象*******&quot;);       User jp_user1=JSON.parseObject(str2,User.class);       System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1);       System.out.println(&quot;\n****** Java对象 转 JSON对象 ******&quot;);       JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);       System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;));       System.out.println(&quot;\n****** JSON对象 转 Java对象 ******&quot;);       User to_java_user = JSON.toJavaObject(jsonObject1, User.class);       System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user);    }}</code></pre></font><hr><p>以上资料参考：<a href="https://mp.weixin.qq.com/s/RAqRKZJqsJ78HRrJg71R1g" target="_blank" rel="noopener">狂神说JAVA</a></font></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式和方法引用</title>
    <link href="/2020/05/13/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    <url>/2020/05/13/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>Lambda表达式和方法引用的整理</font></div><hr><h2 id="Lanbda表达式"><a href="#Lanbda表达式" class="headerlink" title="Lanbda表达式"></a>Lanbda表达式</h2><font size='4'><h3 id="1、Lambda表达式的格式"><a href="#1、Lambda表达式的格式" class="headerlink" title="1、Lambda表达式的格式"></a>1、Lambda表达式的格式</h3><p><code>(o1,o2) -&gt; Integer.compare(o1,o2);</code><br>左边 —&gt; lambda表达式的形参列表，本质上也就是接口中抽象方法的形参列表<br>右边 —&gt; lambda体，也就是重写抽象方法的方法体   </p><h3 id="2、Lambda表达式的使用的六种情况："><a href="#2、Lambda表达式的使用的六种情况：" class="headerlink" title="2、Lambda表达式的使用的六种情况："></a>2、Lambda表达式的使用的六种情况：</h3><p>(1)语法格式一：无参，无返回值<br><font size='5'></p><pre><code>    @Testpublic void test1(){    //不使用Lambda表达式    Runnable r1 = new Runnable() {        @Override        public void run() {            System.out.println(&quot;不使用Lambda表达式&quot;);        }    };    r1.run();    System.out.println(&quot;***********************&quot;);    //使用Lambda表达式    Runnable r2 = () -&gt; {        System.out.println(&quot;使用Lambda表达式&quot;);    };    r2.run();}   </code></pre></font><p>(2)有一个参数，但是没有返回值<br><font size='5'></p><pre><code>@Testpublic void test2(){    //不使用Lambda表达式    Consumer&lt;String&gt; con = new Consumer&lt;String&gt;() {        @Override        public void accept(String s) {            System.out.println(s);        }    };    con.accept(&quot;不使用Lambda表达式&quot;);    System.out.println(&quot;*******************&quot;);    //使用Lambda表达式    Consumer&lt;String&gt; con1 = (String s) -&gt; {        System.out.println(s);    };    con1.accept(&quot;使用Lambda表达式&quot;);}   </code></pre></font><p>(3)数据类型可以省略，因为可以推断得出，称为类型推断<br><font size='5'></p><pre><code>@Testpublic void test3(){    //不使用Lambda表达式    Consumer&lt;String&gt; con1 = (String s) -&gt; {        System.out.println(s);    };    con1.accept(&quot;不使用Lambda表达式&quot;);    System.out.println(&quot;*******************&quot;);    //使用Lambda表达式    Consumer&lt;String&gt; con2 = (s) -&gt; {        System.out.println(s);    };    con2.accept(&quot;使用Lambda表达式&quot;);}</code></pre></font>   <p>(4)只需要一个参数的时候，小括号可以省略<br><font size='5'></p><pre><code>@Testpublic void test5(){    //不使用Lambda表达式    Consumer&lt;String&gt; con1 = (s) -&gt; {        System.out.println(s);    };    con1.accept(&quot;不使用Lambda表达式&quot;);    System.out.println(&quot;*******************&quot;);    //使用Lambda表达式    Consumer&lt;String&gt; con2 = s -&gt; {        System.out.println(s);    };    con2.accept(&quot;使用Lambda表达式&quot;);}</code></pre></font>   <p>(5)需要两个或两个以上的参数，多条执行语句，可以有返回值<br><font size='5'></p><pre><code>    @Testpublic void test6(){    //不使用Lambda表达式    Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;() {        @Override        public int compare(Integer o1, Integer o2) {            System.out.println(o1);            System.out.println(o2);            return o1.compareTo(o2);        }    };    System.out.println(com1.compare(12,21));    System.out.println(&quot;*****************************&quot;);    //使用Lambda表达式    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; {        System.out.println(o1);        System.out.println(o2);        return o1.compareTo(o2);    };    System.out.println(com2.compare(12,6));}</code></pre></font>   <p>(6)只有一条语句时，如果有返回值，return和大括号都可以省略（<strong>return必须省略</strong>）<br><font size='5'></p><pre><code>@Testpublic void test7(){    //不使用Lambda表达式    Comparator&lt;Integer&gt; com1 = (o1,o2) -&gt; {        return o1.compareTo(o2);    };    System.out.println(com1.compare(12,6));    System.out.println(&quot;*****************************&quot;);    //使用Lambda表达式    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; o1.compareTo(o2);    System.out.println(com2.compare(12,21));}</code></pre></font><p>综合的列子：<br>例子一：<br><font size='5'></p><pre><code>@Testpublic void test1(){    //不用Lambda表达式    happyTime(500, new Consumer&lt;Double&gt;() {        @Override        public void accept(Double aDouble) {            System.out.println(&quot;天上的星星有&quot; + aDouble);        }    });    System.out.println(&quot;********************&quot;);    //使用Lambda表达式    happyTime(400,nums -&gt; System.out.println(&quot;眼睛里有&quot; + nums + &quot;颗星星&quot;));}public void happyTime(double nums, Consumer&lt;Double&gt; con){    con.accept(nums);}   </code></pre></font><p>例子二：<br><font size='5'></p><pre><code>@Testpublic void test2(){    List&lt;String&gt; list = Arrays.asList(&quot;北京&quot;,&quot;南京&quot;,&quot;天津&quot;,&quot;东京&quot;,&quot;西京&quot;,&quot;普京&quot;);    List&lt;String&gt; filterStrs = filterString(list, new Predicate&lt;String&gt;() {        @Override        public boolean test(String s) {            return s.contains(&quot;京&quot;);        }    });    System.out.println(filterStrs);    List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains(&quot;京&quot;));    System.out.println(filterStrs1);}    //根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定    public List&lt;String&gt; filterString(List&lt;String&gt; list, Predicate&lt;String&gt; pre){        ArrayList&lt;String&gt; filterList = new ArrayList&lt;&gt;();        for(String s : list){            if(pre.test(s)){                filterList.add(s);            }        }        return filterList;    }}    </code></pre></font><p>总结：<br>&emsp;&emsp;-&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也可以省略<br>&emsp;&emsp;-&gt;右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对{}和return关键字</p><h3 id="3、lambda表达式的本质"><a href="#3、lambda表达式的本质" class="headerlink" title="3、lambda表达式的本质"></a>3、lambda表达式的本质</h3><p>作为函数式接口的<strong>实例</strong><br>&emsp;&emsp;所谓函数式接口也就是只声明了<strong>一个</strong>抽象方法的接口成为函数式接口，一般用@FunctionalInterface来注释，也可以用@FunctionalInterface来检验接口是否为函数式接口，如果不是函数式接口，会报错。<br>&emsp;&emsp;以前用匿名实现类表现的现在都可以用lambda表达式来写   </p><h3 id="4、关于函数式接口"><a href="#4、关于函数式接口" class="headerlink" title="4、关于函数式接口"></a>4、关于函数式接口</h3><p>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。<br>我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。<br><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.png" srcset="/img/loading.gif" alt="函数式接口"><br></font>   </p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><font size='4'>(1)使用情景   当传递给Lambda体的操作，已经有实现的方法了，就可以使用方法的引用   方法的引用：本质上就是Lambda表达式，而Lambda表达式时函数式接口的实例，所以，方法引用，也就是函数式接口的实例   使用格式：类（或对象）：：方法名   方法的引用使用要求：要求接口中抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同（针对于情况一和情况二）   <p>具体分为三种情况<br>情况一：对象 :: 实例方法<br><font size='5'></p><pre><code>//Consumer中的void accept(T t)//PrintStream中的void println(T t)@Testpublic void test1() {    Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);    con1.accept(&quot;北京&quot;);    System.out.println(&quot;*******************&quot;);    PrintStream ps = System.out;    Consumer&lt;String&gt; con2 = ps::println;    con2.accept(&quot;beijing&quot;);}   </code></pre></font><p>情况二：类 :: 静态方法<br><font size='5'></p><pre><code>//Comparator中的int compare(T t1,T t2)//Integer中的int compare(T t1,T t2)@Testpublic void test3() {    Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);    System.out.println(com1.compare(12,21));    System.out.println(&quot;*******************&quot;);    Comparator&lt;Integer&gt; com2 = Integer::compare;    System.out.println(com2.compare(12,3));}</code></pre></font>   <p>情况三：类 :: 实例方法  (有难度)<br><font size='5'>   </p><pre><code>// Comparator中的int comapre(T t1,T t2)// String中的int t1.compareTo(t2)@Testpublic void test5() {    Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);    System.out.println(com1.compare(&quot;abc&quot;,&quot;abd&quot;));    System.out.println(&quot;*******************&quot;);    Comparator&lt;String&gt; com2 = String :: compareTo;    System.out.println(com2.compare(&quot;abd&quot;,&quot;abm&quot;));}   //BiPredicate中的boolean test(T t1, T t2);//String中的boolean t1.equals(t2)@Testpublic void test6() {    BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);    System.out.println(pre1.test(&quot;abc&quot;,&quot;abc&quot;));    System.out.println(&quot;*******************&quot;);    BiPredicate&lt;String,String&gt; pre2 = String :: equals;    System.out.println(pre2.test(&quot;abc&quot;,&quot;abd&quot;));}</code></pre></font></font>   <hr><p><a href="https://www.bilibili.com/video/BV1Qb411g7cz?p=666" target="_blank" rel="noopener">资料来源</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Maven的大概梳理</title>
    <link href="/2020/05/13/%E5%85%B3%E4%BA%8EMaven%E7%9A%84%E5%A4%A7%E6%A6%82%E6%A2%B3%E7%90%86/"/>
    <url>/2020/05/13/%E5%85%B3%E4%BA%8EMaven%E7%9A%84%E5%A4%A7%E6%A6%82%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>关于Maven的大概梳理</font></div><hr><h2 id="目前项目中存在的问题"><a href="#目前项目中存在的问题" class="headerlink" title="目前项目中存在的问题"></a>目前项目中存在的问题</h2><p><font size='4'>1、一个项目就是一个工程<br>2、项目中需要的jar包必须手动复制，粘贴到”WEB-INF/lib”目录下<br>所带来的问题是：同样的jar包重复出现，这样浪费空间也让空间比较臃肿，借助maven可以将jar包保存在仓库中<br>3、jar包需要别人替我们准备好，或者到官网上下载<br>而官网提供的jar包下载形式是不同的，很不方便，面临各种问题，而借助maven可以按照统一的规范下载<br>4、一个jar包以来的其他的jar包需要自己手动加入到项目中<br></font>   </p><h2 id="maven是什么？"><a href="#maven是什么？" class="headerlink" title="maven是什么？"></a>maven是什么？</h2><p><font size='4'>Maven是一款服务于<strong>java</strong>平台的自动化构建工具<br>关于构建：<br>web工程和编译结果在目录上的不同：<br><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/maven%E4%B8%ADweb%E5%B7%A5%E7%A8%8B%E5%92%8C%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C%E7%9B%AE%E5%BD%95%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C.PNG" srcset="/img/loading.gif" alt="web工程和编译结果在目录上的不同"><br>构建的各个环节：<br>[1]清理：将以前的得到的旧的class字节码文件删除，为下一次编译做准备<br>[2]编译：将java源程序编译成class字节码文件<br>[3]测试：自动测试，自动调用junit程序<br>[4]报告：测试程序执行的结果<br>[5]打包：动态web工程打包为war包，java工程打jar包<br>[6]安装：maven特定的概念————将打包得到的文件复制到仓库中的位置<br>[7]部署：将动态的web工程生成war包复制到servlet容器指定目录下，使其可以运行</font>   </p><h2 id="maven的核心概念"><a href="#maven的核心概念" class="headerlink" title="maven的核心概念"></a>maven的核心概念</h2><h3 id="1、约定的目录结构"><a href="#1、约定的目录结构" class="headerlink" title="1、约定的目录结构"></a>1、约定的目录结构</h3><p><font size='4'>例如：<br>        目录结构<br>            Hello<br>            |—src<br>            |—|—main<br>            |—|—|—java<br>            |—|—|—resources<br>            |—|—test<br>            |—|—|—java<br>            |—|—|—resources<br>            |—pom.xml   </p><p>(1)根目录：工程名<br>(2)scr目录：源码<br>(3)pom.xml文件：maven工程的核心配置文件<br>(4)main目录：存放主程序<br>(5)test目录：存放测试程序<br>(6)java目录：存放java源程序<br>(7)resource目录：存放框架或者其他工具的配置文件   </p><p>一般来说：约定 &gt; 配置 &gt; 编码   </p><p>maven常用的命令<br>(1)mvn clean:清理<br>(2)mvn compile:编译主程序<br>(3)mvn test-complie:编译测试程序<br>(4)mvn test:执行测试<br>(5)mvn package:打包<br>(6)mvn site:生成站点   </p><p>Tips：<br>&emsp;&emsp;当我们执行maven命令需要用到某些插件时，maven核心程序会先去本地仓库（家目录）中寻找<code>C:\Users\18369\.m2\repository</code>如果没有找到，就会自动联网，在中央仓库中下载。</font>   </p><h3 id="2、pom"><a href="#2、pom" class="headerlink" title="2、pom"></a>2、pom</h3><p><font size='4'>(1)Project Object Model:项目对象模型<br>(2)pom.xml是maven工程的核心配置文件</font>   </p><h3 id="3、坐标"><a href="#3、坐标" class="headerlink" title="3、坐标"></a>3、坐标</h3><p><font size='4'>(1)使用三个向量在仓库中定位唯一的一个maven工程（管理jar包的方式）<br>&emsp;&emsp;[1]groupid：公司或者组织域名倒序+项目名   </p><pre><code>&lt;groupId&gt;org.example&lt;/groupId&gt;</code></pre><p>&emsp;&emsp;[2]artifactId：模块名   </p><pre><code>&lt;artifactId&gt;springMVC_day02_02_fileupload&lt;/artifactId&gt;   </code></pre><p>&emsp;&emsp;[3]version：版本</p><pre><code>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;   </code></pre></font><h3 id="4、依赖"><a href="#4、依赖" class="headerlink" title="4、依赖"></a>4、依赖</h3><p><font size='4'>(1)maven解析依赖信息的时候，会到本地仓库中查找被以来的jar包，对于我们自己的maven工程，使用mvn install命令安装后就可以进入仓库了。<br>(2)依赖的范围：<br><font size='5'><code>&lt;scope&gt;test&lt;/scope&gt;</code>默认值是compile</font>   </p><p>&emsp;&emsp;[1]compile<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对主程序<strong>有效</strong>，测试程序<strong>有效</strong>，<strong>参与</strong>打包，<strong>参与</strong>部署<br>&emsp;&emsp;[2]test<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对主程序<strong>无效</strong>，测试程序<strong>有效</strong>，<strong>不参与</strong>打包，<strong>不参与</strong>部署<br>&emsp;&emsp;[3]provided<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对主程序<strong>有效</strong>，测试程序<strong>有效</strong>，<strong>不参与</strong>打包，<strong>不参与</strong>部署   </p><p>(3)依赖的传递性<br>&emsp;&emsp;[1]可以传递的依赖不必在每个工程中都重复声明<br>&emsp;&emsp;[2]<strong>非</strong>compile范围的依赖是传递不过来的   </p><p>(4)依赖的排除<br>&emsp;&emsp;[1]需要设置依赖排除的场合<br>&emsp;&emsp;[2]依赖排除的方式<br><font size='5'></p><pre><code>&lt;exclusions&gt;    &lt;exclusion&gt;        &lt;groupId&gt;commons-logging&lt;/groupId&gt;        &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;    &lt;/exclusion&gt;&lt;/exclusions&gt;   </code></pre></font><p>(5)依赖的原则<br>&emsp;&emsp;[1]作用：解决模块工程之间的jar包冲突问题<br>&emsp;&emsp;[2]原则上：路径距离不同时：路径最短者优先<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;路径距离相同时：先声明者（指dependency标签的声明顺序）优先<br>(6)统一管理依赖的版本<br>建议方式：<br>&emsp;&emsp;[1]使用properties标签，其中使用自定义标签，统一声明版本号<br>&emsp;&emsp;例如：<br><font size='5'></p><pre><code>&lt;properties&gt;    &lt;edu.kmust.spring.version&gt;4.1.1.RELEASE&lt;/edu.kmust.spring.version&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt; </code></pre></font>  &emsp;&emsp;[2]在需要统一的位置，使用${自定义标签名}引用声明的版本号   &emsp;&emsp;例如：   <font size='5'><pre><code>&lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;        &lt;!-- 引用版本号实现统一管理 --&gt;        &lt;version&gt;${edu.kmust.spring.version}&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;   </code></pre></font><p>&emsp;&emsp;[3]properties标签并不只是可以声明版本号，也可以进行其他的设置，凡是需要统一声明后再使用的都可以引用<br><font size='5'></p><pre><code>&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;   </code></pre></font></font></font>    </font>   <h3 id="5、仓库"><a href="#5、仓库" class="headerlink" title="5、仓库"></a>5、仓库</h3><p><font size='4'>(1)分类<br>[1]本地仓库：当前电脑上<br>[2]远程仓库<br>&emsp;&emsp;私服：为当前局域网中的maven工程服务<br>&emsp;&emsp;中央仓库：架设在Internet上为全世界的maven服务<br>&emsp;&emsp;中央仓库的镜像：架设在各个州，为中央仓库分流，减轻负担，提升访问速度   </p><p>(2)仓库中保存的内容<br>&emsp;&emsp;[1]maven自身所诉需要的插件<br>&emsp;&emsp;[2]第三方框架或者工具的jar包<br>&emsp;&emsp;[3]我们自己开发的maven工程</font>   </p><h3 id="6、生命周期-插件-目标"><a href="#6、生命周期-插件-目标" class="headerlink" title="6、生命周期/插件/目标"></a>6、生命周期/插件/目标</h3><p><font size='4'>&emsp;&emsp;各个构建环节的执行顺序，不可打乱，必须按照正确的顺序来执行。<br>&emsp;&emsp;不论执行生命周期的哪一阶段，都是从生命周期最初的位置开始执行的。<br>&emsp;&emsp;插件和目标<br>&emsp;&emsp;&emsp;[1]生命周期的各个阶段仅仅定义了要执行的任务是什么<br>&emsp;&emsp;&emsp;[2]各个阶段和插件的目标是对应的<br>&emsp;&emsp;&emsp;[3]相似的目标又特定的插件完成   </p></font>   <h3 id="7、继承"><a href="#7、继承" class="headerlink" title="7、继承"></a>7、继承</h3><font size='4'>继承可以解决的问题：由于test范围的依赖不能传递，所以必然会分散再各个模块的工程中，很容易造成版本不一致。   需求：统一管理各个模块工程中对某个（例如junit）依赖的版本。   解决思路：将junit的依赖统一提取到父工程中，在子工程中声明junit时不指定版本，就以父工程中的统一设定为准。   <p>具体步骤：<br>[1]创建一个maven的父工程，打包方式为<strong>pom</strong><br><font size='5'></p><pre><code>&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;&lt;artifactId&gt;Parent&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt;</code></pre></font><p>[2]在子工程中声明对父工程的引用<br><font size='5'></p><pre><code>&lt;!-- 子工程中声明父工程 --&gt;&lt;parent&gt;    &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;    &lt;artifactId&gt;Parent&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;!-- 以当前文件为基准的父工程pom.xml文件的相对路径 --&gt;    &lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt;</code></pre></font><p>[3]将子工程的坐标与父工程中相同的部分删除<br>例如：<code>&lt;gourpId&gt;  &lt;/gourpId&gt;</code>等（有黄色波浪下划线的部分）<br>[4]在父工程中统一管理junit的依赖<br><font size='5'></p><pre><code>&lt;!-- 配置依赖的管理 --&gt;&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.9&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;</code></pre></font><p>[5]在子工程中删除junit依赖的版本号部分<br>也就是：<code>&lt;version&gt;  &lt;/version&gt;</code><br>Tips：配置继承后，执行命令时要先安装父工程</p><h3 id="8、聚合"><a href="#8、聚合" class="headerlink" title="8、聚合"></a>8、聚合</h3><p>作用：一键安装各个模块工具<br>在一个总的聚合工具中配置各个参与聚合的模块<br><font size='5'></p><pre><code>&lt;!-- 配置聚合 --&gt;&lt;modules&gt;    &lt;!-- 指定各个子工程的相对路径 --&gt;    &lt;module&gt;../HelloFriend&lt;/module&gt;    &lt;module&gt;../MakeFriends&lt;/module&gt;    &lt;module&gt;../Hello&lt;/module&gt;&lt;/modules&gt;</code></pre></font>   使用方法：在聚合工程的pom.xml上右键 ---> run as ---> maven install</font>   <hr><p><a href="https://www.bilibili.com/video/BV1Pt411y7Rh?p=1" target="_blank" rel="noopener">资料来源</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于反射的知识点的整理</title>
    <link href="/2020/05/07/%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E6%95%B4%E7%90%86/"/>
    <url>/2020/05/07/%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<div align='center' ><font size='6'>关于反射的知识点的整理</font></div><hr><h2 id="关于java-lang-Class的理解"><a href="#关于java-lang-Class的理解" class="headerlink" title="关于java.lang.Class的理解"></a>关于java.lang.Class的理解</h2><font size='4'><h3 id="1、类的加载过程"><a href="#1、类的加载过程" class="headerlink" title="1、类的加载过程"></a>1、类的加载过程</h3><p>&emsp;&emsp;程序在运行过程中通过javac.exe命令之后，会生成一个或者多个字节码文件(以.class结尾)，接着当我们使用java.exe命令对某个字节码文件进行解释编译运行，此时就相当于将某个字节码文件加载到了内存中，此过程称之为类的加载，而加载到内存中的类，我们称之为运行时类，此时的运行时类就作为一个Class的实例存在。换句话说，Class的实例就对应着一个运行时类。</p><h3 id="2、哪些对象可以有Class的对象"><a href="#2、哪些对象可以有Class的对象" class="headerlink" title="2、哪些对象可以有Class的对象"></a>2、哪些对象可以有Class的对象</h3><p>(1)、 interface 接口</p><p>(2)、数组[]</p><p>(3)、enum 枚举</p><p>(4)、primitive type 基本数据类型</p><p>(5)、annotation 注解</p><p>(6)、class：外部类、成员(成员内部类、静态内部类)、局部内部类、匿名内部类</p><p>(7)、void</p><h3 id="3、关于获取Class类的实例的方法"><a href="#3、关于获取Class类的实例的方法" class="headerlink" title="3、关于获取Class类的实例的方法"></a>3、关于获取Class类的实例的方法</h3><p>关于其中使用到的<a href="附录：">^Person</a>类见附录</p><p>(1)、方式一：通过运行时属性来获取</p><pre><code>Class&lt;Person&gt; clazz1 = Person.class;    System.out.println(clazz1);</code></pre><p>(2)、方式二：通过运行时类的对象来获取</p><pre><code>Person p1 = new Person();    Class clazz2 = p1.getClass();       //此方法在Object中声明    System.out.println(clazz2);</code></pre><p>(3)、方式三：通过静态方法forName(String classPath)来获取</p><pre><code>Class clazz3 = Class.forName(&quot;Reflaction.Person&quot;);    System.out.println(clazz3);</code></pre><p>(4)、方式四：通过类的加载ClassLoader来获取</p><pre><code>ClassLoader classLoader = ReflactionTest.class.getClassLoader();    Class&lt;Person&gt; clazz4 = (Class&lt;Person&gt;) classLoader.loadClass(&quot;Reflaction.Person&quot;);    System.out.println(clazz4);</code></pre><h3 id="4、一点点关于数组的小思考"><a href="#4、一点点关于数组的小思考" class="headerlink" title="4、一点点关于数组的小思考"></a>4、一点点关于数组的小思考</h3><pre><code>int[] a = new int[10];int[] b = new int[100];Class a10 = a.getClass();Class b100 = b.getClass();System.out.println(a10 == b100);</code></pre><p>结果为：<strong>true</strong><br>原因是：只要数组的元素类型和维度(一维数组、二维数组这样的)一样，它们为同一个Class<br></font></p><hr><h3 id="以下为Person类的附录："><a href="#以下为Person类的附录：" class="headerlink" title="以下为Person类的附录："></a>以下为Person类的附录：</h3><pre><code>package Reflaction;/** * @author BunnyAndOak0 * */public class Person {        private String name;        public int age;        public String getName() {            return name;        }        public void setName(String name) {            this.name = name;        }        public int getAge() {            return age;        }        public void setAge(int age) {            this.age = age;        }        public Person() {            super();            // TODO Auto-generated constructor stub        }        private Person(String name) {            super();            this.name = name;        }        public Person(String name, int age) {            super();            this.name = name;            this.age = age;        }        @Override        public String toString() {            return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;        }        public void show() {            System.out.println(&quot;我是一个人！&quot;);        }        private String showNation(String nation) {            System.out.println(&quot;我的国籍是：&quot; + nation);            return nation;        }}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2020/05/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <url>/2020/05/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="想写一点关于博客语法的东西"><a href="#想写一点关于博客语法的东西" class="headerlink" title="想写一点关于博客语法的东西"></a>想写一点关于博客语法的东西</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/05/07/hello-world/"/>
    <url>/2020/05/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
