<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PLSQL编程语言</title>
    <link href="/2020/06/16/PLSQL%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    <url>/2020/06/16/PLSQL%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 align=center>PL/SQL编程语言</h1><h2 id="SQL的语法变量"><a href="#SQL的语法变量" class="headerlink" title="SQL的语法变量"></a>SQL的语法变量</h2><p>plsql定义：在数据库服务器上保存的大段的可执行方法，供其他的开发人员进行调用</p><p>语法：</p><pre><code class="hljs java">[declare] --定义部分：变量，引用变量，记录型变量，异常    begin<span class="hljs-comment">//必须写</span> [exception]  --需要捕获异常时写上    end<span class="hljs-comment">//必须写</span></code></pre><p>例如：</p><p>定义一个number变量，定义PI常量，定义记录型变量，定义应用型变量</p><p>（没有++、——这样的写法）</p><pre><code class="hljs java">declare    i number := <span class="hljs-number">1</span>;<span class="hljs-comment">//:=进行赋值（定义变量）</span>PI constant number := <span class="hljs-number">3.14</span>;<span class="hljs-comment">//constant表示常量（定义常量）</span>pemp emp%rowtype;<span class="hljs-comment">//定义一个记录型变量</span>pname emp.ename%type;<span class="hljs-comment">//引用型变量</span> <span class="hljs-function">pjob <span class="hljs-title">VARCHAR2</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;begin    DBMS_OUTPUT.PUT_LINE(i);DBMS_OUTPUT.PUT_LINE(PI);SELECT * INTO pemp FROM emp WHERE empno = <span class="hljs-number">7499</span>;  DBMS_OUTPUT.PUT_LINE(<span class="hljs-string">'员工编号：'</span> || pemp.empno || <span class="hljs-string">',     员工姓名：'</span> || pemp.ename);SELECT ename INTO pname FROM emp WHERE empno = <span class="hljs-number">7499</span>;  DBMS_OUTPUT.PUT_LINE(pname);SELECT job INTO pjob FROM emp WHERE empno = <span class="hljs-number">7499</span>;  DBMS_OUTPUT.PUT_LINE(pjob);end;</code></pre><pre><code class="hljs java"><span class="hljs-number">2</span><span class="hljs-number">3.14</span>员工编号：<span class="hljs-number">7499</span>, 员工姓名：ALLENALLENSALESMAN</code></pre><h2 id="if分支"><a href="#if分支" class="headerlink" title="if分支"></a>if分支</h2><pre><code class="hljs java"><span class="hljs-comment">//if判断分支语句</span>begin     <span class="hljs-keyword">if</span> 判断语句 then    elsif 判断语句 then<span class="hljs-comment">//注意是“elsif”</span>    <span class="hljs-keyword">else</span>    end <span class="hljs-keyword">if</span>;end;</code></pre><p>例如：</p><p>从控制台出入一个数字。如果是1，就输出我是1</p><p>(PLSQL中没有==，等于是“:=”)</p><pre><code class="hljs java">DECLARE   age NUMBER := &amp;age;BEGIN  IF age = <span class="hljs-number">1</span> then    DBMS_OUTPUT.PUT_LINE(<span class="hljs-string">'我是'</span> || age);  ELSE    DBMS_OUTPUT.PUT_LINE(<span class="hljs-string">'我不是1'</span>);  END IF;END;</code></pre><pre><code class="hljs java">我是<span class="hljs-number">1</span>      <span class="hljs-comment">//   我是不是1</span></code></pre><p>如果输出的年龄在18岁一下，输出未成年人，18~40，成年人；40以上，老年人</p><pre><code class="hljs java">DECLARE  age NUMBER := &amp;age;BEGIN  IF age &lt; <span class="hljs-number">18</span> THEN    DBMS_OUTPUT.PUT_LINE(<span class="hljs-string">'未成年人'</span>);  ELSIF age &gt;= <span class="hljs-number">18</span> AND age &lt; <span class="hljs-number">40</span> THEN    DBMS_OUTPUT.PUT_LINE(<span class="hljs-string">'成年人'</span>);  ELSE    DBMS_OUTPUT.PUT_LINE(<span class="hljs-string">'老年人'</span>);  END IF;END;</code></pre><pre><code class="hljs java">未成年人 | 成年人 | 老年人</code></pre><h2 id="loop循环"><a href="#loop循环" class="headerlink" title="loop循环"></a>loop循环</h2><p>相当于for循环</p><p>语法一：</p><pre><code class="hljs java">begin:<span class="hljs-keyword">while</span> 循环条件 loop    end loop;end;</code></pre><p>语法二：（常用）</p><pre><code class="hljs java">begin    loop    exit when 退出条件    end loop;end;</code></pre><p>语法三：</p><pre><code class="hljs java">begin    <span class="hljs-keyword">for</span> i in <span class="hljs-number">1</span>..<span class="hljs-number">10</span> loop    end loop;end;</code></pre><p>例如：</p><p>语法一：在控制台输出1-10：</p><pre><code class="hljs java">DECLARE   i NUMBER := <span class="hljs-number">1</span>;BEGIN  WHILE i &lt;= <span class="hljs-number">10</span> LOOP    DBMS_OUTPUT.PUT_LINE(i);    i := i + <span class="hljs-number">1</span>;  END LOOP;END;</code></pre><pre><code class="hljs java"><span class="hljs-number">1</span><span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-number">4</span><span class="hljs-number">5</span><span class="hljs-number">6</span><span class="hljs-number">7</span><span class="hljs-number">8</span><span class="hljs-number">9</span><span class="hljs-number">10</span></code></pre><p>语法二：在控制台输出1-10：</p><pre><code class="hljs java">DECLARE  i NUMBER := <span class="hljs-number">1</span>;BEGIN  LOOP    EXIT WHEN i &gt; <span class="hljs-number">10</span>;      DBMS_OUTPUT.PUT_LINE(i);      i := i + <span class="hljs-number">1</span>;  END LOOP;END;</code></pre><p>语法三：在控制台输出1-10：</p><pre><code class="hljs JAVA">BEGIN  FOR i IN <span class="hljs-number">1</span>..<span class="hljs-number">10</span> LOOP<span class="hljs-comment">//for中已经定义</span>    DBMS_OUTPUT.PUT_LINE(i);  END LOOP;END;</code></pre><h2 id="SQL游标（Cursor）"><a href="#SQL游标（Cursor）" class="headerlink" title="SQL游标（Cursor）"></a>SQL游标（Cursor）</h2><p>在PL/SQL中，会用到多条数据，这时就需要用到游标，游标可以存储查询返回的多条数据</p><p>语法：</p><p>CURSOR  游标名 [(参数名  数据类型， 参数名  数据类型, …)]  IS  SELECT   语句;</p><p>例如：</p><pre><code class="hljs java">CURSOR c1 IS SELECT ename FROM emp;</code></pre><p>游标的使用步骤：</p><ol><li><p>打开游标：open c1;（打开游标执行查询）</p></li><li><p>取一行游标的值：fetch c1 into pjob;   (取一行到变量中)</p></li><li><p>关闭游标：close  c1;  （关闭游标释放资源）</p></li><li><p>游标的结束方式：exit when c1%notfound</p><p>（上面的pjob必须和emp中的job类型一致）</p></li></ol><p>例如：</p><p>使用游标方式，输出emp表中的员工编号和姓名</p><pre><code class="hljs java">DECLARE  pemp emp%rowtype;<span class="hljs-comment">//定义游标</span>  CURSOR c1 IS<span class="hljs-comment">//定义记录型的变量</span>    SELECT * FROM emp;BEGIN  OPEN C1;<span class="hljs-comment">//打开游标</span>  LOOP    FETCH c1      INTO pemp;<span class="hljs-comment">//从游标中取值，取完值后会自动向下移动一步</span>    EXIT WHEN c1%notfound;    DBMS_OUTPUT.PUT_LINE(<span class="hljs-string">'编号为'</span> || pemp.empno || <span class="hljs-string">', 名字为：'</span> || pemp.ename);  END LOOP;  CLOSE C1;<span class="hljs-comment">//关闭游标</span>END;</code></pre><pre><code class="hljs java">员工编号为：<span class="hljs-number">7369</span>, 员工姓名为：SMITH员工编号为：<span class="hljs-number">7499</span>, 员工姓名为：ALLEN员工编号为：<span class="hljs-number">7521</span>, 员工姓名为：WARD员工编号为：<span class="hljs-number">7566</span>, 员工姓名为：JONES员工编号为：<span class="hljs-number">7654</span>, 员工姓名为：MARTIN    ......</code></pre><p>例如：</p><p>按照员工的工种涨工资，总裁1000元，经理800元，其他人员长400元</p><pre><code class="hljs java">DECLARE  pemp emp%rowtype;  addsal NUMBER;  CURSOR c1 IS           SELECT * FROM myemp;BEGIN  OPEN c1;  LOOP    EXIT WHEN c1%notfound;    FETCH c1 INTO pemp;    IF pemp.JOB = <span class="hljs-string">'PRESIDENT'</span> THEN      addsal := <span class="hljs-number">1000</span>;    ELSIF pemp.JOB = <span class="hljs-string">'MANAGER'</span> THEN      addsal := <span class="hljs-number">800</span>;    ELSE      addsal := <span class="hljs-number">400</span>;    END IF;    UPDATE myemp SET SAL = SAL + addsal WHERE empno = pemp.empno;  END LOOP;  COMMIT;  CLOSE c1;END;</code></pre><p>为部门是10的员工涨工资</p><pre><code class="hljs java">DECLARE    <span class="hljs-comment">//带了参数的游标</span>   <span class="hljs-function">CURSOR <span class="hljs-title">c1</span><span class="hljs-params">(dno myemp.deptno%type)</span> IS SELECT * FROM myemp WHERE deptno </span>= dno;   adddeptno myemp%rowtype;BEGIN    <span class="hljs-comment">//除了此处其他的地方的游标不需要带参数</span>   <span class="hljs-function">OPEN <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;   LOOP      EXIT WHEN c1%notfound;     FETCH c1 INTO adddeptno;     UPDATE myemp SET SAL = SAL + <span class="hljs-number">1000</span> WHERE deptno = adddeptno.deptno;   END LOOP;   COMMIT;   CLOSE c1;END;</code></pre><h2 id="异常（例外）"><a href="#异常（例外）" class="headerlink" title="异常（例外）"></a>异常（例外）</h2><p>系统定义异常</p><p>no_data_found（没有找到数据）</p><p>too_many_rows（select…into语句匹配多个行）</p><p>zero_divide（被零除）</p><p>value_error（算术或转换错误）</p><p>timeout_on_resource（在等待资源时发生超时）</p><p>others（是最大的异常）</p><p>例如：</p><p>写出被0除的异常</p><pre><code class="hljs java">DECLARE  i NUMBER := <span class="hljs-number">1</span>;BEGIN  i := i / <span class="hljs-number">0</span>;  EXCEPTION     WHEN zero_divide THEN      DBMS_OUTPUT.PUT_LINE(<span class="hljs-string">'分母不能为0'</span>);END;</code></pre><p>写了exception就一定需要写点什么</p><p> 设置错误的value_error异常</p><pre><code class="hljs java">DECLARE      page NUMBER;BEGIN  page := <span class="hljs-string">'test'</span>;  EXCEPTION      WHEN value_error THEN        DBMS_OUTPUT.PUT_LINE(<span class="hljs-string">'算数或转换出错'</span>);END;</code></pre><p>都可以通过others捕获</p><p>自定义异常</p><p>查询部门编号为40员工（自定义exception）</p><pre><code class="hljs java">DECLARE       no_data EXCEPTION;       CURSOR emp_cur IS SELECT * FROM emp WHERE empno = <span class="hljs-number">0</span>;       pemp emp%rowtype;BEGIN  OPEN emp_cur;  FETCH emp_cur INTO pemp;  IF emp_cur%notfound THEN     RAISE no_data;  END IF;  EXCEPTION     WHEN no_data THEN    DBMS_OUTPUT.PUT_LINE(<span class="hljs-string">'抛出没有数据的自定义异常！'</span>);END;</code></pre><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>是在大型数据库中，为了完成特定的功能的SQL语句集。</p><p>语法：</p><pre><code class="hljs java">CREATE [or replace] procedure 过程名(参数名字 in | out 类型)    AS<span class="hljs-comment">//可以加定义</span>BEGINEND;</code></pre><p>例如：</p><p>声明pro_add_sal存储的过程，作用是给指定的员工涨1000工资，并打印出涨前和涨后的工资</p><pre><code class="hljs java"><span class="hljs-function">CREATE OR REPLACE PROCEDURE <span class="hljs-title">pro_add_sal</span> <span class="hljs-params">(pno in NUMBER)</span></span><span class="hljs-function">AS </span><span class="hljs-function">       psal NUMBER</span>;BEGIN  SELECT sal INTO psal FROM myemp WHERE empno = pno;  DBMS_OUTPUT.PUT_LINE(psal);  UPDATE myemp SET sal = sal + <span class="hljs-number">1000</span> WHERE empno = pno;  DBMS_OUTPUT.PUT_LINE(psal + <span class="hljs-number">1000</span>);  COMMIT;<span class="hljs-comment">//进行提交</span>END;BEGIN  pro_add_sal(<span class="hljs-number">7499</span>);END;</code></pre><h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><p>定义：保存一段可执行的sql语句，方便开发调用过程名</p><p>语法：</p><pre><code class="hljs java">CREATE [OR REPLACE] FUNCTION 方法名 (参数名 in | out 类型) RETURN 参数类型<span class="hljs-comment">//in的类型可以忽略不写 out必须要写 也可以写引用型类型</span>AS    定义变量名 类型要和RETURN返回类型一致BEGIN    RETURN 变量名<span class="hljs-comment">//必须和前面return的类型一致</span>END;</code></pre><p>例如：</p><p>声明pro_emp_totalsal存储过程，查询指定员工的年薪</p><pre><code class="hljs java"><span class="hljs-function">CREATE OR REPLACE PROCEDURE <span class="hljs-title">emp_totalsal</span><span class="hljs-params">(pno in number, psal OUT NUMBER)</span></span><span class="hljs-function">AS</span><span class="hljs-function">BEGIN</span><span class="hljs-function">  <span class="hljs-title">SELECT</span> <span class="hljs-params">(sal*<span class="hljs-number">12</span>)</span>+<span class="hljs-title">nvl</span><span class="hljs-params">(COMM, <span class="hljs-number">0</span>)</span> INTO psal FROM myemp WHERE empno </span>= pno;END;DECLARE  sal NUMBER;BEGINemp_totalsal(<span class="hljs-number">7499</span>, sal);DBMS_OUTPUT.PUT_LINE(sal);END;</code></pre><p>声明func_emp_totalsal存储函数，查询指定员工的年薪</p><pre><code class="hljs java"><span class="hljs-function">CREATE OR REPLACE FUNCTION <span class="hljs-title">func_emp_totalsal</span><span class="hljs-params">(pno in NUMBER)</span> RETURN NUMBER</span><span class="hljs-function">AS</span><span class="hljs-function">  psal NUMBER</span>;BEGIN  SELECT (sal*<span class="hljs-number">12</span>)+nvl(COMM, <span class="hljs-number">0</span>) INTO psal FROM myemp WHERE empno = pno;  DBMS_OUTPUT.PUT_LINE(psal);  RETURN psal;END;DECLARE   sal NUMBER;BEGIN  sal := func_emp_totalsal(<span class="hljs-number">7369</span>);  DBMS_OUTPUT.PUT_LINE(sal);END;</code></pre><p>在select调用存储函数</p><pre><code class="hljs java">SELECT ename, func_emp_dname(deptno) FROM emp;</code></pre><p>存储过程和存储函数的区别：</p><ol><li>定义的语法不一样procedure，function</li><li>function有返回值</li><li>function可以在select中进行调用</li><li>存储过程可以通过out类型来返回参数</li></ol><p>java中调用存储函数、存储过程</p><p>调用存储函数</p><p>存储函数：</p><pre><code class="hljs java">--声明func_emp_totalsal存储函数，查询指定员工的年薪<span class="hljs-function">CREATE OR REPLACE FUNCTION <span class="hljs-title">func_emp_totalsal</span><span class="hljs-params">(pno in NUMBER)</span> RETURN NUMBER</span><span class="hljs-function">AS</span><span class="hljs-function">  psal NUMBER</span>;BEGIN  SELECT (sal*<span class="hljs-number">12</span>)+nvl(COMM, <span class="hljs-number">0</span>) INTO psal FROM myemp WHERE empno = pno;  DBMS_OUTPUT.PUT_LINE(psal);  RETURN psal;END;</code></pre><p>调用：</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">testFunctinnEmpTotalsal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException</span>&#123;call = connection.prepareCall(<span class="hljs-string">"&#123;? = call func_emp_totalsal(?)&#125;"</span>);<span class="hljs-comment">//注意&#123;&#125;</span>call.registerOutParameter(<span class="hljs-number">1</span>, OracleTypes.NUMBER);call.setInt(<span class="hljs-number">2</span>, <span class="hljs-number">7499</span>);call.execute();<span class="hljs-keyword">int</span> totalsal = call.getInt(<span class="hljs-number">1</span>);System.out.println(totalsal);&#125;</code></pre><p>调用存储过程</p><p>存储过程：</p><pre><code class="hljs java">---声明pro_add_sal存储的过程，作用是给指定的员工涨<span class="hljs-number">1000</span>工资，并打印出涨前和涨后的工资<span class="hljs-function">CREATE OR REPLACE PROCEDURE <span class="hljs-title">pro_add_sal</span> <span class="hljs-params">(pno in NUMBER)</span></span><span class="hljs-function">AS </span><span class="hljs-function">       psal NUMBER</span>;BEGIN  SELECT sal INTO psal FROM myemp WHERE empno = pno;  DBMS_OUTPUT.PUT_LINE(psal);  UPDATE myemp SET sal = sal + <span class="hljs-number">1000</span> WHERE empno = pno;  DBMS_OUTPUT.PUT_LINE(psal + <span class="hljs-number">1000</span>);END;</code></pre><p>调用：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCallProceduraAddSal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException</span>&#123;call = connection.prepareCall(<span class="hljs-string">"call pro_add_sal(?)"</span>);call.setInt(<span class="hljs-string">"pno"</span>, <span class="hljs-number">7499</span>);call.execute();&#125;</code></pre><h2 id="SQL触发器"><a href="#SQL触发器" class="headerlink" title="SQL触发器"></a>SQL触发器</h2><p>​        满足一定设定的触发条件，立即执行</p><p>语法：</p><pre><code class="hljs java">CREATE [OR REPLACE] TRIGGER 触发器名BEFORE | AFTERINSERT | UPDATE | DELETEON 表名FOR EACH ROW    --:<span class="hljs-keyword">new</span>, :old<span class="hljs-comment">//表示指向新值或者旧值  for each row是行级触发器</span>BEGINEND;</code></pre><p>例如：</p><p>触发器应用</p><pre><code class="hljs java">CREATE OR REPLACE TRIGGER tri_emp_insertBEFOREINSERTON myempFOR EACH ROWBEGIN  SELECT myseq1.nextval INTO :<span class="hljs-keyword">new</span>.empno FROM dual;END;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git</title>
    <link href="/2020/06/15/git/"/>
    <url>/2020/06/15/git/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>Git</font></div><h2 id="Git和Svn对比"><a href="#Git和Svn对比" class="headerlink" title="Git和Svn对比"></a>Git和Svn对比</h2><p>Svn：</p><p>集中式管理，可以轻松掌握每个人开发权限</p><p>缺点：</p><ol><li>服务器单点故障</li><li>容错性差</li></ol><p>Git：</p><p>分布式版本控制系统，没有中央服务器，个人拥有本地仓库</p><p>流程图：</p><p><img src="https://github.com/BunnyAndOak0/IMG/blob/master/images/git.png" srcset="/img/loading.gif" alt=""></p><p>Workspace：工作区<br> Index / Stage：暂存区<br> Repository：仓库区（或本地仓库）<br> Remote：远程仓库</p><h2 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h2><pre><code class="hljs java">$git init;</code></pre><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>必须要在工作目录中，也就是带有.git的那个文件夹</p><pre><code class="hljs java">git add XXX<span class="hljs-comment">//加入到暂存区中</span></code></pre><p>提交到仓库</p><pre><code class="hljs java">git commit -m <span class="hljs-string">"XXX"</span><span class="hljs-comment">//可写提交注释</span></code></pre><p>查看是否还有文件未提交</p><pre><code class="hljs java">git status<span class="hljs-comment">//如果文件被修改 但是没有提交会显示红色的字以及modified</span></code></pre><p>查看文件修改了什么内容</p><pre><code class="hljs java">git diff XXX<span class="hljs-comment">//跟上文件名</span></code></pre><h2 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h2><p>查看历史记录</p><pre><code class="hljs java">git log<span class="hljs-comment">//可以查看每次提交的版本号 以及日志  从远到近</span>git log –pretty=oneline<span class="hljs-comment">//信息显示的少一点</span></code></pre><p>版本回退</p><pre><code class="hljs java">git reset --hard HEAD^<span class="hljs-comment">//回退至上一个版本</span>git reset --hard HEAD^^<span class="hljs-comment">//回退至上上个版本，以此类推 </span>git reset --hard HEAD~<span class="hljs-number">100</span><span class="hljs-comment">//回退至前100个版本</span></code></pre><p>获取回退之前的版本号</p><pre><code class="hljs java">git reflog git reset --hard 版本号<span class="hljs-comment">//回退至相应版本</span></code></pre><p>查看内容</p><pre><code class="hljs java">cat XXX<span class="hljs-comment">//跟上文件名</span></code></pre><h2 id="工作区和暂存区的区别"><a href="#工作区和暂存区的区别" class="headerlink" title="工作区和暂存区的区别"></a>工作区和暂存区的区别</h2><p>工作区：就是你在电脑上看到的目录(.git隐藏目录版本库除外)</p><p>版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。</p><h2 id="撤销修改和删除文件操作"><a href="#撤销修改和删除文件操作" class="headerlink" title="撤销修改和删除文件操作"></a>撤销修改和删除文件操作</h2><p>撤销修改</p><ol><li><p>如果知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。</p></li><li><p>可以按以前的方法直接恢复到上一个版本。使用 git reset –hard HEAD^</p></li><li><pre><code class="hljs java">git checkout -- XXX<span class="hljs-comment">//把XXX文件在工作区做的修改全部撤销</span>git restore XXX    <span class="hljs-comment">//也可以撤销</span></code></pre><p><strong>命令git checkout – readme.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了</strong>。</p></li></ol><p>   分两种情况：</p><ol><li>还没有放到暂存区，撤销之后就回到和版本库一摸一样的状态</li><li>已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。</li></ol><p>删除文件</p><p>可以直接在文件目录中删除，也可以使用命令：</p><pre><code class="hljs java">rm XXX<span class="hljs-comment">//删除XXX文件</span></code></pre><p>如果想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉</p><p>没有commit之前，恢复此文件的操作</p><pre><code class="hljs java">git checkout -- XXX<span class="hljs-comment">//恢复XXX文件</span>git restore XXX<span class="hljs-comment">//也可以进行恢复</span></code></pre><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>注册github账号，创建SSH Key</p><p>如果现在已经有一个本地的Git仓库，又建立了一个github的git仓库，想要这两个仓库进行同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。</p><p>把一个已有的本地仓库与之关联</p><pre><code class="hljs java">git remote add origin https:<span class="hljs-comment">//github.com/XXXX    //添上仓库的地址</span></code></pre><p>把本地库的内容推送到远程</p><pre><code class="hljs java">git push -u origin master<span class="hljs-comment">//把当前分支master推送到远程</span></code></pre><p>​        第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>之后，如果本地还需要提交只需要</p><pre><code class="hljs java">git push origin master<span class="hljs-comment">//把本地master分支的最新修改推送到github上</span></code></pre><p>从远程库克隆</p><pre><code class="hljs java">git clone https:<span class="hljs-comment">//github.com/XXXX//加上要克隆仓库的github地址</span></code></pre><h2 id="创建合并分支"><a href="#创建合并分支" class="headerlink" title="创建合并分支"></a>创建合并分支</h2><p>​        在 版本回填退里，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p><p>切换、创建dev分支</p><pre><code class="hljs java">git checkout -b dev<span class="hljs-comment">//命令加上–b参数表示创建并切换</span>git branch dev<span class="hljs-comment">//查看当前的分支  当前分支前面会添加一个星号</span>git branch<span class="hljs-comment">//查看所有的分支 当前分支前面会添加一个星号</span>git checkout master<span class="hljs-comment">//切换分支</span></code></pre><p>在分支上添加的内容，切换到master分支，就会不在了，因为不是同一个分支</p><p>可以把dev分支上的内容合并到分支master上，在master分支上使用：</p><p>合并分支：</p><pre><code class="hljs java">git merge 分支名<span class="hljs-comment">//合并指定分支到当前分支上</span></code></pre><p>删除分支</p><pre><code class="hljs java">git branch –d 分支名字<span class="hljs-comment">//分支的删除</span></code></pre><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在使用带参数 –no-ff来禁用”Fast forward”模式。</p><pre><code class="hljs java">git merge –no-ff -m “注释” dev<span class="hljs-comment">//合并dev分支，-no-ff表示禁用fast forward</span></code></pre><p>即使这个时候分支被删除，依然还会有版本号，以及被删除分支的信息还在</p><h2 id="分支Bug"><a href="#分支Bug" class="headerlink" title="分支Bug"></a>分支Bug</h2><p>在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p><p>Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。</p><pre><code class="hljs java">git stash将当前的工作现场隐藏起来</code></pre><p>之后在主分支master上创建一个临时分支，修复完内容后，切换到master分支，完成合并，再删除掉临时分支即可。</p><p>查看工作现场</p><pre><code class="hljs java">git stash list</code></pre><p>恢复工作现场</p><ol><li>方法一：</li></ol><pre><code class="hljs java">git stash apply<span class="hljs-comment">//恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。</span></code></pre><ol start="2"><li>方法二：</li></ol><pre><code class="hljs java">git stash pop<span class="hljs-comment">//恢复的同时把stash内容也删除了。</span></code></pre><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>当从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。</p><p>查看远程库的信息</p><pre><code class="hljs java">git remote</code></pre><p>查看远程库的详细信息</p><pre><code class="hljs java">git remote –v</code></pre><p>推送分支</p><p>​        推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><pre><code class="hljs java">git push origin master</code></pre><p>如果要推送到其他分支，比如dev分支上，还是那个命令 git push origin dev</p><p>​        而一般情况下，master分支是主分支，因此要时刻与远程同步。一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。</p><p>抓取分支</p><p>​        如果要在dev分支上做开发，就必须创建远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：</p><p>先克隆远程的库到本地d</p><pre><code class="hljs java">git clone XXX<span class="hljs-comment">//克隆库</span>git checkout –b dev origin/dev<span class="hljs-comment">//创建远程origin的dev分支到本地中</span>git push origin dev<span class="hljs-comment">//修改完成后把现在的dev分支推送到远程</span></code></pre><p>但是此时，如果不同的人推送同样的文件，修改同一个文件的同一个地方，则会报错，解决的办法也很简单：先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。</p><hr><p><a href="https://blog.csdn.net/u011535541/article/details/83379151" target="_blank" rel="noopener">参考文档</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Oracle</title>
    <link href="/2020/06/15/Oracle/"/>
    <url>/2020/06/15/Oracle/</url>
    
    <content type="html"><![CDATA[<h1 align=center> Oracle</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>​        Oracle服务中，有两个服务是非常重要的：</p><ol><li>数据库的实例服务：如果创建了多个数据库，就会有多个数据库实力服务，命名模式为：“OracleServiceSID”</li><li>数据库监听服务“OracleOraDb11g_home1TNSListener”，如果要通过程序访问数据库，就必须开启此服务，否则无法连接。</li></ol><p>Oracle的卸载：</p><ol><li>执行Oracle提供的卸载程序</li><li>进入到注册表，而后删除掉与Oracle有关的配置项</li><li>重新启动电脑，并且进入到安全模式，删除掉所有的Oracle的配置文件</li></ol><h2 id="SQLPlus基础命令"><a href="#SQLPlus基础命令" class="headerlink" title="SQLPlus基础命令"></a>SQLPlus基础命令</h2><p>进行数据库的使用（Windows + r）：</p><p>登录：输入用户、密码</p><ol><li><p>查看当前登录用户</p><pre><code class="hljs java">show user;</code></pre></li><li><p>切换使用的用户</p><pre><code class="hljs java">conn 用户名 [/ 密码][as sysdba];<span class="hljs-comment">//如果用超级管理员登录就必须追加“as sysdba”</span></code></pre></li></ol><p>设置显示格式：</p><ol><li><p>设置每行显示的数据长度</p><pre><code class="hljs java">set linesize 长度;</code></pre></li><li><p>设置每页显示的数据长度</p><pre><code class="hljs java">set pagesize 长度;</code></pre></li><li><p>清屏</p><pre><code class="hljs java">clear scr;</code></pre></li></ol><p>调用自己的文本编辑器</p><p>（windows下用notepad、linux下用vi）</p><p>启动本地的文本编辑工具</p><pre><code class="hljs java">edit my;<span class="hljs-comment">//此时会在用户所在的目录中创建一个名为my.sql的文件</span></code></pre><p>执行程序</p><pre><code class="hljs java"><span class="hljs-meta">@my</span><span class="hljs-comment">//执行的是默认路径中的my.sql的文件</span></code></pre><p>如果现在需要执行的sql文件已经存在于磁盘上了，就可以使用完整路径进行执行，例如：</p><pre><code class="hljs java"><span class="hljs-meta">@d</span>:\mldn<span class="hljs-comment">//如果不加后缀，那么默认就是“*.sql”</span></code></pre><p>调用本机的操作系统程序</p><pre><code class="hljs java">host 系统命令<span class="hljs-comment">//例如  windows下的拷贝命令</span> host copy d:\mldn.sql d:\a.sql</code></pre><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>SQL标准语法中，将SQL分为了三种：</p><ul><li>DML（数据操作语言）：指的是数据库的具体操作，具体操作只有四个形式，insert、delete、update、select，其中最麻烦的是查询操作（直接影响程序的性能）</li><li>DDL（数据定义语言）：定义数据库对象、定义数据表、用户、</li><li>DCL（数据控制语言）：用户的授权管理操作</li></ul><h2 id="Scott用户数据表"><a href="#Scott用户数据表" class="headerlink" title="Scott用户数据表"></a>Scott用户数据表</h2><p>查看数据库中所有表名称</p><pre><code class="hljs java">select * from tab;</code></pre><h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h2><p>使用SQL-DML语法操作</p><p>语法：</p><pre><code class="hljs java">select * |具体的列名 [as] [别名] from 表名称;</code></pre><p>起别名</p><pre><code class="hljs java">select empno 编号,ename 姓名,job 工作 from emp;--省略as关键字的写法</code></pre><pre><code class="hljs java">select empno as 编号,ename as 姓名,job as 做工 from emp; --保留as关键字的写法</code></pre><p>消除重复值</p><pre><code class="hljs java">select distinct *|具体的列名 别名 from 表名称;</code></pre><h2 id="限定查询"><a href="#限定查询" class="headerlink" title="限定查询"></a>限定查询</h2><p>在Oracle数据库中，里面的内容是区分大小写的</p><p>使用WHERE子句</p><pre><code class="hljs java">select *|具体的列名 from 表名称 where 条件表达式;</code></pre><p>条件大于某个值：</p><pre><code class="hljs java">select * from emp where sal&gt;<span class="hljs-number">1500</span>;</code></pre><p>不为空</p><pre><code class="hljs java">select * from emp where comm is not <span class="hljs-keyword">null</span>;<span class="hljs-comment">//为空</span>select * from emp where comm is <span class="hljs-keyword">null</span>;</code></pre><p>采用and关键字将多个限定条件进行连接，表示所有的限定条件都需要满足</p><pre><code class="hljs java">select * from emp where sal&gt;<span class="hljs-number">1500</span> and comm is not <span class="hljs-keyword">null</span>;</code></pre><p>“或者”，所以在查询时，只需要满足两个条件中的一个就行</p><pre><code class="hljs java">select * from emp where sal&gt;<span class="hljs-number">1500</span> or comm is not <span class="hljs-keyword">null</span>;</code></pre><p>专门指定范围查询的过滤语句：between x and y，相当于a&gt;=x and a&lt;=y,也就是包含了等于的功能，日期也适用</p><pre><code class="hljs java">select * from emp where sal between <span class="hljs-number">1500</span> and <span class="hljs-number">3000</span>;</code></pre><p>模糊查询：Like</p><p>提供两个匹配符号：</p><ol><li><p>“_”：匹配任意的一位字符</p></li><li><p>“%”：表示匹配任意的0位，1位或者多位字符</p><p>例如：查询以A开头的员工：</p><pre><code class="hljs java">SELECT * FROM emp WHERE ename LIKE <span class="hljs-string">'A%'</span> ;</code></pre><p>查询雇员姓名中，第二个字母为A的</p><pre><code class="hljs java">SELECT * FROM emp WHERE ename LIKE <span class="hljs-string">'_A%'</span> ;</code></pre><ul><li>like运算的时候可以针对各种数据类型，例如：字符串、数字、日期</li><li>如果想要进行关键字的查询，前后可以使用“%关键字%”的形式完成</li><li>如果在进行关键字检索的时候，没有设置关键字内容，也就是设置的是’’（空字符串）,就表示查询全部（要比简单查询性能差很多）</li></ul></li></ol><p>IN、NOT  IN范围查询</p><p>通过给定的种子数，筛选出符合这些数据的内容</p><p>例如：</p><p>查询出雇员编号为：7369、7566、7788、9999的雇员信息</p><pre><code class="hljs java">SELECT * FROM emp<span class="hljs-function">WHERE empno <span class="hljs-title">IN</span> <span class="hljs-params">(<span class="hljs-number">7369</span>,<span class="hljs-number">7566</span>,<span class="hljs-number">7839</span>,<span class="hljs-number">9999</span>)</span> </span>;</code></pre><p>由于没有9999的雇员，所以只会返回三行数据</p><p>也可以使用NOT  IN表示不在范围之中。</p><p>注意点：</p><p>使用where查询的主要目的是只显示部分数据行的数据信息，在NOT  IN处理的过程中，如果种子数中，出现有任何的空（null），就不会有任何的结果返回。</p><h2 id="查询排序"><a href="#查询排序" class="headerlink" title="查询排序"></a>查询排序</h2><p>使用ORDER BY子句，进行一些特殊子段的排序</p><p>语法：</p><pre><code class="hljs java">③SELECT [DISTINCT] * | 列名称 [别名] , 列名称 [别名] ,... | 数据计算①FROM 数据表 [别名] ②[WHERE 限定条件(s)]④[ORDER BY 排序字段 [ASC | DESC],排序字段 [ASC | DESC],.....];</code></pre><p>​        SELECT 子句是在WHERE子句之后执行的，所以WHERE子句中，无法使用SELECT子句定义的别名，Order by是所有子句中最后一个执行，所以可以使用SELECT中的别名。</p><p>两种排序模式：</p><ol><li>ASC：升序，默认为此模式</li><li>DESC：降序</li></ol><p>例如：</p><p>查询所有雇员的信息要求雇员的工资有低到高排序</p><pre><code class="hljs java">SELECT * FROM emp ORDER BY sal ;<span class="hljs-comment">//降序</span>SELECT * FROM emp ORDER BY sal DESC ;</code></pre><p>查询所有雇员的信息，要求工资由高到低排序，如果工资相同就按照雇佣日期由早到晚排序</p><pre><code class="hljs java">SELECT * FROM emp ORDER BY sal DESC , hiredate ASC ;</code></pre><p>ORDER BY永远都在最后处理，也就是说排序是在所有数据都筛选完成之后，才进行数据处理。</p><h2 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h2><p>大多数关系型数据库的区别：</p><ol><li>数据的存储区别，拥有不同的存储方案</li><li>支持的数据类型是不同的的</li><li>有不同的支持函数</li></ol><p>​        oracle针对于系统函数的定义的基本格式：返回数据类型 函数名称（数据  | 列名称），而返回的数据类型基本上只有三类：字符串（VARCHAR2），数字（NUMBER），日期（DATE）</p><p>​        单行函数分为：字符串函数、数值函数、日期函数（避免闰年问题）、转换函数、通用函数。</p><p>字符串函数</p><ol><li>进行字符串的处理<ul><li>转大写函数 字符串UPPER（数据 |列）；</li><li>转消谐函数 字符串LOWER（数据 | 列）；</li><li>首字母大写 字符串INITCAP（数据 | 列）；</li><li>计算字符串长度 数字 LENGTH （数据 | 列）；</li><li>字符串截取：字符串 SUBSTR（数据 | 列， 截取点[，长度]）；<ul><li>由指定索引（Oracle中的字符串索引开始的值为1，如果设置为0，则与1相同，也就是所效果与1相同），到结尾</li><li>设置指定索引和截取长度</li><li>也可以将索引数设置为复数，表示由结尾开始的指定索引截取（可以渐变的进行从后往前的计算长度）</li></ul></li><li>字符串替换 字符串 REPLACE（要替换的数据 | 列，要替换的数据， 替换的数据）；</li></ul></li></ol><p>数值函数</p><p>数值函数主要作用是进行一些数字的操作，三种常见数值操作的函数：</p><ol><li>ROUND（数据 | 列[，保留小数位]）：四舍五入的处理；</li><li>TRUNC（数据 | 列[，保留小数位]）：数据截取（不进位）；</li><li>MOD（数据 | 列， 数据 | 列）：求余数。</li></ol><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p> 也就是说，FROM之后可以设置多张表，多表查询的参考语法：</p><p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5.PNG" srcset="/img/loading.gif" alt=""></p><p>相关概念</p><p>结论：在实际的开发中，慎用多表查询，根据数据量来决定。</p><p>多表查询中，积一直都在。</p><p>多表查询使用分析</p><p>对于多表查询，这些关联的数据表之间存在有一定关系（某个字段，某些条件）</p><ul><li><p>确定要使用的数据表</p></li><li><p>确定已知的关联字段：两张表用一个条件，三张表用两个条件，使用AND连接</p></li></ul><p>数据库中对于多表查询，实际上给出了两种表的连接</p><ul><li><p>内连接</p><p>等值连接，在之前进行判断的时候会使用一些条件（e.deptno = d.deptno），只有条件满足了才会显示相应的数据信息,不满足就不显示</p></li><li><p>外连接：一定要根据具体的查询要求来定义</p><p>数据表记录的全部显示，外连接分为：左外连接，右外连接，全外连接</p><ul><li>左外连接：条件上（字段 = 字段（+））：也就是说左表的数据要求全部显示</li><li>右外连接：条件上（字段（+） = 字段）：也就是说右表的数据要求全部显示</li><li>也可以进行自身关联</li></ul><p>但是外连接的相关操作，在整个实现过程中，使用了（+），如果更换到了其他的数据库，那么有可能就不支持此类查询，为了解决此问题，可以使用1999标准语法。</p><p>1999语法：</p><ul><li>交叉连接：CROSS  JOIN 就是简单地将数据表关联在一起，会产生笛卡尔积</li><li>自然连接：NATURAL   JOIN 内连接，自动找到同名字段，采用内连接的模式效出笛卡尔积</li><li>USING子句（与JOIN配合使用）：设置要进行关联的字段</li><li>ON子句（与JOIN配合使用）：设置关联条件</li><li>外连接（三类）：LEFT  OUTER  JOIN、 RIGHT  OUTER  JOIN、 FULL  OUTER  JOIN（可以与ON配合使用）</li></ul></li></ul><h2 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h2><p>  ​        对于查询结果而言，也可以进行集合的运算，要求查询返回的结构一定要相同</p><p>  语法：</p><p>  <img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E9%9B%86%E5%90%88%E7%9A%84%E5%A4%84%E7%90%86.PNG" srcset="/img/loading.gif" alt=""></p><ul><li><p>UNION运算：将集合的结果整合在一起使用，但是相同的部分<strong>不显示</strong></p></li><li><p>UNION   ALL运算：将集合的结果的整合在一起，<strong>显示</strong>相同的部分</p></li><li><p>MINUS运算：差集运算，需要看取值范围的大小使用</p></li><li><p>INTERSECT运算：返回两个查询中的相同部分</p><p>这些运算符都是以查询结果进行处理的，也就是说你可以执行多个不同的查询，再用以上的连接符将以上这些内容放到一起进行显示。</p></li></ul><h2 id="分组统计查询"><a href="#分组统计查询" class="headerlink" title="分组统计查询"></a>分组统计查询</h2><p>统计函数（分组函数、组函数）</p><p>常用：</p><p>COUNT()：可以 统计出数据表中数据行的个数，如果表中没有记录，count的统计结果为0，而不是空null</p><p>用法：COUNT(*)，COUNT(字段)，COUNT(DISTINCT    字段)</p><ol><li><p>如果现在某一个列上的数据没有null，那么使用COUNT(*)和COUNT(字段)结果，是相同的</p><p>但是如果某一个列上一旦出现有空null，则null在COUNT(字段)中是不统计的</p></li><li><p>如果某一个列上拥有重复数据，统计的时候不想出现重复，则使用DISTINCT完成处理</p><p>例如：COUNT(DISTINCT job)</p></li></ol><p>SUM()</p><p>AVG()</p><p>MIN()</p><p>MAX()</p><h2 id="分组统计"><a href="#分组统计" class="headerlink" title="分组统计"></a>分组统计</h2><p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1.PNG" srcset="/img/loading.gif" alt=""></p><ol><li><p>在编写查询语句的时候，如果没有编写GROUP BY子句，这个时候的SELECT 子句中只能够出现统计函数，表示对整表数据的进行性统计操作（可以理解为整表分为一组）。</p></li><li><p>在使用GROUP BY查询址中，SELECT子句里面只能出现分组字段和统计函数，其他的任何字段都不允许出现</p></li><li><p>在进行分组查询的时候，统计函数允许嵌套，但是此时 的SELECT子句之中，不能出现任何字段，包括分组字段</p></li></ol><h2 id="多表查询与分组统计"><a href="#多表查询与分组统计" class="headerlink" title="多表查询与分组统计"></a>多表查询与分组统计</h2><p>​        如果要想按照多个列分组，则要求，这多个列的内容一起重复着，这样的操作往往都要结合多表查询一起出现。</p><h2 id="HAVING子句"><a href="#HAVING子句" class="headerlink" title="HAVING子句"></a>HAVING子句</h2><p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/having%E9%A1%BA%E5%BA%8F.PNG" srcset="/img/loading.gif" alt=""></p><p>由于执行顺序的问题，用WHERE代替HAVING的时候，会出现逻辑上的问题。</p><p>HAVING与WHERE的区别：</p><p>WHERE：是在GROUP  BY分组前使用，表示对要分组的数据进行筛选定义，<strong>不允许</strong>使用统计函数。</p><p>HAVING：在GROUP  BY之后使用，<strong>允许</strong>使用统计函数，针对于分组后的数据进行筛选。</p><p>对于分组操作，不一定只有GROUP  BY可以解决，这些集合操作可以将多个查询结果整合在一起显示。</p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>​        指的是在一个完整查询的语句里面嵌入N个内部查询结果，子查询没有固定的语法，可以自己嵌套。</p><p>对于子查询而言，在哪个字句出现并没有一个明确的结果：</p><ul><li><strong>WHERE子句</strong>：当子句返回单行单列、多行单列、单行多列</li><li>HAVING子句：子查询返回单行单列，并且需要进行统计操作的时候</li><li><strong>FROM子句</strong>：子查询返回多行多列数据（表）可以在FROM子句中出现，按照表的形式处理</li><li>SELECT子句：子查询返回单行单列</li></ul><p>子查询主要是为了解决查询性能的问问题。</p><ol><li><p>WHERE子句的主要作用，是为了限制数据表中数据行的显示，所以一般都是作为筛选数据使用的。</p><ul><li>子查询返回单行单列</li></ul><p>例如：查询出工资高于平均工资的员工的所有信息</p><pre><code class="hljs java">SELECT * FROM empWHERE sal &gt; (<span class="hljs-function">SELECT <span class="hljs-title">AVG</span><span class="hljs-params">(sal)</span> FROM emp)</span>;</code></pre><ul><li>子查询返回单行多列</li></ul><p>指的是要求同时满足两个列的判断</p><pre><code class="hljs JAVA">SELECT * FROM emp WHERE (job, sal) = (SELECT job, sal FROM emp WHERE ename = <span class="hljs-string">'SCOTT'</span>)AND ename != <span class="hljs-string">'SCOTT'</span>;</code></pre><ul><li>子查询返回多行单列</li></ul><p>一旦子查询返回多行单列的数据，实际上所返回的内容就属于一个数据的范围了，对于范围的的查询在子查询之中定义有三种操作形式：</p><ol><li><p>IN</p><p>与之前的IN是相同的(NOT  IN  指的是不在范围之中)</p><pre><code class="hljs JAVA">SELECT * FROM emp<span class="hljs-function">WHERE sal <span class="hljs-title">IN</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">SELECT sal FROM emp WHERE job = <span class="hljs-string">'MANAGER'</span>)</span></span>;</code></pre><p>如果使用了<strong>NOT  IN</strong> 并且子查询中返回的结果中包含有null，则不会有任何的结果返回。</p></li></ol></li></ol><ol start="2"><li><p>ANY：一共有三种使用形式</p><p>‘=ANY’：与IN操作完全一样</p><p>‘&gt;ANY’：比最小的值要大</p><p>‘&lt;ANY’：比最大的值要小</p></li></ol><ol start="3"><li><p>ALL：所有的内容，有两种方法</p><p>‘&gt;ALL’：比集合中最大的还要大</p><p>‘&lt;ALL’：比集合中最小的还要小</p></li></ol><ol start="2"><li><p>在HAVING中使用子查询</p><p>一般而言都表示子查询返回的是单行单列，并且需要使用到分组统计的时候。（HAVING的时候前提是出现GROUP  BY）</p></li></ol><p>   例如：查询出高于公司平均工资的职位名称、职位人数、平均工资</p><ol start="3"><li><p>在FROM子句中使用子查询</p><p>​        最主要的作用是确定要使用到的数据表，所谓的数据表也就是一个行列点的集合，也就是说如果返回的取数据是一个多行多列的数据，就需要考虑将其直接放入FROM子句之中。</p></li></ol><p>   例如：</p><p>   查询出每个部门的编号、名称、位置、部门人数、平均工资</p>   <pre><code class="hljs java">SELECT d.deptno,d.dname,d.loc,temp.count,temp.avgFROM dept d , (SELECT deptno dno,COUNT(empno) count,AVG(sal) avgFROM empGROUP BY deptno) tempWHERE d.deptno=temp.dno(+) ;</code></pre><ol start="4"><li><p>EXISTS运算</p><p>​        exists运算是一种根据子查询是否有数据的形式来判断条件是否成立的运算符。子查询返回数据则表示判断条件成立。所以EXISTS知识简单的判断是否有数据返回，而不关心返回的具体数据是什么。</p></li></ol><p>Tips：IN和EXISTS的区别：</p><ul><li><p>IN需要明确的进行数据的判断，也就是说子查询中返回的数据的内容要参与运算</p></li><li><p>EXISTS：不需要参考具体的返回内容，其知识依靠是否有数据的返回来判断条件是否成立。</p></li></ul><h2 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h2><p>例如：</p><p>列出与“SCOTT”从事相同工作的所有干员以及部门名称，部门人数，平均工资</p><pre><code class="hljs java">SELECT e.empno,e.ename,e.job,d.dname,temp.count,temp.avgFROM emp e,dept d , (SELECT deptno dno,COUNT(empno) count,AVG(sal) avgFROM empGROUP BY deptno) tempWHERE e.job=(SELECT job FROM emp WHERE ename=<span class="hljs-string">'SCOTT'</span>) AND e.ename&lt;&gt;<span class="hljs-string">'SCOTT'</span>AND e.deptno=d.deptnoAND e.deptno=temp.dno</code></pre><p>列出薪资高于在部门30工作的所有员工的薪资以及高于公司平均工资的员工姓名和薪资、部门名称、部门平均工资、个人工资等级。</p><pre><code class="hljs java">SELECT e.ename,e.sal,d.dname,temp.avg,s.gradeFROM emp e,dept d,(SELECT deptno dno,AVG(sal) avgFROM empGROUP BY deptno) temp,salgrade sWHERE e.sal&gt;ALL(SELECT sal FROM emp WHERE deptno=<span class="hljs-number">30</span>) AND e.sal&gt;(<span class="hljs-function">SELECT <span class="hljs-title">AVG</span><span class="hljs-params">(sal)</span> FROM emp) </span><span class="hljs-function">AND e.deptno</span>=d.deptnoAND e.deptno=temp.dnoAND e.sal BETWEEN s.losal AND s.hisal ;</code></pre><p>查询出所有雇员的编号、姓名、职位、薪金、此职位的人数、领导姓名、领导职位、领导所在的职位的人数，雇员部门、雇员部门的人数，领导部门、领导所在的部门人数，雇员工资等级，以及此等级的平均工资。</p><pre><code class="hljs java">SELECT e.empno,e.ename,e.job,e.sal,empjobtemp.count,m.ename,m.job,mgrjobtemp.count,d.dname,empdepttemp.count,d2.dname,mgrdepttemp.count,s.grade,empsaltemp.countFROM emp e , (SELECT job,COUNT(*) countFROM empGROUP BY job) empjobtemp , emp m ,(SELECT job,COUNT(*) countFROM emp<span class="hljs-function">WHERE job <span class="hljs-title">IN</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">SELECT job</span></span><span class="hljs-function"><span class="hljs-params">FROM emp WHERE empno IN (</span></span><span class="hljs-function"><span class="hljs-params">SELECT DISTINCT mgr FROM emp)</span>)</span><span class="hljs-function">GROUP BY job) mgrjobtemp,dept d ,</span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">SELECT deptno dno,COUNT(*)</span> count</span><span class="hljs-function">FROM emp</span><span class="hljs-function">GROUP BY deptno) empdepttemp ,dept d2 ,</span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">SELECT deptno dno,COUNT(*)</span> count</span><span class="hljs-function">FROM emp</span><span class="hljs-function">WHERE deptno <span class="hljs-title">IN</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">SELECT deptno</span></span><span class="hljs-function"><span class="hljs-params">FROM emp WHERE mgr IN (</span></span><span class="hljs-function"><span class="hljs-params">SELECT mgr FROM emp)</span>)</span><span class="hljs-function">GROUP BY deptno) mgrdepttemp , salgrade s ,</span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">SELECT s1.grade grd,COUNT(e1.empno)</span> count</span><span class="hljs-function">FROM emp e1,salgrade s1</span><span class="hljs-function">WHERE e1.sal BETWEEN s1.losal AND s1.hisal</span><span class="hljs-function">GROUP BY s1.grade) empsaltemp</span><span class="hljs-function">WHERE e.job</span>=empjobtemp.job AND e.mgr=m.empno(+)AND m.job=mgrjobtemp.jobAND e.deptno=d.deptnoAND e.deptno=empdepttemp.dnoAND m.deptno=d2.deptnoAND m.deptno=mgrdepttemp.dnoAND e.sal BETWEEN s.losal AND s.hisal AND s.grade=empsaltemp.grd;</code></pre><h2 id="数据库更新操作"><a href="#数据库更新操作" class="headerlink" title="数据库更新操作"></a>数据库更新操作</h2><p> 数据表的复制操作：</p><pre><code class="hljs java">CREATE TABLE myemp AS SELECT * FROM emp;</code></pre><p>对于数据更新操作在SQL中，一共分为三种：增加（INSERT）、修改（UPDATE）、删除（DELETE）</p><ol><li><p>数据增加</p><p>如果向已有的数据表之中进行数据的增加，其采用的语法有两种：</p><ul><li>完整语法格式（推荐使用）</li></ul><pre><code class="hljs java">INSERT INTO 表名称(列名称,列名称,...) VALUES (内容<span class="hljs-number">1</span>,内容<span class="hljs-number">2</span>,...) ;</code></pre><ul><li>简化语法（不写列名称）</li></ul><pre><code class="hljs java">INSERT INTO 表名称 VALUES (内容<span class="hljs-number">1</span>,内容<span class="hljs-number">2</span>,...) ;</code></pre><p>TIps：</p><p>在追加内容的时候常见的几种类型：</p><ol><li>字符串，要求使用” ‘(单引号) “例如：’hello’</li><li>是数字，直接进行编写</li><li>日期，当前日期使用SYSDATE描述，如果使用自定义日期则可以使用TO_DATE()函数进行转换</li></ol></li></ol><p>   例如：</p><p>   向myemp表中追加一行新的记录</p><p>   使用完整语法：</p>   <pre><code class="hljs java">INSERT INTO myemp (empno,sal,ename,hiredate,job,mgr,comm,deptno) VALUES (<span class="hljs-number">8888</span>,<span class="hljs-number">9999.99</span>,<span class="hljs-string">'爱丽丝'</span>,TO_DATE(<span class="hljs-string">'1969-10-10'</span>,<span class="hljs-string">'yyyy-mm-dd'</span>), <span class="hljs-string">'魔法使'</span>,<span class="hljs-number">1521</span>，<span class="hljs-number">10</span>，<span class="hljs-number">40</span>);</code></pre><p>   如果在某些字段上不想设置数据（null），那么有两种做法：</p><ol><li>在增加的时候不设置具体的内容</li><li>明确的设置内容为null</li></ol><ol start="2"><li><p>数据的修改</p><p>也算是数据的更新处理操作，修改的命令使用的是UPDATE语句完成，其语法如下：</p><pre><code class="hljs java">UPDATE 表名称 SET 字段<span class="hljs-number">1</span>=内容<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span>=内容<span class="hljs-number">2</span>, ... [WHERE 更新条件(s)] ;</code></pre><p>​        如果没有写上那个更新条件，就表示表中的所有数据行信息都要同时进行更新（实际中很少用），如果写上了更新条件就表示只更新满足条件的数据行，这些条件可以像之前限定查询那样进行各种运算符的整合或者使用子查询完成更新操作。</p></li></ol><p>   例如：</p><p>   将7369的雇员工资修改为3500，雇佣日期设置为今天</p>   <pre><code class="hljs java">UPDATE myemp SET sal = <span class="hljs-number">3500</span>, hiredate = SYSDATE WHERE empno = <span class="hljs-number">7369</span>;</code></pre><p>   所有20部门的雇员工资增长20%</p>   <pre><code class="hljs java">UPDATE myemp SET sal = sal * <span class="hljs-number">1.2</span> WHERE deptno = <span class="hljs-number">20</span>;</code></pre><p>   公司所有的雇员的雇佣日期修改为今天</p>   <pre><code class="hljs java">UPDATE myemp SET HIREDATE = SYSDATE;    <span class="hljs-comment">//更新了全部</span></code></pre><ol start="3"><li><p>删除操作</p><p>在以后的开发中，删除操作尽可能不要使用（没有一个所谓的成熟系统支持数据的删除）。</p><p>在SQL中，如果想要删除某些不在使用的数据，可以使用DELETE语法：</p><pre><code class="hljs java">DELETE FROM 表名称 [WHERE 删除条件(s)] ;</code></pre><p>如果要删除表中所有的数据，可以不设置删除条件</p><pre><code class="hljs java">DELETE FROM myemp ;</code></pre><p>在实际的项目之中的删除操作，数据的删除分为两种：</p><ul><li><p>物理删除：直接使用了DELETE语句，彻底删除干净</p></li><li><p>逻辑删除：在表中设置一个逻辑位（例如：设计的时候准备一个flag字段），那么逻辑位的内容如下：</p><ol><li><p>flag=1（非0表示true）：表示带数据已经被删除了</p><p>​        如果数据要被删除则将flag内容设置为1（执行更        新处理）</p></li><li><p>flag=0（0表示false）：表示该数据未被删除</p></li></ol><p>在以后的查询过程中，多增加一个WHERE语句：</p><p>SELECT  *  FROM  表  WHERE  flag=0;</p></li></ul><p>所以在以后的开发中，使用的都是逻辑删除，所谓的删除操作只是一个更新处理。</p></li></ol><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p>​        传统的关系型数据库的最大特征是具有事务的支持能力，最大的好处是可以保证操作数据的完整性，也就是在进行数据更新操作的时候，如果一个更新操作会导致多张数据表的同时更新，那么这些更新要么一起成功，要么一起失败。事务处理是关系型数据库的一个最大特征，但是也是所有性能造成的瓶颈所在，</p><p>事务的控制原理：</p><p>Session（会话），在oracle数据库之中，同一个数据库可以连接多次，那么每一个连接到数据库上的用户在数据库之中，都会使用一个Session的概念来描述，每一个Session之中都拥有自己的独立的操作</p><p>ACID：一个用户一个用户的更新，每个用户的更新操作彼此<strong>独立</strong>，更新完成后的数据要持久化到数据库之中</p><p>Oracle中的事务控制</p><p>重点的命令（也有其他的命令）：</p><ol><li>commit：指的是所有的操作需要进行提交（也就是进行真正的更新，例如删除操作一旦commit，数据就会真正的被删除）</li></ol><ol start="2"><li>rollback：当发现数据操作产生问题的时候就需要进行回滚处理，回滚到上一次的提交点</li></ol><p>在oracle中，对事务的支持控制本身是提供有一个操作的<strong>缓冲区</strong>的，也就是说用户发出的所有的更新操作并不是直接，立刻反应到数据库上（也可以通过设置关闭事务，这样所有的更新会立刻反应到数据库之中），用户如果发现更新没有问题就提交事务，如果有问题则进行数据的回滚。</p><p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%A4%84%E7%90%86.PNG" srcset="/img/loading.gif" alt=""></p><h2 id="事务锁"><a href="#事务锁" class="headerlink" title="事务锁"></a>事务锁</h2><p>例如:</p><ol><li><p>定义两个session分别连接到数据库</p></li><li><p>SessionA现在发出一个更新指令，更新一条数据：</p><pre><code class="hljs java">UPDATE emp SET sal = <span class="hljs-number">9999</span> WHERE empno = <span class="hljs-number">7369</span>;</code></pre></li><li><p>SessionB由于第一个Session并没有提交或者回滚事务，所以这个时候第二个Session是无法更新7369这行数据的（对于其他数据是可以更新的）</p></li><li><p>SessionA执行rollback或者commit表示释放掉当前锁住的数据行，SessionB才可以被执行</p></li><li><p>在进行锁定的时候除了更新操作，可以采用其他的查询模式</p><pre><code class="hljs java">SELECT * FROM emp WHERE empno = <span class="hljs-number">7369</span>;</code></pre><p>也就说，数据行被锁的话，在当前事务释放之前，该数据不允许被修改</p></li></ol><h2 id="数据伪列"><a href="#数据伪列" class="headerlink" title="数据伪列"></a>数据伪列</h2><p>也就是不存在于表中的列，但是该列又可以直接使用。例如：SYSDATE、重量级的伪列：ROWNUM（常用），ROWID（数据库分析）</p><ol><li><p><strong>ROWNUM伪列</strong>（重点）</p><p>在每一次查询过程中，如果想要显示出当前的行号，就自动追加一个ROWNUM即可：</p></li></ol><p>​                例如：ROWNUM的使用</p><pre><code class="hljs java">SELECT ROWNUM, empno, ename FROM emp;</code></pre><p>​                使用了ROWNUM之后，会自动做一个数据的增长列，该行号从1开始，但是该行号就根据数据的查询结果而进行自动的生成，不是固定的</p><p>而在实际开发中，ROWNUM可以做两件事情：</p><ul><li><p>查询第一行记录（不能查看第N行数据，N不等于1）；</p><p>例如：</p><p>查询第一行数据：</p><pre><code class="hljs java">SELECT empno,ename FROM emp WHERE ROWNUM=<span class="hljs-number">1</span> ;SELECT empno,ename FROM emp WHERE deptno=<span class="hljs-number">10</span> AND ROWNUM=<span class="hljs-number">1</span> ;</code></pre></li></ul><ul><li><p>查询前N行记录；</p><p>例如：</p><p>查询emp的前5行数据：</p><pre><code class="hljs java">SELECT ROWNUM, empno, ename FROM emp WHERE ROWNUM &lt;= <span class="hljs-number">5</span>;</code></pre><p>ROWNUM只有看前N行的能力，没有直接提供看中间行的能力（比如6~10行）</p></li></ul><p><strong>数据的分页显示处理</strong>（很重要！！！）</p><p>所谓的分页显示指的是可以让表中的数据信息按照部分的模式来完成，在Oracle中分页的基本语法定义如下：</p><pre><code class="hljs java">SELECT * FROM (SELECT 查询字段,查询字段,..,ROWNUM rn    FROM 数据表WHHERE ROWNUM&lt;=currentPage * lineSize) tempWHERE temp.rn&gt;(currentPage-<span class="hljs-number">1</span>)*lineSize ;</code></pre><p>其中currentPage描述的是当前所在页，而lineSize描述的是每页显示的数据行数</p><p>例如：</p><p>查询表中的6~10条记录</p><ul><li>此时描述的是第二页的数据，也就是说currentPage = 2，lineSize = 5（每页显示五行数据）</li></ul><pre><code class="hljs java">SELECT *FROM (SELECT empno,ename,job,ROWNUM rnFROM empWHERE ROWNUM&lt;=<span class="hljs-number">10</span>) tempWHERE temp.rn&gt;<span class="hljs-number">5</span> ;</code></pre><ol start="2"><li><p>ROWID（一般分析上使用）</p><p>指的是数据行的唯一编号，该编号通过硬盘的存储而得来的</p><p>例如：ROWID的组成</p><pre><code class="hljs java">SELECT ROWID deptno, dname, loc FROM dept;</code></pre><p>每一行都有唯一的一个ROWID数据，而且最为重要的是，如果想要定位某一个数据行，可以通过ROWID来实现。</p><p>例如：</p><p>通过ROWID找到一行数据</p><pre><code class="hljs java">SELECT deptno, dname, loc FROM dept WHERE ROWID = <span class="hljs-string">'AAAR3qAAEAAAACHAAD'</span>;</code></pre><p>对于任何一个ROWID其基本组成结构如下：”AAAR3qAAEAAAACHAAD”</p><ul><li>数据的对象编号：AAAR3q</li><li>数据保存你的文件编号：AAE</li><li>数据保存的文件块编号：AAAACH</li><li>数据保存的行号：AAD</li></ul></li></ol><h2 id="数据表的创建与管理"><a href="#数据表的创建与管理" class="headerlink" title="数据表的创建与管理"></a>数据表的创建与管理</h2><p>数据表的定义属于SQL-DDL（数据定义语言）范畴，其不受到事务的控制，也就是说只有DML操作才受到事务的控制，并且在Oracle中，<strong>如果事务未提交，并且发生了DDL操作，所有未提交的事务将自动提交</strong>，也就是说在实际开发之中，数据表的创建要么是在系统定义的同时设置上，或者最简单的方式就是进行关闭服务的维护。</p><ol><li><p>常用的数据类型</p><p>每一个数据都要求有自己的数据类型</p><p>数据类型有如下几种：</p><ul><li>VARCHAR2(n)：一般要保存200个字以内的数据都会采用此类型，例如：姓名、家庭住址、新闻关键字</li><li>NUMBER：直接编写NUMBER表示的就是数字（包括小数或者是整数）<ol><li>NUMBER(n)：表示最多n位整数</li><li>NUMBER(n ,m)：表示m个小数位，n-m的整数位</li></ol></li><li>DATE：描述日期时间（Oracle中的DATE类型是包含有时间数据的，而其他数据库的DATE只有日期）</li><li>CLOB（4G）：描述大文本数据</li><li>BLOB（4G）：描述二进制的数据，例如：电影、音乐、文字等，一般而言不会考虑BLOB类型</li></ul></li></ol><h3 id="数据表的创建"><a href="#数据表的创建" class="headerlink" title="数据表的创建"></a>数据表的创建</h3><p>语法：</p><pre><code class="hljs java">CREATE TABLE 表名称 (列名称 数据类型 [DEFAULT 默认值] ,列名称 数据类型 [DEFAULT 默认值] ,...列名称 数据类型 [DEFAULT 默认值]       <span class="hljs-comment">//最后一列不加逗号</span>) ;</code></pre><p>列名称的定义一般都建议使用字母开头，中文也可以，不过不要用</p><p>例如：</p><pre><code class="hljs java"><span class="hljs-function">CREATE TABLE <span class="hljs-title">member</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">mid VARCHAR2(<span class="hljs-number">20</span>)</span>,</span><span class="hljs-function">name <span class="hljs-title">VARCHAR2</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span> DEFAULT '无名氏',</span><span class="hljs-function">age <span class="hljs-title">NUMBER</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span>,</span><span class="hljs-function">salary <span class="hljs-title">NUMBER</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)</span>,</span><span class="hljs-function">birthday DATE DEFAULT SYSDATE,</span><span class="hljs-function">note CLOB</span><span class="hljs-function">)</span>;</code></pre><pre><code class="hljs java">SELECT * FROM tab;<span class="hljs-comment">//可以查看所有的数据表名称</span></code></pre><pre><code class="hljs JAVA">DESC MEMBER;<span class="hljs-comment">//使用DESC可以查看数据表组成的结构</span></code></pre><p>创建表时所采用的的默认值知识数据库本身的一种实现，但在开发中，一般不会进行默认值的设置，而内容默认值的设置一般都是通过程序完成的。</p><p>表的复制</p><p>可以根据已有的数据表（也可能是查询语句），来进行数据表的动态创建。</p><p>语法：</p><pre><code class="hljs java">CREATE TABLE 表名称 AS 子查询 ;</code></pre><p>例如：</p><p>将20部门的雇员复制到emp20表中</p><pre><code class="hljs java"><span class="hljs-function">CREATE TABLE emp20 <span class="hljs-title">AS</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">SELECT * FROM emp WHERE deptno = <span class="hljs-number">20</span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre><p>将emp的表结构复制到empnull表中</p><pre><code class="hljs java"><span class="hljs-comment">//此时 只需要编写一个绝对不可能满足的条件即可</span><span class="hljs-function">CREATE TABLE empnull <span class="hljs-title">AS</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">SELECT * FROM emp WHERE <span class="hljs-number">1</span> = <span class="hljs-number">2</span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre><h3 id="修改表名称"><a href="#修改表名称" class="headerlink" title="修改表名称"></a>修改表名称</h3><p>在开发之中并不常用，所以对于这样的操作语法也只有Oracle自己支持。</p><p>​        数据字典：数据库会自动进行相关数据对象的记录，可以理解为一张系统维护的数据表，当用户创建了一张数据表之后，在数据库中会自动将表的名称以及表的相关信息，都保存在一张系统维护的数据表里面。所以表的更新就是进行数据字典的休息修改，但是该数据字典一定要由系统自己来进行维护，所以用户只能采用一系列的命令来完成，对于数据字典在Oracle中，一共分为三位：</p><ul><li>USER_*（以USER开头）：表示用户具有的数据字典的信息</li><li>DBA_*：表示数据库管理员具有的数据字典的信息</li><li>ALL_*：表示用户何管理员都可以访问的数据字典信息</li></ul><p>例如：</p><p>查看数据表保存的字典信息：</p><pre><code class="hljs java">SELECT * FROM user_tables;</code></pre><p>修改表名称：</p><p>语法：</p><pre><code class="hljs java">RENAME 旧的表名称 TO 新的表名称</code></pre><p>例如：</p><pre><code class="hljs java">RENAME member TO person;</code></pre><h3 id="截断数据表"><a href="#截断数据表" class="headerlink" title="截断数据表"></a>截断数据表</h3><pre><code class="hljs java">TRUNCATE TABLE person;</code></pre><p>表截断之后，该表中的所有资源将彻底被释放，并且无法进行事务的回滚操作，一般都在清空数据表的时候使用，但是实际开发中，一般不进行数据表的清空。</p><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>数据表不再使用之后，可以进行表的删除，表一旦删除之后，默认情况下（大部分情况下是无法进行恢复的）， </p><p>语法：</p><pre><code class="hljs java">DROP TABLE 表名称;</code></pre><p>例如：</p><p>删除数据表</p><pre><code class="hljs java">DROP TABLE empnull;</code></pre><p>​        在Oracle 10g之前，如果是进行了数据表的删除，那么该表就彻底删除了，但是从Oracle 10g开始之后，为了防止数据表被直接删除处理，所以提供了恢复的机制。</p><h3 id="闪回操作"><a href="#闪回操作" class="headerlink" title="闪回操作"></a>闪回操作</h3><p>​        从Oracle 10g开始，默认情况下每当执行了一次表的删除处理都会留写一些：“BIN$Zqba7ZgYRhqvjJlMjTBogw==$0”这样的形式的数据表，这个就是FalshBack()技术，也就是相当于提供了一个回收站的功能。</p><ul><li>最早的时候进行回收站的查看：SHOWRECYCLEBIN（不稳定）；</li><li>通用的查看回收站可以采用数据字典：</li></ul><pre><code class="hljs java">COL object_name FOR A30 ;COL original_name FOR A30 ;COL droptime FOR A30 ;SELECT object_name,original_name,droptime FROM user_recyclebin ;</code></pre><p>如果发现有数据表删除错误了，可以通过回收站进行恢复</p><pre><code class="hljs java">FLASHBACK TABLE emp20 TO BEFORE DROP;</code></pre><p>如果不希望通过回收站，而是希望直接删除数据表，则可以在删除的时候设置一个选项：</p><pre><code class="hljs java">DROP TABLE emp20 PURGE ;<span class="hljs-comment">//彻底删除不经过回收站</span></code></pre><p>删除回收站的表：</p><pre><code class="hljs java">PURGE TABLE empnull ;<span class="hljs-comment">//删除回收站的表</span></code></pre><p>清空回收站</p><pre><code class="hljs java">PURGE RECYCLEBIN ;<span class="hljs-comment">//清空回收站</span></code></pre><p>（删除表尽量先经过回收站）</p><h3 id="数据表的创建于管理"><a href="#数据表的创建于管理" class="headerlink" title="数据表的创建于管理"></a>数据表的创建于管理</h3><p>表结构的修改，实际上就是字段的增加和减少的过程</p><ol><li>追加表的数据列的语法：</li></ol><pre><code class="hljs java">ALTER TABLE 表名称 ADD (列名称 数据类型 [DEFAULT 默认值],列名称 数据类型 [DEFAULT 默认值],...)<span class="hljs-comment">//可以一条语句上设置多个要追加的数据列</span></code></pre><p>​        例如：</p><p>​        为表中追加一个age的数据列，并且不设置默认值</p><pre><code class="hljs JAVA"><span class="hljs-function">ALTER TABLE member <span class="hljs-title">ADD</span> <span class="hljs-params">(age NUMBER(<span class="hljs-number">3</span>)</span>)</span>;</code></pre><p>​        此时，已有数据行中对应的列内容为null</p><p>​        为表中追加一个sex数据列，设置默认值</p><pre><code class="hljs java"><span class="hljs-function">ALTER TABLE member <span class="hljs-title">ADD</span> <span class="hljs-params">(sex VARCHAR2(<span class="hljs-number">10</span>)</span> DEFAULT '女')</span>;</code></pre><p>​                一旦有默认值之后，对应表中的所有数据行的内容都需要进行更改 （一        般不在修改表结构的时候设置默认值）</p><ol start="2"><li><p>修改表的数据列</p><p>语法：</p><pre><code class="hljs java">ALTER TABLE 表名称 MODIFY (列名称 数据类型 [DEFAULT 默认值],列名称 数据类型 [DEFAULT 默认值],...)</code></pre><p>例如：将name的长度修改为50</p><pre><code class="hljs java"><span class="hljs-function">ALTER TABLE member <span class="hljs-title">MODIFY</span><span class="hljs-params">(name VARCHAR2(<span class="hljs-number">50</span>)</span>) </span>;</code></pre></li><li><p>删除数据列</p><p>语法：</p><pre><code class="hljs java">ALTER TABLE 表名称 DROP COLUMN 字段名称 ;</code></pre><p>例如；</p><p>删除age的数据列：</p><pre><code class="hljs java">ALTER TABLE member DROP COLUMN age;</code></pre></li><li><p>数据库对象（DDL）操作只有三类语法：</p><p>CREATE    对象类型    对象名称  </p><p>DROP    对象类型    对象名称</p><p>ALTER    对象类型    对象名称</p></li></ol><h2 id="约束的创建与管理"><a href="#约束的创建与管理" class="headerlink" title="约束的创建与管理"></a>约束的创建与管理</h2><p>​        当数据表创建完成的时候只能够说，确定了要操作的数据表的存储结构，如果想真正的去将其应用在项目之中，就必须要保证里面存放的数据是有效的数据。所以在传统关系型数据库中，为了保证这些数据的完整性，就提供有一套自己的检测机制：约束。</p><p>约束的基本概念</p><p>​        约束是保证数据完整型的一种手段，根据功能约束一共分为6种，其中有一种成为数据类型的约束（也就是数据类型为NUMBER的，不能存放字符串），而除了这类约束之外还有五种：</p><ul><li><p>非空约束（NOT NULL 、NK）：保证数据表中的某一个字段的内容不允许是null；</p></li><li><p>唯一约束（UNIQUE、UK）：该列上的数据不允许出现重复</p></li><li><p>主键约束（PRIMARY  KEY、PK）：非空约束 + 唯一约束</p></li><li><p>检查约束（CHECK、CK）：设置一些判断条件，而后满足条件的允许更新</p></li><li><p>外键约束（FOREIGN  KEY、FK）：设置父子表之间的约束关系</p><p>只有满足约束条件的数据才能够被更新处理（才能够被保存在数据库之中）</p></li></ul><p>系统之中，所设置的表约束越多，那么数据库的性能就会越差，但是对于约束的使用也需要考虑两种情况：</p><ol><li>传统的软件开发：由于使用的服务器设备有限（单台），所以约束可以适当完善</li><li>如果是保证性能的开发，基本上唯一可以使用的约束就是主键约束</li></ol><ol><li><p>非空约束</p><p>​        非空约束严格来讲属于一种特殊的约束形式，因为其设置的约束形式和其他的约束相同，但是其处理流程有一些差别，如果要使用非空约束，则在创建表的时候在指定的字段后设置一个“NOT NULL”即可。</p><pre><code class="hljs java"><span class="hljs-function">CREATE TABLE <span class="hljs-title">member</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">mid VARCHAR2(<span class="hljs-number">50</span>)</span> ,</span><span class="hljs-function">name <span class="hljs-title">VARCHAR2</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span> NOT NULL<span class="hljs-comment">//name字段更新的时候必须设置内容</span></span><span class="hljs-function">) </span>;</code></pre><pre><code class="hljs java"><span class="hljs-function">INSERT INTO <span class="hljs-title">member</span><span class="hljs-params">(mid,name)</span> <span class="hljs-title">VALUES</span> <span class="hljs-params">(<span class="hljs-string">'hello'</span>,<span class="hljs-keyword">null</span>)</span> </span>;</code></pre><p>由于此时name字段上没有设置具体的内容，所以在进行数据的增加的时候会出现如下的错误信息</p><blockquote><p>ORA-01400: 无法将 NULL 插入 (“SCOTT”.”MEMBER”.”NAME”)</p></blockquote><p>如果更新的时候，违反了非空约束，会明确指出代码出错的位置所在</p></li></ol><ol start="2"><li><p>唯一约束</p><p>主要特征是：数据表中的某一列上的内容不允许重复。如果想要设置唯一约束可以使用UNIQUE来实现</p><p>例如：</p><p>定义数据表使用唯一约束</p><pre><code class="hljs java"><span class="hljs-function">CREATE TABLE <span class="hljs-title">member</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">mid VARCHAR2(<span class="hljs-number">50</span>)</span> ,</span><span class="hljs-function">name <span class="hljs-title">VARCHAR2</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span> NOT NULL ,</span><span class="hljs-function">email <span class="hljs-title">VARCHAR2</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span> UNIQUE</span><span class="hljs-function">) </span>;</code></pre><p>设置唯一约束的时候null不在唯一约束的奠定范畴之内</p><pre><code class="hljs java"><span class="hljs-function">INSERT INTO <span class="hljs-title">member</span><span class="hljs-params">(mid,name,email)</span> <span class="hljs-title">VALUES</span> <span class="hljs-params">(<span class="hljs-string">'hello'</span>,<span class="hljs-string">'你好'</span>,<span class="hljs-keyword">null</span>)</span> </span>;</code></pre><p>重复插入违反唯一约束之后：</p><pre><code class="hljs java">ORA-<span class="hljs-number">00001</span>: 违反唯一约束条件 (SCOTT.SYS_C0011118)</code></pre><p>​        所有的约束在Oracle数据库之中都会成为一个个独立的数据库对象，如果没有为约束设置对象的名字，那么会由系统自动的分配一个唯一的名称（例如：(SCOTT.SYS_C0011118)）进行该对象的标注。所以要查看错误的具体信息，需要通过数据字典来进行观察：</p><ul><li>查看约束与表的对应关系</li></ul><pre><code class="hljs java">SELECT * FROM user_constraints ;</code></pre><ul><li>查看约束与表中的列对应关系</li></ul><pre><code class="hljs java">SELECT * FROM user_cons_columns ;<span class="hljs-comment">//格式会更好看一点</span>COL owner FOR A20 ;COL constraint_name FOR A20 ;COL table_name FOR A20 ;COL column_name FOR A20 ;SELECT owner,constraint_name,table_name,column_name FROM user_cons_columns ;</code></pre><p>​        但是如果每一次违反约束后都要这=这样去查看约束信息会很麻烦，所以为了简化约束的错误查看，最好的做法是明确的为约束设置一个名字，而设置约束的名字需要增加新的配置项（不可直接在列名称上设置约束）。</p><p>例如：</p><pre><code class="hljs java"><span class="hljs-function">CREATE TABLE <span class="hljs-title">member</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">mid VARCHAR2(<span class="hljs-number">50</span>)</span> ,</span><span class="hljs-function">name <span class="hljs-title">VARCHAR2</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span> NOT NULL ,</span><span class="hljs-function">email <span class="hljs-title">VARCHAR2</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span>,</span><span class="hljs-function">CONSTRAINT uk_email_UNIQUE <span class="hljs-title">UNIQUE</span><span class="hljs-params">(email)</span></span><span class="hljs-function">) </span>;</code></pre><p>此时如果违反约束条件，会提示：</p><pre><code class="hljs java">ORA-<span class="hljs-number">00001</span>: 违反唯一约束条件 (SCOTT.UK_EMAIL_UNIQUE)</code></pre><p>可以明确知道错误的位置，方便排除错误。</p><p>​        所以以后的设计中，为了方便维护，应该为每一个约束设定一个具体的约束名称（非空约束可以不用）。</p></li></ol><ol start="3"><li><p>主键约束</p><p>指的就是“非空约束 + 唯一约束”，也就是说作为一个唯一标识使用</p><p>例如：</p><p>定义主键约束</p><pre><code class="hljs java"><span class="hljs-function">CREATE TABLE <span class="hljs-title">member</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">mid VARCHAR2(<span class="hljs-number">50</span>)</span> ,</span><span class="hljs-function">name <span class="hljs-title">VARCHAR2</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span> NOT NULL ,</span><span class="hljs-function">CONSTRAINT pk_mid_primary PRIMARY <span class="hljs-title">KEY</span><span class="hljs-params">(mid)</span></span><span class="hljs-function">) </span>;</code></pre><p>增加正确的数据：</p><pre><code class="hljs java"><span class="hljs-function">INSERT INTO <span class="hljs-title">member</span><span class="hljs-params">(mid,name)</span> <span class="hljs-title">VALUES</span> <span class="hljs-params">(<span class="hljs-string">'hello'</span>,<span class="hljs-string">'田田抬头'</span>)</span> </span>;</code></pre><p>如果数据错误：</p><ol><li><p>情况一：追加的主键内容为空</p><pre><code class="hljs java"><span class="hljs-function">INSERT INTO <span class="hljs-title">member</span><span class="hljs-params">(name)</span> <span class="hljs-title">VALUES</span> <span class="hljs-params">(<span class="hljs-string">'田田低头'</span>)</span> </span>;</code></pre><p>错误提示信息：</p><pre><code class="hljs java">ORA-<span class="hljs-number">01400</span>: 无法将 NULL 插入 (<span class="hljs-string">"SCOTT"</span>.<span class="hljs-string">"MEMBER"</span>.<span class="hljs-string">"MID"</span>)</code></pre></li></ol></li></ol><ol start="2"><li><p>情况二：设置的主键重复</p><p>错误提示：</p><pre><code class="hljs java">ORA-<span class="hljs-number">00001</span>: 违反唯一约束条件 (SCOTT.PK_MID_PRIMARY)</code></pre><p>所以可以看出主键约束就是两种约束（非空约束 + 唯一约束）的合集。（复合主键的情况应该积极避免）</p></li></ol><h3 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h3><p>​        检查约束的本质在于设置一系列的过滤条件，当满足了这些过滤条件之后才可以保证数据更新，</p><p>例如：</p><pre><code class="hljs java"><span class="hljs-function">CREATE TABLE <span class="hljs-title">member</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">mid VARCHAR2(<span class="hljs-number">50</span>)</span> ,</span><span class="hljs-function">name <span class="hljs-title">VARCHAR2</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span> ,</span><span class="hljs-function">age <span class="hljs-title">NUMBER</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span> ,</span><span class="hljs-function">sex <span class="hljs-title">VARCHAR2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span> ,</span><span class="hljs-function">CONSTRAINT pk_mid PRIMARY <span class="hljs-title">KEY</span><span class="hljs-params">(mid)</span> ,</span><span class="hljs-function">CONSTRAINT ck_age <span class="hljs-title">CHECK</span> <span class="hljs-params">(age BETWEEN <span class="hljs-number">0</span> AND <span class="hljs-number">250</span> )</span>,</span><span class="hljs-function">CONSTRAINT ck_sex <span class="hljs-title">CHECK</span><span class="hljs-params">(sex IN (<span class="hljs-string">'男'</span>,<span class="hljs-string">'女'</span>)</span>)</span><span class="hljs-function">) </span>;</code></pre><p>当执行错误语句时：</p><pre><code class="hljs java"><span class="hljs-function">INSERT INTO <span class="hljs-title">member</span><span class="hljs-params">(mid,name,age,sex)</span> <span class="hljs-title">VALUES</span> <span class="hljs-params">(<span class="hljs-string">'xiaoli'</span>,<span class="hljs-string">'小李'</span>,<span class="hljs-number">900</span>,<span class="hljs-string">'非女'</span>)</span> </span>;</code></pre><p>两个数据都违反检查约束，但是这些检查的过滤并不是一次性检查完成的，而是一个个检查的。所以设置的检查约束越多，程序的执行速度也就越慢。所以多数情况下，都会选择在程序的代码之中进行这希望检查的处理。</p><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>描述的是两张关系表（可以理解为父子关系表）上使用的约束</p><p>例如：</p><pre><code class="hljs java"><span class="hljs-function">CREATE TABLE <span class="hljs-title">member</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">mid VARCHAR2(<span class="hljs-number">50</span>)</span> ,</span><span class="hljs-function">name <span class="hljs-title">VARCHAR2</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span> ,</span><span class="hljs-function">CONSTRAINT pk_mid PRIMARY <span class="hljs-title">KEY</span><span class="hljs-params">(mid)</span></span><span class="hljs-function">) </span>;<span class="hljs-comment">//可以看作父表</span><span class="hljs-function">CREATE TABLE <span class="hljs-title">book</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">bid NUMBER ,</span></span><span class="hljs-function"><span class="hljs-params">title VARCHAR2(<span class="hljs-number">50</span>)</span> ,</span><span class="hljs-function">mid <span class="hljs-title">VARCHAR2</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span> ,</span><span class="hljs-function">CONSTRAINT pk_bid PRIMARY <span class="hljs-title">KEY</span><span class="hljs-params">(bid)</span> ,</span><span class="hljs-function">CONSTRAINT fk_mid FOREIGN <span class="hljs-title">KEY</span><span class="hljs-params">(mid)</span> REFERENCES <span class="hljs-title">member</span><span class="hljs-params">(mid)</span></span><span class="hljs-function">) </span>;<span class="hljs-comment">//可以看作子表</span></code></pre><p>这个时候如果追加子表的数据的时候没有指定父表的数据与之对应，则会抛出错误：“ORA-02291: 违反完整约束条件 (SCOTT.FK_MID) - 未找到父项关键字”</p><p>需要注意：</p><ol><li><p>一旦设置了外键外键关系之后，在删除主表之前就必须删除子表，否则无法删除</p><pre><code class="hljs java">ORA-<span class="hljs-number">02449</span>: 表中的唯一/主键被外键引用</code></pre><p>如果两张表互为父子表则可以使用：</p><pre><code class="hljs java">DROP TABLE member CASCADE CONSTRAINT ;</code></pre></li><li><p>对于数据的记录在默认的情况下，必须先删除父表中的记录，而后才能删除子表中的记录，但是这样就很麻烦，所以这个时候在外键设置中，可以设置级联操作，有两种级联处理：</p><ul><li><p>级联删除：ON  DELETE  CASCADE</p><pre><code class="hljs java"><span class="hljs-function">CREATE TABLE <span class="hljs-title">member</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">mid VARCHAR2(<span class="hljs-number">50</span>)</span> ,</span><span class="hljs-function">name <span class="hljs-title">VARCHAR2</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span> ,</span><span class="hljs-function">CONSTRAINT pk_mid PRIMARY <span class="hljs-title">KEY</span><span class="hljs-params">(mid)</span></span><span class="hljs-function">) </span>;<span class="hljs-function">CREATE TABLE <span class="hljs-title">book</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">bid NUMBER ,</span></span><span class="hljs-function"><span class="hljs-params">title VARCHAR2(<span class="hljs-number">50</span>)</span> ,</span><span class="hljs-function">mid <span class="hljs-title">VARCHAR2</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span> ,</span><span class="hljs-function">CONSTRAINT pk_bid PRIMARY <span class="hljs-title">KEY</span><span class="hljs-params">(bid)</span> ,</span><span class="hljs-function">CONSTRAINT fk_mid FOREIGN <span class="hljs-title">KEY</span><span class="hljs-params">(mid)</span> REFERENCES <span class="hljs-title">member</span><span class="hljs-params">(mid)</span> ON DELETE CASCADE</span><span class="hljs-function">) </span>;</code></pre><p>这样两张表中的数据都会被删除</p></li></ul></li></ol><ul><li><p>级联更新：ON  DELETE  SET  NULL，也就是说如果被删除了，则子表中对应的外键字段设置为NULL</p><pre><code class="hljs java"><span class="hljs-function">CREATE TABLE <span class="hljs-title">member</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">mid VARCHAR2(<span class="hljs-number">50</span>)</span> ,</span><span class="hljs-function">name <span class="hljs-title">VARCHAR2</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span> ,</span><span class="hljs-function">CONSTRAINT pk_mid PRIMARY <span class="hljs-title">KEY</span><span class="hljs-params">(mid)</span></span><span class="hljs-function">) </span>;<span class="hljs-function">CREATE TABLE <span class="hljs-title">book</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">bid NUMBER ,</span></span><span class="hljs-function"><span class="hljs-params">title VARCHAR2(<span class="hljs-number">50</span>)</span> ,</span><span class="hljs-function">mid <span class="hljs-title">VARCHAR2</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span> ,</span><span class="hljs-function">CONSTRAINT pk_bid PRIMARY <span class="hljs-title">KEY</span><span class="hljs-params">(bid)</span> ,</span><span class="hljs-function">CONSTRAINT fk_mid FOREIGN <span class="hljs-title">KEY</span><span class="hljs-params">(mid)</span> REFERENCES <span class="hljs-title">member</span><span class="hljs-params">(mid)</span> ON DELETE SET NULL</span><span class="hljs-function">) </span>;</code></pre><p>但是对于是否使用级联并没有明确的要求，也就是说是否为外键进行级联配置完全由业务需要来决定。</p></li></ul><h3 id="修改约束"><a href="#修改约束" class="headerlink" title="修改约束"></a>修改约束</h3><p>​        设置原则，当数据表的创建完成后一定要将约束同时建立完整，并且不要进行约束的变更。</p><ol><li><p>为表追加约束</p><p>语法：</p><p>ALTER  TABLE  表名称  ADD  CONSTRAINT  约束名称  约束类型（字段）;</p><p>例如：</p><pre><code class="hljs java"><span class="hljs-function">ALTER TABLE member ADD CONSTRAINT pk_mid PRIMARY <span class="hljs-title">KEY</span><span class="hljs-params">(mid)</span> </span>;<span class="hljs-comment">//为member表追加主键约束</span></code></pre><p>但是如果数据表之中有违反主键的情况出现，那么该约束是无法添加的</p><p>Tips：</p><p>​        ALTER…ADD  CONSTRAINT  语法只能够追加非空之外的约束，如果想要追加非空约束，则只能采用修改表结构的模式完成。</p><pre><code class="hljs java"><span class="hljs-function">ALTER TABLE member <span class="hljs-title">MODIFY</span><span class="hljs-params">(name VARCHAR2(<span class="hljs-number">50</span>)</span> NOT NULL) </span>;</code></pre><p>如果有违反约束的记录存在，同样也不可修改</p></li></ol><ol start="2"><li><p>删除表约束</p><p>语法：</p><p>ALTER  TABLE  表名称  DROP  CONSTRAINT  约束名称;</p><p>例如：</p><p>删除主键约束</p><pre><code class="hljs java">ALTER TABLE member DROP CONSTRAINT pk_mid ;</code></pre><p><strong>但是，最好的做法是数据表和约束一起产出</strong></p></li></ol><h2 id="Oracle序列"><a href="#Oracle序列" class="headerlink" title="Oracle序列"></a>Oracle序列</h2><p>​        Oralce序列是一个Oracle之中最为常用的数据对象的类型，所谓的序列本质上指的就是自动增长列的配置实现，但是oracle 11g中并没有提供简便的自动增长列的设置，Oracle中提供的是一种手工的控制序列的模式来实现自动增长列（也就是说，用户需要自己手工控制才可以完成），在Oracle 12c开始才真正追加了自动增长列的配置。</p><p>序列创建的语法：</p><pre><code class="hljs java">CREATE SEQUENCE 序列名称 [START WITH 开始值][INCREMENTY BY 步长][MAXVALUE 最大值 | NOMAXVALUE][MINVALUE 最小值 | NOMAXVALUE][CYCLE | NOCYCLE]   <span class="hljs-comment">//是否为循环序列</span>[CACHE 缓存个数 | NOCACHE]<span class="hljs-comment">//是否有缓存</span></code></pre><p>对于以上的选项，其默认设置如下：</p><ol><li>开始值（START  WITH）：1</li><li>步长（INCREMENTY  BY）：1</li><li>最大值（MAXVALUE）：NOMAXVALUE</li><li>最小值（MINVALUE）：1</li><li>是否为循环序列：非循环序列</li><li>缓存（CACHE）：20</li></ol><p>例如：</p><pre><code class="hljs java">CREATE SEQUENCE myseq ;</code></pre><p>当一个序列创建完成之后，会自动将此序列的信息保存在数据字典表之中（user_sequences）</p><p>序列创建完成之后，如果想要使用该序列，可以采用序列之中定义的两个伪列：</p><ul><li><p>序列名称.nextval：获取下一个增长值，也就是说当前内容加上步长</p></li><li><p>序列名称.currval：获取序列当前的内容</p><p><strong>一定要先调用nextval之后才可以执currval</strong>，否则会报错“MYSEQ.CURRVAL 尚未在此会话中定义”</p></li></ul><p>在数据字典中，last_number这个数据值的增长是利用“步长 * 缓存个数“得来的，在Oracle数据库中，为了防止每一次都频繁的进行计算，所以会帮助用户做一个数据的缓存处理。缓存的好处是提高操作性能，缺点是，如果一旦数据库停掉了，那么可能缓存的数据就丢失了</p><p>序列与数据表结合使用，只能在增加语句上进行操作</p><p>例如：</p><p>编写增加语句，设置mid的时候用序列处理</p><pre><code class="hljs java"><span class="hljs-function">INSERT INTO <span class="hljs-title">member</span><span class="hljs-params">(mid,name)</span> <span class="hljs-title">VALUES</span> <span class="hljs-params">(myseq.nextval,<span class="hljs-string">'mldn'</span>)</span> </span>;</code></pre><p>也可以在序列定义的时候，定义一些自定义选项来处理</p><ol><li><p>将序列的默认开始值设置为100</p><pre><code class="hljs java">DROP SEQUENCE myseq ;CREATE SEQUENCE myseq START WITH <span class="hljs-number">100</span> ;</code></pre></li><li><p>修改序列的步长，将步长设置为2</p><pre><code class="hljs java">DROP SEQUENCE myseq ;CREATE SEQUENCE myseq START WITH <span class="hljs-number">100</span> INCREMENT BY <span class="hljs-number">2</span> ;</code></pre></li><li><p>设置一个循环序列，例如：要求序列在1，3， 5，7，9之间进行循环处理</p><pre><code class="hljs java">DROP SEQUENCE myseq ;CREATE SEQUENCE myseq START WITH <span class="hljs-number">1</span>INCREMENT BY <span class="hljs-number">2</span>MINVALUE <span class="hljs-number">1</span>MAXVALUE <span class="hljs-number">9</span>CYCLE CACHE <span class="hljs-number">3</span> ;</code></pre></li></ol><h2 id="同义词"><a href="#同义词" class="headerlink" title="同义词"></a>同义词</h2><p>​        属于Oracle自己的概念</p><p>dual表是一张临时表，一般拿它作为测试使用，DUAL是属于sys的用户表</p><p>​        在数据库中有一个模式的概念叫做（SCHEMA），每一张数据表的全名实际上是“schema.table”。对于这个模式，最初的时候是需要用户单独创建的，后来将模式和用户名的概念结合在了一起，所以现在所谓的模式，基本上指的都是用户名。所以例如：emp在其他的用户下的完整表名应该是：scott.emp</p><p>所以同义词在Oracle中的主要目的是为了方便不同用户之间的数据表的访问。例如：scott中可以访问sys的dual表，是因为dual属于sys.dual的同义词。</p><p>要创建同义词往往都需要具备有管理员的权限来完成，比如在sys上创建。</p><p>语法：</p><p>CREATE  SYNONYM  同义词名称  FOR  用户名.表名称;</p><p>例如：将scott.emp的数据表创建为emp的同义词：</p><pre><code class="hljs java">CREATE SYNONYM emp FOR scott.emp ;</code></pre><p>这个时候所创建的同义词只能够由sys一个用户使用，因为不是公共同义词，如果一个同义词要被所有用户访问，则在创建前需要追加一个PUBLIC </p><pre><code class="hljs java">DROP SYNONYM emp ;CREATE PUBLIC SYNONYM emp FOR scott.emp ;</code></pre><p>同义词只是Oracle提供的一个支持。</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>主要功能是封装复杂的查询语句，也就是说，利用视图就可以实现数据的复杂查询操作。</p><p>创建视图语法：</p><pre><code class="hljs java">CREATE [OR REPLACE] VIEW 视图名称 AS 子查询[WITH CHECK OPTION] [WITH READ ONLY] ;</code></pre><p>如果使用了CREATE  REPLACE表示该视图如果不存在就创建，如果存在就使用新的语句进行试图的替换。</p><p>例如：</p><p>实现一个包含有复杂查询的视图</p><p>在11g中，scott用户的视图创建权限被剥削了，所以需要将其重新授权：</p><ol><li>使用sys登录：conn sys / change_on_install as sysdba;</li><li>进行授权控制：GRANT CREATE VIEW TO scott;</li><li>切换到scott：CONN   scott / tiger</li></ol><pre><code class="hljs jav">CREATE OR REPLACE VIEW myviewAS&#x2F;&#x2F;进行包装处理SELECT d.deptno,d.dname,d.loc,temp.countFROM dept d, (SELECT deptno dno,COUNT(empno) countFROM empGROUP BY deptno) tempWHERE d.deptno&#x3D;temp.dno(+) ;</code></pre><p> 当视图创建完成之后，就可以直接查询视图了</p><pre><code class="hljs java">SELECT * FROM myview;</code></pre><p>但是在视图中，为了保证创建字段的内容不被改变，可以考虑使用子句：“WIEH  CHECK  OPTION”</p><p>例如：</p><p>创建一个不允许修改创建字段的视图：</p><pre><code class="hljs java">CREATE OR REPLACE VIEW myviewASSELECT * FROM emp WHERE deptno=<span class="hljs-number">20</span>WITH CHECK OPTION ;</code></pre><p>这时更新数据：</p><pre><code class="hljs java">UPDATE myview SET deptno=<span class="hljs-number">30</span> WHERE empno=<span class="hljs-number">7369</span> ;</code></pre><p>会出现错误：</p><pre><code class="hljs java">视图 WITH CHECK OPTION where 子句违规</code></pre><p>因为视图的创建字段、创建条件（deptno字段），不能被修改。</p><p>但是此时，其他的字段依然允许被用户修改，但是视图中的数据并不是真实数据，为了保证其不能被修改，建议追加“WITH  READ  ONLY”的选项，将其配置为“只读”视图。</p><pre><code class="hljs java">CREATE OR REPLACE VIEW myviewASSELECT * FROM emp WHERE deptno=<span class="hljs-number">20</span>WITH READ ONLY ;</code></pre><p>删除视图：</p><pre><code class="hljs java">DROP VIEW myview;</code></pre><p>在视图的使用过程中，都建议使用只读模式。</p><h2 id="Oracle索引"><a href="#Oracle索引" class="headerlink" title="Oracle索引"></a>Oracle索引</h2><p>​        在数据库里面是一种相对提升数据库查询性能的，需要清楚数据库之中的限定查询的问题。</p><p>例如：</p><p>查询工资高于1500的所有雇员信息</p><pre><code class="hljs java">SELECT * FROM emp WHERE sal&gt;<span class="hljs-number">1500</span> ;</code></pre><p>如果想要观察查询的处理过程，可以通过管理员账户，启动一个轨迹的追踪器：</p><ol><li><p>切换账户：</p><pre><code class="hljs java">conn sys / change_on_install as sysdba;</code></pre></li><li><p>打开执行追踪器：</p><pre><code class="hljs java">SET AUTOTRACE ON;</code></pre><p>再次执行查询，默认情况下，数据采用的是全表扫描（逐行扫描 TABLE ACCESS FULL），这种情况下，如果数据量很大，那么执行的速度就会很慢，而解决此问题的方法是，形成一棵树。</p><p>​        这棵树取第一个数据作为根节点，而后比根节点小的数据放在左边，比根节点大的数据放在右边。</p><p>在数据库中，对于索引的创建有两种形式：</p><ol><li><p>当数据列上使用了主键约束或者唯一约束的时候，自动创建索引</p></li><li><p>自己手动设置一个查询的字段，手动创建索引</p><p>例如：</p><p>在sal的字段上设置索引</p><pre><code class="hljs java">CREATE INDEX scott.emp_sal_ind ON scott.emp(sal) ;</code></pre></li></ol></li></ol><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>SQL语句有三个方面：DML、DDL、DCL。其中DCL指的就是数据库的控制语言，也就是说进行权限控制的处理操作，在DCL中，主要有两个语法：</p><ol><li>GRANT：授权</li><li>REVOEK：回收</li></ol><p>如果想要正常的使用DCL还是需要结合用户来完成，而用户在数据库之中被称为对象。</p><ol><li><p>如果要进行用户对象的维护，一定要采用管理员账户登录，本次使用sys登录：</p><pre><code class="hljs java">conn sys / change_on_install as sysdba;</code></pre></li><li><p>创建一个新的用户：dog / wangwang</p><pre><code class="hljs java">CREATE USER dog IDENTIFIED BY wangwang;</code></pre><p>随后启动一个新的sqlPlus客户端进行用户的登录，但是，此时会：</p><pre><code class="hljs java">ORA-<span class="hljs-number">01045</span>: user DOG lacks CREATE SESSION privilege; logon denied警告: 您不再连接到 ORACLE。</code></pre><p>此时该用户只是一个普通的dog用户，但是这个dog用户并没有任何的权限，本次缺少的是“CREATE  SESSION”的权限，也就表明用户无法创建session（无法登录），</p></li><li><p>将创建session的权限授予dog用户（由超级管理员进行）</p><pre><code class="hljs java">GRANT CREATE SESSION TO dog;</code></pre><p>授权成功之后，就可以进行1dog用户的登录处理操作了。</p><p>但是此时，如果进行序列的创建或者表的创建的话，会出现</p><pre><code class="hljs java">ORA-<span class="hljs-number">01031</span>: 权限不足</code></pre><p>在Oracle中，提供了两个角色（每一个角色包含多个权限）：</p><ol><li>CONNECT</li><li>RESOURCE</li></ol><p>最简单的做法是，将这个两个角色授予dog用户：</p><pre><code class="hljs jav">GRANT CONNECT, RESOURCE TO dog;</code></pre><p>授权完成之后，需要重新登录</p></li><li><p>一旦有了用户的产生之后，就会出现一些用户的维护：</p><ul><li><p>重置用户密码：</p><pre><code class="hljs java">ALTER USER dog IDENTIFIED BY miaomiao;</code></pre></li><li><p>让密码失效：</p><pre><code class="hljs java">ALTER USER dog PASSWORD EXPIRE;</code></pre></li><li><p>锁定用户：</p><pre><code class="hljs java">ALTER USER dog ACCOUNT LOCK;</code></pre><p>登陆时会出现：</p><pre><code class="hljs java">ORA-<span class="hljs-number">28000</span>: the account is locked</code></pre></li><li><p>解锁：</p><pre><code class="hljs java">ALTER USER dog ACCOUNT UNLOCK;</code></pre></li></ul></li><li><p>如果不同用户之间要进行访问，那么必须具有其他用户的对象权限，而对象权限一共有四种：</p><ul><li>SELECT </li><li>UPDATE</li><li>DELETE</li><li>INSERT</li></ul><p>例如：</p><p>将scott.emp表的SELECT、INSERT权限授予dog用户</p><pre><code class="hljs java">GRANT SELECT, INSERT on scott.emp TO dog;</code></pre><p>​        此时就可以访问到scott.emp</p></li><li><p>进行对象权限的回收</p><pre><code class="hljs java">REVOKE select, insert on scott.emp from dog;</code></pre><p>此时就不可以再进行查询</p></li></ol><p>   回收CONNECT、RESOURCE的角色</p>   <pre><code class="hljs JAVA">REVOKE CONNECT, RESOURCE FROM dog;</code></pre><p>   回收连接的权限</p>   <pre><code class="hljs java">REVOKE CREATE SESSION FROM dog;</code></pre><p>   此时，不可以再进行连接。</p><ol start="7"><li><p>删除用户</p><pre><code class="hljs java">DROP USER dog CASCADE;</code></pre><p>用户有可能由各种对象的创建，所以在删除的时候一定要将这些遗留的内容一起清除掉，要加上CASCADE。</p></li></ol><h2 id="数据库的备份"><a href="#数据库的备份" class="headerlink" title="数据库的备份"></a>数据库的备份</h2><ol><li><p>数据的导出与导入（开发中进行）</p><p>将数据导出到d:\backup目录之中</p><ul><li><p>建立一个目录：mkdir  backup；</p></li><li><p>进入到“d:\backup”目录中</p><pre><code class="hljs java">cd backup</code></pre></li><li><p>执行一个数据导出命令：exp;</p><ol><li><p>输入要导出数据的用户名</p></li><li><p>设置一个导出的文件名称，默认为：“导出文件: EXPDAT.DMP”</p></li><li><p>导出全部数据表：</p><p>“U（将该用户下的表都导出）”</p></li></ol></li></ul></li><li><p>数据的导入：</p><ul><li>进入到备份文件所在的路径：“d:\backup”</li><li>执行“imp”的指令</li></ul><p>不适合导数据很大的文件</p></li></ol><h2 id="数据库冷备份"><a href="#数据库冷备份" class="headerlink" title="数据库冷备份"></a>数据库冷备份</h2><p>   ​        是数据库较为全面的数据库的处理模式，利用数据库冷备份的操作可以保证所有的数据都是归档数据。需要清除数据库的存储结构。</p><p>   ​        Oracle数据库是以文件形式进行存储的，也就是说在一块磁盘上会划分出不同的文件区，而后每一个文件区里面可以保存相应的数据。</p><ul><li><p>备份控制文件，控制整个Oracle数据库的服务信息</p><p>通过“v$controlfile”获得</p></li><li><p>备份重做日志文件</p><p>通过“v$logfile”数据字典获得</p></li><li><p>数据文件</p><p>保存真实的数据信息，通过“v$datafile”数据字典获得</p></li><li><p>核心配置文件（pfile）</p><p>整个Oracle的核心参数</p><p>例如:</p><p>查看控制文件的路径：</p><p>需要使用sys账户</p><pre><code class="hljs java">SELECT * FROM v$controlfile;</code></pre><pre><code class="hljs java">D:\ORACLE\ORACLE\ORADATA\ORCL\CONTROL01.CTL</code></pre><p>查看日志文件的路径：</p><pre><code class="hljs java">SELECT * FROM v$logfile;</code></pre><pre><code class="hljs java">D:\ORACLE\ORACLE\ORADATA\ORCL\REDO03.LOG</code></pre><p>查看数据文件的路径：</p><pre><code class="hljs java">SELECT * FROM v$datafile;</code></pre><pre><code class="hljs java">D:\ORACLE\ORACLE\ORADATA\ORCL\SYSTEM01.DBF</code></pre><p>查看核心配置文件（pfile）的目录：</p><pre><code class="hljs java">show parameter pfile;</code></pre><pre><code class="hljs java">D:\ORACLE\ORACLE\PRODUCT\<span class="hljs-number">11.2</span><span class="hljs-number">.0</span>\DBHOME_1\DATABASE\SPFILEORCL.ORA</code></pre><p>Oracle最核心的配置</p><p>​    </p><p>关闭Oracle的服务</p><pre><code class="hljs java">SHUTDOWN IMMEDIATE<span class="hljs-comment">//立即执行，不等待</span></code></pre><p>将之前记录好的路径文件都拷贝到其他磁盘上</p><p>恢复Oracle数据库的实例</p><pre><code class="hljs java">STARTUP</code></pre><p>这种数据库备份的前提要求是允许你关闭服务。</p><p>如果是一些公共的服务，就不能关闭服务进行此操作，只能进行热备份，最简单的热备份模式就是做一个主从关系。</p></li></ul><h2 id="数据库的设计范式"><a href="#数据库的设计范式" class="headerlink" title="数据库的设计范式"></a>数据库的设计范式</h2><p>​        数据库的设计范式，其核心的本质在于可以设计出方便扩展，而且存储精准的数据结构，并且可以有效的满足程序开发的需求。但是从另外一个层次来讲，数据库设计没有模式，核心：保证数据有效存储，保证查询性能。</p><ol><li><p>第一设计范式</p><p>设计要求：数据表中的每个字段不可再分</p><p>例如：</p><p>设计一个表示用户的数据表</p><pre><code class="hljs java">CREATE TABLE 用户 (用户编号NUMBER ,姓名VARCHAR2(<span class="hljs-number">20</span>) ,联系方式VARCHAR2(<span class="hljs-number">200</span>) ,CONSTRAINT pk_用户编号 <span class="hljs-function">PRIMARY <span class="hljs-title">KEY</span><span class="hljs-params">(用户编号)</span></span><span class="hljs-function">) </span>;</code></pre><p>而此设计中，最大的败笔在于联系方式上，因为从实际的使用角度来讲，联系方式是可以进一步进行拆分的，例如：电话</p><p>email、城市、住址、邮编……所以并不符合第一设计范式，因为有的字段还可以进行拆分，所以以下设计是符合第一设计范式要求的：</p><pre><code class="hljs java">CREATE TABLE 用户 (用户编号NUMBER ,姓名VARCHAR2(<span class="hljs-number">20</span>) ,联系电话VARCHAR2(<span class="hljs-number">20</span>) ,<span class="hljs-function">email<span class="hljs-title">VARCHAR2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span> ,</span><span class="hljs-function">CONSTRAINT pk_用户编号 PRIMARY <span class="hljs-title">KEY</span><span class="hljs-params">(用户编号)</span></span><span class="hljs-function">) </span>;</code></pre><p>而此设计每一个字段无法再进行划分，所以该设计属于第一设计范式的要求。</p><p>对于第一设计范式，需要注意的是：</p><ul><li><p>再中国姓名就是姓名，而国外飞鸟为姓（firstName）名（lastName）</p></li><li><p>在设计的时候应该尽量使用数据库支持的几种数据类型（字符串、数字、日期、大文本），不要将日期拆分为独立的年、月、日来保存，例如：</p><pre><code class="hljs java">CREATE TABLE 用户 (用户编号NUMBER ,姓名VARCHAR2(<span class="hljs-number">20</span>) ,生日_年NUMBER(<span class="hljs-number">4</span>) ,生日_月NUMBER(<span class="hljs-number">2</span>)  ,生日_日NUMBER(<span class="hljs-number">2</span>)  ,<span class="hljs-function">email<span class="hljs-title">VARCHAR2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span> ,</span><span class="hljs-function">CONSTRAINT pk_用户编号 PRIMARY <span class="hljs-title">KEY</span><span class="hljs-params">(用户编号)</span></span><span class="hljs-function">) </span>;<span class="hljs-comment">//这样设计很不好！</span></code></pre></li></ul></li></ol><ol start="2"><li><p>第二设计范式</p><p>设计原则：数据表中不存在非关键字段对于任一候选关键字的部分函数依赖。</p><p>理解：</p><ul><li>函数关系</li></ul><pre><code class="hljs java">CREATE TABLE 订单 (订单编号NUMBER ,订单日期DATE ,商品单价NUMBER ,商品数量NUMBER ,商品总价 NUMBER) ;</code></pre><p>这个时候，这些字段之间彼此存在有函数依赖关系：“商品总价 = 商品数量 * 商品总价”，所以这是不符合第二设计范式的</p><ul><li>函数依赖：不同的字段可以得到相同或者不同的结果</li></ul></li></ol><p>   再例如：</p><p>   一个学生可以选择参加多门课程，一门课程可以有多个学生参加，并且每个学生参加完每个课程都有一个自己的考试成绩。</p><p>   如果此时按照第一范式设计，其设计如下：</p>   <pre><code class="hljs java">CREATE TABLE 学生选课 (学生编号NUMBER  PRIMARY KEY 学生姓名VARCHAR2(<span class="hljs-number">50</span>),学生年龄NUMBER ,课程名称VARCHAR2(<span class="hljs-number">50</span>) ,课程学分NUMBER ,考试成绩NUMBER) ;<span class="hljs-comment">//符合第一设计范式</span></code></pre><p>   插入信息：</p>   <pre><code class="hljs java">INSERT INTO 学生选课  VALUES (<span class="hljs-number">1</span>,<span class="hljs-string">'张三'</span>,<span class="hljs-number">18</span>,<span class="hljs-string">'oracle'</span>,<span class="hljs-number">2</span>,<span class="hljs-number">89</span>) ;INSERT INTO 学生选课  VALUES (<span class="hljs-number">2</span>,<span class="hljs-string">'李四'</span>,<span class="hljs-number">17</span>,<span class="hljs-string">'java'</span>,<span class="hljs-number">3</span>,<span class="hljs-number">69</span>) ;INSERT INTO 学生选课  VALUES (<span class="hljs-number">1</span>,<span class="hljs-string">'张三'</span>,<span class="hljs-number">18</span>,<span class="hljs-string">'java'</span>,<span class="hljs-number">3</span>,<span class="hljs-number">79</span>) ;</code></pre><p>   而此时，使用第一设计范式的时候，会出现以下几个问题：</p><ul><li><p>无法确认主键，因为一个学生可以选择多门课程</p></li><li><p>数据冗余（重复），因为一个课程的名称是不会被改变的，学分信息也是一样的</p></li><li><p>数据更新麻烦，当某一门课程的学分要更新之后，所影响到的数据行有N行</p></li><li><p>如果一门课程没有一个人选择，那么这门课程就彻底消失了</p><p>所以此时是一个多对多的处理关系</p><p>设计改进如下： </p><pre><code class="hljs java">CREATE TABLE 学生(学生IDNUMBER PRIMARY KEY ,学生姓名VARCHAR2(<span class="hljs-number">20</span>) ,学生年龄NUMBER ) ;CREATE TABLE 课程(课程ID NUMBERPRIMARY KEY ,课程名称VARCHAR2(<span class="hljs-number">50</span>) ,课程学分NUMBER ) ;CREATE TABLE 学生选课(学生ID NUMBER REFERENCES 学生(学生ID) ,课程ID NUMBER REFERENCES 课程(课程ID) ,成绩NUMBER) ;</code></pre><p>如果需要修改什么信息，就修改对应的表信息即可。</p></li></ul><ol start="3"><li><p>第三设计范式</p><p>设计原则：数据表之中，不存在非关键字段对任意候选关键字段的传递函数依赖。而实际上，传递函数依赖就好比层级关系表一样</p><p>如果采用第一设计范式进行数据表的设计，那么就有如下的结构</p><table><thead><tr><th align="center">姓名</th><th align="center">工资</th><th align="center">部门名称</th><th align="center">部门位置</th></tr></thead><tbody><tr><td align="center">SIMITH</td><td align="center">800.0</td><td align="center">ACCOUNTGING</td><td align="center">NEWYORK</td></tr></tbody></table><p>这个时候：（雇员编号）—&gt; 部门名称 —&gt; 部门位置，所以这样的设计就不符合于第三设计范式</p><p>例如：</p><p>现在需要设计一个学生和学校关系的数据库，很明显，一个学校会有多个学生</p><pre><code class="hljs java">CREATE TABLE 学校-学生 (学校IDNUMBER PRIMARY KEY ,学校名称VARCHAR2(<span class="hljs-number">50</span>) ,学校地址VARCHAR2(<span class="hljs-number">50</span>) ,学生姓名VARCHAR2(<span class="hljs-number">50</span>) ,学生年龄NUMBER) ;</code></pre><p>此为第一设计范式，会有以下问题：</p><ul><li>如果学生数量太多，那么学校名称会重复很多次，如果学校更名，此数据量是非常大的</li></ul></li></ol><p>   使用第三设计范式：</p>   <pre><code class="hljs java">CREATE TABLE 学校 (学校IDNUMBER PRIMARY KEY ,学校名称VARCHAR2(<span class="hljs-number">50</span>) ,学校地址VARCHAR2(<span class="hljs-number">50</span>)) ;CREATE TABLE 学生 (学生IDNUMBER PRIMARY KEY ,学生姓名VARCHAR2(<span class="hljs-number">50</span>) ,学生年龄NUMBER ,学校IDNUMBER REFERENCES 学校(学校ID)) ;</code></pre><p>   这一过程属于一个一对多的设计方案</p><p>总结：</p><p>第一范式就是单表设计原则，第二范式就是多对多关系，第三范式就是一对多关系</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ajax</title>
    <link href="/2020/06/07/ajax/"/>
    <url>/2020/06/07/ajax/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>AJAX</font></div><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><ol><li>在浏览器中，创建一个脚本对象，这个对象就是异步请求对象</li><li>为<strong>异步请求对象</strong>添加一个<strong>工作状态监听器</strong>，帮助开发人员确认何使从<strong>异步请求对象</strong>身上得到服务端返回的响应数据</li><li>初始化<strong>异步请求对象</strong><ul><li>第一个：通知异步请求对象采用何种方式发送<strong>请求解析包</strong>POST/GET</li><li>第二个：通知异步请求对象，本次要访问的资源文件地址</li><li>第三个：通知异步请求对象，在其工作期间，浏览器是否会等他（同步请求，异步请求）</li></ul></li><li>命令异步请求对象代替浏览器发送请求</li></ol><h3 id="同步请求和异步请求的区别"><a href="#同步请求和异步请求的区别" class="headerlink" title="同步请求和异步请求的区别"></a>同步请求和异步请求的区别</h3><ol><li>同步请求<ul><li>在当前的异步请求对象的工作期间，浏览器只能处于等待状态，直到当前异步请求对象工作完毕，浏览器才可以委派其他的异步请求对象发送请求</li></ul></li><li>异步请求：<ul><li>在当前异步请求对象工作期间，浏览器可以继续委派其他的异步请求对象发送其他的请求</li></ul></li></ol><h3 id="AJAX命令"><a href="#AJAX命令" class="headerlink" title="AJAX命令"></a>AJAX命令</h3><ol><li><p>创建异步请求对象</p><p>var xmlhttp =    new XMLHttpRequest();</p></li><li><p>绑定监听器   obj.监听器 = function(){}</p><p>xmlHttp.onreadystatechangr = function(){};</p></li><li><p>初始化异步请求对象</p><p>xmlHttp.open(“post/get”, “/myweb/oneServlet?uname=smith”, true)</p></li><li><p>命令异步请求对象代替浏览器发送请求对象</p><p>xmlHttp.send()</p></li></ol><h3 id="异步请求对象的工作状态（5种）"><a href="#异步请求对象的工作状态（5种）" class="headerlink" title="异步请求对象的工作状态（5种）"></a>异步请求对象的工作状态（5种）</h3><p>readyState属性：储存当前的工作状态</p><table><thead><tr><th align="center">XMLHttp.READYSTATE</th><th align="center">状态</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">异步请求对象已经被创建完毕</td></tr><tr><td align="center">1</td><td align="center">异步请求对象已经被初始化完毕</td></tr><tr><td align="center">2</td><td align="center">异步请求对象已经发送了协议包，如果情况正常，此时服务端应该正在处理这个请求</td></tr><tr><td align="center">3</td><td align="center">异步请求对象已经得到服务端返回的相应包，此时异步请求对象正在解析响应包中响应体的内容</td></tr><tr><td align="center">4</td><td align="center">异步请求对象已经解析数据完毕，此时数据时符合脚本规范的数据，可以提取响应数据</td></tr></tbody></table><h3 id="从异步请求对象上得到响应数据，进行局部刷新"><a href="#从异步请求对象上得到响应数据，进行局部刷新" class="headerlink" title="从异步请求对象上得到响应数据，进行局部刷新"></a>从异步请求对象上得到响应数据，进行局部刷新</h3><pre><code class="hljs java">xmlHttp.onreadystatechangr = function()&#123;    <span class="hljs-comment">//每当事件处理函数被调用，都需要询问异步请求对象当前工作状态</span>    <span class="hljs-keyword">if</span>(xmlHttp.readySatet == <span class="hljs-number">4</span> &amp;&amp; xmlHttp.status == <span class="hljs-number">200</span>)&#123;        <span class="hljs-comment">//读取响应数据</span>        <span class="hljs-keyword">var</span> data = xmlHttp.responseseText;        callBack(data);     &#125;    <span class="hljs-comment">//局部刷新实现函数</span>    <span class="hljs-function">function <span class="hljs-title">callBack</span><span class="hljs-params">(param)</span></span>&#123;        $(<span class="hljs-string">"div"</span>).text(param)    &#125;&#125;;</code></pre><p>例如：</p><pre><code class="hljs htm">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;script src&#x3D;&quot;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;js&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;function fun1()&#123;&#x2F;&#x2F;创建请求对象var xmlHttp &#x3D; new XMLHttpRequest();&#x2F;&#x2F;设置监听器xmlHttp.onreadystatechange &#x3D; function()&#123;if(xmlHttp.status &#x3D;&#x3D; 200 &amp;&amp; xmlHttp.readyState &#x3D;&#x3D; 4)&#123;var data &#x3D; xmlHttp.responseText;alert(&quot;得到的数据为：&quot; + data);callBack(data);&#125;&#125;&#x2F;&#x2F;初始化异步请求var param &#x3D; document.getElementById(&quot;dname&quot;).value;xmlHttp.open(&quot;GET&quot;, &quot;&#x2F;myWeb&#x2F;dept&#x2F;add.do?dname&#x3D;&quot; + param, true);&#x2F;&#x2F;代替浏览器发送请求对象xmlHttp.send();&#125;function callBack(data)&#123;if(data &#x3D;&#x3D; 0)&#123;document.getElementById(&quot;dname&quot;).innerText &#x3D; &quot;部门名称可以使用&quot;&#125;else&#123;document.getElementById(&quot;dname&quot;).innerText &#x3D; &quot;部门名称被占用&quot;&#125;&#125;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;center&gt;&lt;form action&#x3D;&quot;&#x2F;myWeb&#x2F;dept&#x2F;add.do&quot; method&#x3D;&quot;post&quot;&gt;部门编号：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;deptNo&quot; &#x2F;&gt;&lt;br &#x2F;&gt;部门名称：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;dname&quot; id&#x3D;&quot;dname&quot; onblur&#x3D;&quot;fun1()&quot; &#x2F;&gt;&lt;font color&#x3D;&quot;red&quot; id&#x3D;&quot;myFont&quot;&gt;*&lt;&#x2F;font&gt;&lt;br &#x2F;&gt;部门位置：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;loc&quot; &#x2F;&gt;&lt;br &#x2F;&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;添加部门&quot; &#x2F;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;center&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h3 id="将服务端高级类型对象交给异步请求对象处理"><a href="#将服务端高级类型对象交给异步请求对象处理" class="headerlink" title="将服务端高级类型对象交给异步请求对象处理"></a>将服务端高级类型对象交给异步请求对象处理</h3><ol><li><p>异步请求对象和浏览器无法解析服务端返回的高级类型对象</p></li><li><p>异步请求对象和浏览器稚嫩能够接受来自于服务端发送的基本类型数据（int, String）</p></li><li><p>只能将高级类型对象换变为<strong>标准的JSON格式字符串</strong>交给异步请求对象</p><p>（javaScript的eval函数，可以将JSON格式的字符串转变为JSON对象、或者利用JSON工具包）</p><p>使用eval()函数：</p><pre><code class="hljs html">var data = xmlHttp.responseText;//此时返回的对象就是一个JSON对象var jsonObj = eval("(" + data + ")")</code></pre><p>使用JSON工具包：</p><pre><code class="hljs html">JSONObject jsonObj = JSONObject.fromObject(XXX);</code></pre></li></ol><h3 id="jquery对ajax开发步骤的封装版"><a href="#jquery对ajax开发步骤的封装版" class="headerlink" title="jquery对ajax开发步骤的封装版"></a>jquery对ajax开发步骤的封装版</h3><p>体现思路：不需要开发人员亲自实现AJAX的四个步骤，只需要开发人员提供AJAX开发步骤需要的参数，可以让开发人员专注于<strong>局部刷新函数实现</strong></p><h3 id="ajax-的使用"><a href="#ajax-的使用" class="headerlink" title="$.ajax()的使用"></a>$.ajax()的使用</h3><p>$.ajax()是AJAX开发提供的标准简化版</p><p>使用：</p><ol><li><p>ajax（)只接受一个json对象作为参数，开发人员可以将AJAX实现需要的参数在json对象中，进行声明</p></li><li><pre><code class="hljs html">var option = &#123;typs://[作用]：通知异步请求对象采用何种方式发送请求协议包（post/get）//[赋值]：type：'get', type = 'post'//[注意]：type属性可以不声明，此时异步请求对象使用GET方式发送请求协议包url://[作用]：本次要访问的资源文件地址，要求异步请求对象将这个地址写入到请求协议包中请求行上//[赋值]：url:'/myWeb/one.do', url:'/myWeb/emp/check.do'//[注意]：url属性不能省略，url属性不能携带请求参数data://[租用]：通知异步请求对象，本次携带的请求参数//[赋值]：data属性可以接收[以字符串形式拼接的参数]   data："uname=mike&amp;pwd=123"//data属性也可以接收[json格式描述的参数]            data：&#123;                "uname":"mike",                "password":"123"            &#125;//但是两种形式的参数不可以混搭使用//[注意]：也可以不用写,如果没有携带发送的参数，可以不声明dataasync：//[作用]：设置同步请求和异步请求，简单来说就是通知浏览器在当前异步请求对象工作期间，浏览器时候可以委托其他的异步请求对象发送其他的请求//[赋值]：async：true  异步请求async：false  同步请求//[注意]：绝大多数情况下，都是使用异步请求，此时这个属性可以不用声明success：//[作用]：指定异步请求对象工作完毕后，需要调用的[局部刷新的函数名]//[赋值]：success：callBack//[注意]：只写局部刷新函数名字，不要带括号，success不能省略error：//[作用]：通知异步请求对象在接收到[400, 405, 500]等状态码的时候，需要调用的方法名//[赋值]：error：errorFun//[注意]：开发测试会写，上线不需要写dataType：//[作用]：通知[jquery]，将异步对象中读取的数据转变为何种数据类型//[赋值]：dataType：'text'，通知jquery，将异步对象中读取的数据转变为字符串dataType：'json'，通知jquery，将异步对象中读取的数据通过eval函数转换为json对象//[注意]：可以不声明，默认将异步请求对象获取到的的内容作为一个字符串输出到[局部刷新函数]中&#125;</code></pre></li></ol><h3 id="get-与-post"><a href="#get-与-post" class="headerlink" title="$.get() 与 $.post()"></a>$.get() 与 $.post()</h3><ol><li><p>介绍：</p><p>$.get()：通知异步请求对象采用GET方式发送请求</p><p>$.post()：通知异步请求对象采用POST方式发送请求</p></li><li><p>使用</p><ul><li><p>$.get（请求地址，请求参数，局部刷新函数名，需要的数据类型[text/json]）</p><p>如果只需要得到字符串类型的数据就可以使用：$.get（请求地址，请求参数，局部刷新函数名），省略最后的数据类型。</p><p>如果只需要得到字符串类型的数据，并且没有需要携带的请求参数就可以使用：$.get（请求地址，局部刷新函数名）。</p><p>Tip：只写刷新函数的名称</p></li><li><p>$.post（）同上</p></li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring(3)---AOP</title>
    <link href="/2020/05/26/Spring(3)---AOP/"/>
    <url>/2020/05/26/Spring(3)---AOP/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>Spring---AOP</font></div><h2 id="AOP基本概念"><a href="#AOP基本概念" class="headerlink" title="AOP基本概念"></a>AOP基本概念</h2><p>​        AOP：全称是 Aspect Oriented Programming 即：面向切面编程。 简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>特点：字节码随用随创建，随用随加载</p><p>作用：不修改源码的基础上对方法增强</p><p>分类：</p><ul><li>基于接口的动态代理</li><li>基于子类的动态代理</li></ul><h3 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h3><p>基于接口的动态代理：</p><p>涉及的类：Proxy</p><p>提供者：JDK官方</p><p>如何创建代理对象：</p><ul><li>使用Proxy类中的newProxyInstance方法</li></ul><p>创建代理对象的要求：</p><ul><li>被代理类<strong>最少实现一个接口</strong>，如果没有则不能使用</li></ul><p>newProxyInstance方法的参数：</p><ul><li><p>ClassLoader：类加载器</p><p>它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法</p></li><li><p>Class[]：字节码数组</p><p>它是用于让代理对象和被代理对象有相同方法。固定写法。</p></li></ul><p>InvocationHandler：用于提供增强的代码</p><p>它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。</p><p>此接口的实现类都是谁用谁写。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">final</span> Producer producer = <span class="hljs-keyword">new</span> Producer();               IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),                producer.getClass().getInterfaces(),                <span class="hljs-keyword">new</span> InvocationHandler() &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 作用：执行被代理对象的任何接口方法都会经过该方法</span><span class="hljs-comment">     * 方法参数的含义</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> proxy   代理对象的引用</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method  当前执行的方法</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args    当前执行方法所需的参数</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>        和被代理对象方法有相同的返回值</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable</span><span class="hljs-comment">     */</span>                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;                        <span class="hljs-comment">//提供增强的代码</span>                        Object returnValue = <span class="hljs-keyword">null</span>;                        <span class="hljs-comment">//1.获取方法执行的参数</span>                        Float money = (Float)args[<span class="hljs-number">0</span>];                        <span class="hljs-comment">//2.判断当前方法是不是销售</span>                        <span class="hljs-keyword">if</span>(<span class="hljs-string">"saleProduct"</span>.equals(method.getName())) &#123;                            returnValue = method.invoke(producer, money*<span class="hljs-number">0.8f</span>);                        &#125;                        <span class="hljs-keyword">return</span> returnValue;                    &#125;                &#125;);        proxyProducer.saleProduct(<span class="hljs-number">10000f</span>);    &#125;&#125;</code></pre><h3 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h3><p>基于子类的动态代理：</p><p>涉及的类：Enhancer</p><p>提供者：第三方cglib库</p><p>如何创建代理对象：</p><ul><li>使用Enhancer类中的create方法</li></ul><p>创建代理对象的要求：</p><ul><li><strong>被代理类不能是最终类</strong></li></ul><p>create方法的参数：</p><ul><li><p>Class：字节码</p><p>它是用于指定被代理对象的字节码。</p></li><li><p>Callback：用于提供增强的代码</p><p>它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。</p></li></ul><p>此接口的实现类都是谁用谁写。</p><p>我们一般写的都是该接口的子接口实现类：MethodInterceptor</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">final</span> Producer producer = <span class="hljs-keyword">new</span> Producer();        Producer cglibProducer = (Producer)Enhancer.create(producer.getClass(), <span class="hljs-keyword">new</span> MethodInterceptor() &#123;            <span class="hljs-comment">/**</span><span class="hljs-comment">             * 执行北地阿里对象的任何方法都会经过该方法</span><span class="hljs-comment">             * <span class="hljs-doctag">@param</span> proxy</span><span class="hljs-comment">             * <span class="hljs-doctag">@param</span> method</span><span class="hljs-comment">             * <span class="hljs-doctag">@param</span> args</span><span class="hljs-comment">             *    以上三个参数和基于接口的动态代理中invoke方法的参数是一样的</span><span class="hljs-comment">             * <span class="hljs-doctag">@param</span> methodProxy ：当前执行方法的代理对象</span><span class="hljs-comment">             * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">             * <span class="hljs-doctag">@throws</span> Throwable</span><span class="hljs-comment">             */</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;                <span class="hljs-comment">//提供增强的代码</span>                Object returnValue = <span class="hljs-keyword">null</span>;                <span class="hljs-comment">//1.获取方法执行的参数</span>                Float money = (Float)args[<span class="hljs-number">0</span>];                <span class="hljs-comment">//2.判断当前方法是不是销售</span>                <span class="hljs-keyword">if</span>(<span class="hljs-string">"saleProduct"</span>.equals(method.getName())) &#123;                    returnValue = method.invoke(producer, money*<span class="hljs-number">0.8f</span>);                &#125;                <span class="hljs-keyword">return</span> returnValue;            &#125;        &#125;);        cglibProducer.saleProduct(<span class="hljs-number">12000f</span>);    &#125;&#125;</code></pre><p>需引入；</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1_3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><h2 id="基于xml的AOP配置"><a href="#基于xml的AOP配置" class="headerlink" title="基于xml的AOP配置"></a>基于xml的AOP配置</h2><p>配置步骤：</p><ol><li>把通知Bean也交给spring来管理</li><li>使用aop:config标签表明开始AOP的配置</li><li>使用aop:aspect标签表明配置切面<pre><code>id属性：是给切面提供一个唯一标识ref属性：是指定通知类bean的Id。</code></pre></li><li>在aop:aspect标签的内部使用对应标签来配置通知的类型<pre><code>我们现在示例是让printLog方法在切入点方法执行之前之前：所以是前置通知 aop:before：表示配置前置通知 method属性：用于指定Logger类中哪个方法是前置通知 pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强</code></pre></li></ol><p>切入点表达式的写法：<br>        关键字：execution(表达式)<br>        表达式：<br>            访问修饰符  返回值  包名.包名.包名…类名.方法名(参数列表)</p><p>全通配写法：</p><pre><code class="hljs java">* *..*.*(..)</code></pre><p>实际开发中切入点表达式的通常写法：<br>            切到业务层实现类下的所有方法:</p><pre><code class="hljs java">* com.itheima.service.impl.*.*(..)</code></pre><p>比如:</p><pre><code class="hljs java">&lt;!-- 配置srping的Ioc,把service对象配置进来--&gt;    &lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt;&lt;/bean&gt;      &lt;aop:before method="printLog" pointcut="execution(* com.itheima.service.impl.*.*(..))"&gt;&lt;/aop:before&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;</code></pre><p>AOP配置各种通知：</p><pre><code class="hljs java">&lt;!--配置AOP--&gt;    &lt;aop:config&gt;        &lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容              此标签写在aop:aspect标签内部只能当前切面使用。              它还可以写在aop:aspect外面，此时就变成了所有切面可用          --&gt;        &lt;aop:pointcut id="pt1" expression="execution(* com.itheima.service.impl.*.*(..))"&gt;&lt;/aop:pointcut&gt;        &lt;!--配置切面 --&gt;        &lt;aop:aspect id=<span class="hljs-string">"logAdvice"</span> ref=<span class="hljs-string">"logger"</span>&gt;            &lt;!-- 配置前置通知：在切入点方法执行之前执行            &lt;aop:before method="beforePrintLog" pointcut-ref="pt1" &gt;&lt;/aop:before&gt;--&gt;            &lt;!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个            &lt;aop:after-returning method="afterReturningPrintLog" pointcut-ref="pt1"&gt;&lt;/aop:after-returning&gt;--&gt;            &lt;!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个            &lt;aop:after-throwing method="afterThrowingPrintLog" pointcut-ref="pt1"&gt;&lt;/aop:after-throwing&gt;--&gt;            &lt;!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行            &lt;aop:after method="afterPrintLog" pointcut-ref="pt1"&gt;&lt;/aop:after&gt;--&gt;            &lt;!-- 配置环绕通知 详细的注释请看Logger类中--&gt;            &lt;aop:around method="aroundPringLog" pointcut-ref="pt1"&gt;&lt;/aop:around&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;</code></pre><h3 id="基于注解的AOP配置"><a href="#基于注解的AOP配置" class="headerlink" title="基于注解的AOP配置"></a>基于注解的AOP配置</h3><pre><code class="hljs java"><span class="hljs-meta">@Component</span>(<span class="hljs-string">"logger"</span>)<span class="hljs-meta">@Aspect</span><span class="hljs-comment">//表示当前类是一个切面类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123;    <span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.itheima.service.impl.*.*(..))"</span>)    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pt1</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 前置通知</span><span class="hljs-comment">     */</span><span class="hljs-comment">//    @Before("pt1()")</span>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">beforePrintLog</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"前置通知Logger类中的beforePrintLog方法开始记录日志了。。。"</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 后置通知</span><span class="hljs-comment">     */</span><span class="hljs-comment">//    @AfterReturning("pt1()")</span>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturningPrintLog</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"后置通知Logger类中的afterReturningPrintLog方法开始记录日志了。。。"</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 异常通知</span><span class="hljs-comment">     */</span><span class="hljs-comment">//    @AfterThrowing("pt1()")</span>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowingPrintLog</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。"</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 最终通知</span><span class="hljs-comment">     */</span><span class="hljs-comment">//    @After("pt1()")</span>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">afterPrintLog</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"最终通知Logger类中的afterPrintLog方法开始记录日志了。。。"</span>);    &#125;</code></pre><p>关于环绕通知：</p><p>​        它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。</p><pre><code class="hljs java"><span class="hljs-meta">@Around</span>(<span class="hljs-string">"pt1()"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">aroundPringLog</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span></span>&#123;        Object rtValue = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span>&#123;            Object[] args = pjp.getArgs();<span class="hljs-comment">//得到方法执行所需的参数</span>            System.out.println(<span class="hljs-string">"Logger类中的aroundPringLog方法开始记录日志了。。。前置"</span>);            rtValue = pjp.proceed(args);<span class="hljs-comment">//明确调用业务层方法（切入点方法）</span>            System.out.println(<span class="hljs-string">"Logger类中的aroundPringLog方法开始记录日志了。。。后置"</span>);            <span class="hljs-keyword">return</span> rtValue;        &#125;<span class="hljs-keyword">catch</span> (Throwable t)&#123;            System.out.println(<span class="hljs-string">"Logger类中的aroundPringLog方法开始记录日志了。。。异常"</span>);            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(t);        &#125;<span class="hljs-keyword">finally</span> &#123;            System.out.println(<span class="hljs-string">"Logger类中的aroundPringLog方法开始记录日志了。。。最终"</span>);        &#125;    &#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring(2)---IOC配置和注解</title>
    <link href="/2020/05/26/Spring(2)---IOC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%B3%A8%E8%A7%A3/"/>
    <url>/2020/05/26/Spring(2)---IOC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>Spring---IOC配置和注解</font></div><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>之前的xml配置写法：</p><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">"accountService"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl"</span>         scope=<span class="hljs-string">""</span>  init-method=<span class="hljs-string">""</span> destroy-method=<span class="hljs-string">""</span>&gt;       &lt;property name=""  value="" | ref=""&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h2 id="用于创建对象的注解"><a href="#用于创建对象的注解" class="headerlink" title="用于创建对象的注解"></a>用于创建对象的注解</h2><p>他们的作用就和在XML配置文件中编写一个<bean>标签实现的功能是一样的</p><p>Component:</p><ul><li><p>作用：用于把当前类对象存入spring容器中</p></li><li><p>属性：</p><p>value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。</p></li></ul><p>Controller：一般用在表现层</p><p>Service：一般用在业务层</p><p>Repository：一般用在持久层</p><p>以上三个注解他们的作用和属性与Component是一模一样。</p><p>他们三个是spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰</p><h3 id="用于注入数据"><a href="#用于注入数据" class="headerlink" title="用于注入数据"></a><strong>用于注入数据</strong></h3><p>他们的作用就和在xml配置文件中的bean标签中写一个<property>标签的作用是一样的</p><p>Autowired:</p><ul><li><p>作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功</p><p>​            如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。</p><p>​            如果Ioc容器中有多个类型匹配时：</p></li><li><p>出现位置：</p><p>​            可以是变量上，也可以是方法上</p></li><li><p>细节：</p><p>​            在使用注解注入时，set方法就不是必须的了。</p></li></ul><p>Qualifier:</p><ul><li><p>作用：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时            <strong>不能单独</strong>使用。但是在给方法参数注入时可以（稍后我们讲）</p></li><li><p>属性：</p><p>​            value：用于指定注入bean的id。</p></li></ul><p>Resource</p><ul><li><p>作用：直接按照bean的id注入。它可以独立使用</p></li><li><p>属性：</p><p>​            name：用于指定bean的id。</p><p>以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。</p><p>另外，集合类型的注入只能通过XML来实现。</p></li></ul><p>Value</p><ul><li><p>作用：用于注入基本类型和String类型的数据</p></li><li><p>属性：</p><p>​            value：用于指定数据的值。它可以使用spring中SpEL(也就是spring的el表达式）SpEL的写法：${表达式}</p></li></ul><h3 id="用于改变作用范围"><a href="#用于改变作用范围" class="headerlink" title="用于改变作用范围"></a><strong>用于改变作用范围</strong></h3><p>他们的作用就和在bean标签中使用scope属性实现的功能是一样的</p><ul><li><p>Scope</p><p>​            作用：用于指定bean的作用范围</p></li><li><p>属性：</p><p>​            value：指定范围的取值。常用取值：singleton、prototype</p></li></ul><p>和生命周期相关 了解</p><ul><li><p>他们的作用就和在bean标签中使用init-method和destroy-methode的作用是一样的</p><p>​            PreDestroy</p><p>​            作用：用于指定销毁方法</p><p>​            PostConstruct</p><p>​            作用：用于指定初始化方法</p></li></ul><p>例如：</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span>(<span class="hljs-string">"accountService"</span>)<span class="hljs-comment">//@Scope("prototype")</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAccountService</span> </span>&#123;<span class="hljs-comment">//    @Autowired</span><span class="hljs-comment">//    @Qualifier("accountDao1")</span>    <span class="hljs-meta">@Resource</span>(name = <span class="hljs-string">"accountDao2"</span>)    <span class="hljs-keyword">private</span> IAccountDao accountDao = <span class="hljs-keyword">null</span>;    <span class="hljs-meta">@PostConstruct</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"初始化方法执行了"</span>);    &#125;    <span class="hljs-meta">@PreDestroy</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"销毁方法执行了"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">saveAccount</span><span class="hljs-params">()</span></span>&#123;        accountDao.saveAccount();    &#125;&#125;</code></pre><p>可以在spring.xml中配置要扫描的包</p><pre><code class="hljs java">&lt;!--告知spring在创建容器时要扫描的包，配置所需要的标签不是在beans的约束中，而是一个名称为context名称空间和约束中--&gt;    &lt;context:component-scan base-package="edu.kmust"&gt;&lt;/context:component-scan&gt;</code></pre><p>spring管理bean方式的比较：</p><p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/spring%E7%AE%A1%E7%90%86bean%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83.PNG" srcset="/img/loading.gif" alt="spring管理bean方式比较"></p><h2 id="使用全注解方式时，会用到的注解"><a href="#使用全注解方式时，会用到的注解" class="headerlink" title="使用全注解方式时，会用到的注解"></a>使用全注解方式时，会用到的注解</h2><p>Configuration</p><ul><li>作用：指定当前类是一个配置类</li><li>细节：当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写。</li></ul><p>ComponentScan</p><ul><li><p>作用：用于通过注解指定spring在创建容器时要扫描的包</p></li><li><p>属性：</p><p>​            value：它和basePackages的作用是一样的，都是用于指定创建容器时要扫描的包。</p><p>​            我们使用此注解就等同于在xml中配置了:</p><pre><code class="hljs java">&lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt;</code></pre></li></ul><p>Bean</p><ul><li><p>作用：用于把<strong>当前方法</strong>的返回值作为bean对象存入spring的ioc容器中</p></li><li><p>属性:</p><p>​            name:用于指定bean的id。当不写时，默认值是当前方法的名称</p></li><li><p>细节：</p><p>​            当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象。</p></li><li><p>查找的方式和Autowired注解的作用是一样的</p></li></ul><p>Import</p><ul><li><p>作用：用于导入其他的配置类</p></li><li><p>属性：</p><p>​            value：用于指定其他配置类的字节码。</p><p>​            当我们使用Import的注解之后，有Import注解的类就父配置类，而导入的都是子配置类</p></li></ul><p>PropertySource</p><ul><li><p>作用：用于指定properties文件的位置</p></li><li><p>属性：</p><p>​            value：指定文件的名称和路径。</p></li><li><p>关键字：classpath，表示类路径下</p></li></ul><pre><code class="hljs java"><span class="hljs-comment">//@Configuration</span><span class="hljs-meta">@ComponentScan</span>(<span class="hljs-string">"com.itheima"</span>)<span class="hljs-meta">@Import</span>(JdbcConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>@PropertySource("classpath:jdbcConfig.properties")<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfiguration</span> </span>&#123;&#125;</code></pre><h3 id="junit整合"><a href="#junit整合" class="headerlink" title="junit整合"></a>junit整合</h3><p>用Junit单元测试：测试我们的配置</p><ul><li><p>Spring整合junit的配置</p><ul><li>导入spring整合junit的jar(坐标)    </li><li>使用Junit提供的一个注解把原有的main方法替换了，替换成spring提供的</li></ul></li><li><p>@Runwith</p><ul><li>告知spring的运行器，spring和ioc创建是基于xml还是注解的，并且说明位置</li></ul></li><li><p>@ContextConfiguration</p><ul><li>locations：指定xml文件的位置，加上classpath关键字，表示在类路径下</li><li>classes：指定注解类所在地位置</li></ul><p>当我们使用spring 5.x版本的时候，要求junit的jar必须是4.12及以上</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring(1)---IOC</title>
    <link href="/2020/05/26/Spring(1)---IOC/"/>
    <url>/2020/05/26/Spring(1)---IOC/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>Spring---IOC</font></div><hr><h2 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h2><p>​      Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control： 反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>方便解耦，简化开发 </li><li>AOP编程的支持 </li><li>声明式事务的支持 </li><li>方便程序的测试 </li><li>方便集成各种优秀框架 </li><li>降低 JavaEE API的使用难度 </li><li>Java源码是经典学习范例</li></ol><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>控制反转-Inversion Of Control </p><p>ioc的作用： </p><p>削减计算机程序的耦合(解除我们代码中的依赖关系)。 </p><h3 id="IOC解决程序耦合"><a href="#IOC解决程序耦合" class="headerlink" title="IOC解决程序耦合"></a>IOC解决程序耦合</h3><ol><li><p>准备必要的jar包</p></li><li><p>在根路径下创建一个xml文件（不可以是中文）,导入约束</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag"> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag"> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></li><li><p>让spring管理资源，也就是在配置文件中进行相应的配置，使其可以创建对象，并存入ioc容器中</p><p>使用了bean标签 </p><p>id属性：对象唯一标识</p><p>class属性：指定要创建对象的全限定类名</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置 service --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span> <span class="hljs-comment">&lt;!-- 配置 dao --&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountDao"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.dao.impl.AccountDaoImpl"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  <span class="hljs-comment">//1.获取核心容器对象</span><span class="hljs-comment">//        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");</span>        ClassPathXmlApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"bean.xml"</span>);        <span class="hljs-comment">//2.根据id获取Bean对象</span>        IAccountService as  = (IAccountService)ac.getBean(<span class="hljs-string">"accountService"</span>);        as.saveAccount();        <span class="hljs-comment">//手动关闭容器</span>        ac.close();    &#125;</code></pre><h3 id="IOC细节"><a href="#IOC细节" class="headerlink" title="IOC细节"></a>IOC细节</h3><ul><li>BeanFactory和 ApplicationContext 的区别 </li></ul><pre><code class="hljs xml">BeanFactory 才是 Spring 容器中的顶层接口。ApplicationContext 是它的子接口。BeanFactory 和 ApplicationContext 的区别： 创建对象的时间点不一样。   ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。   BeanFactory：什么使用什么时候创建对象。</code></pre><ul><li>ApplicationContext 接口的实现类 </li></ul><pre><code class="hljs xml">ClassPathXmlApplicationContext：它是从类的根路径下加载配置文件  推荐使用这种 FileSystemXmlApplicationContext：它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 AnnotationConfigApplicationContext: 当我们使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</code></pre><h3 id="ICO中bean标签管理对象的细节"><a href="#ICO中bean标签管理对象的细节" class="headerlink" title="ICO中bean标签管理对象的细节"></a>ICO中bean标签管理对象的细节</h3><p>创建bean的三种方式</p><ol><li>使用默认构造函数创建</li></ol><pre><code class="hljs xml">在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时。采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><ol start="2"><li>使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入IOC中）</li></ol><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 模拟一个工厂类（该类可能是存在于jar包中的，我们无法通过修改源码的方式来提供默认构造函数）</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> IAccountService <span class="hljs-title">getAccountService</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AccountServiceImpl();    &#125;&#125;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"instanceFactory"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.factory.InstanceFactory"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"instanceFactory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getAccountService"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><ol start="3"><li>使用工厂中的<strong>静态方法</strong>创建对象（使用某个类中的<strong>静态方法</strong>创建对象，并存入IOC中）</li></ol><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 模拟一个工厂类（该类可能是存在于jar包中的，我们无法通过修改源码的方式来提供默认构造函数）</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IAccountService <span class="hljs-title">getAccountService</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AccountServiceImpl();    &#125;&#125;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.factory.StaticFactory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getAccountService"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>bean标签的作用范围</p><pre><code class="hljs xml">bean标签的scope属性：作用：用于指定bean的作用范围取值： 常用的就是单例的和多例的singleton：单例的（默认值）prototype：多例的request：作用于web应用的请求范围session：作用于web应用的会话范围global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl"</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"prototype"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>bean标签的生命周期</p><pre><code class="hljs xml">bean对象的生命周期单例对象出生：当容器创建时对象出生活着：只要容器还在，对象一直活着死亡：容器销毁，对象消亡,destory需要手动调用总结：单例对象的生命周期和容器相同 多例对象出生：当我们使用对象时spring框架为我们创建活着：对象只要是在使用过程中就一直活着。死亡：当对象长时间不用，且没有别的对象引用时，由Java的垃圾回收器回收</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAccountService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountServiceImpl</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"对象创建了"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">saveAccount</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"service中的saveAccount方法执行了。。。"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"对象初始化了。。。"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"对象销毁了。。。"</span>);    &#125;&#125;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl"</span></span><span class="hljs-tag">          <span class="hljs-attr">scope</span>=<span class="hljs-string">"prototype"</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">"init"</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">"destroy"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><h3 id="spring的依赖注入"><a href="#spring的依赖注入" class="headerlink" title="spring的依赖注入"></a>spring的依赖注入</h3><p>​        依赖注入：Dependency Injection。它是 spring 框架核心 ioc 的具体实现。依赖注入：Dependency Injection。它是 spring 框架核心 ioc 的具体实现。依赖关系的管理都交给spring来维护，在当前类需要用到其他类的对象，有spring来提供，我们只需要在配置文件中说明</p><p>依赖注入能注入的数据有三类：基本类型和String，其他bean类型，复杂（集合）类型</p><p>注入方式有三种：</p><ol><li>使用构造函数   </li></ol><pre><code class="hljs xml">使用的标签:constructor-arg标签出现的位置：bean标签的内部标签中的属性type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始name：用于指定给构造函数中指定名称的参数赋值常用的=============以上三个用于指定给构造函数中哪个参数赋值===============================value：用于提供基本类型和String类型的数据ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。弊端：改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"泰斯特"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"18"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"birthday"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"now"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置一个日期对象 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"now"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"java.util.Date"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>涉及到的类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAccountService</span> </span>&#123;    <span class="hljs-comment">//如果是经常变化的数据，并不适用于注入的方式</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> Date birthday;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountServiceImpl</span><span class="hljs-params">(String name,Integer age,Date birthday)</span></span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;        <span class="hljs-keyword">this</span>.birthday = birthday;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">saveAccount</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"service中的saveAccount方法执行了。。。"</span>+name+<span class="hljs-string">","</span>+age+<span class="hljs-string">","</span>+birthday);    &#125;&#125;</code></pre><ol start="2"><li>set方法注入（较为常用）</li></ol><pre><code class="hljs xml">涉及的标签：property        出现的位置：bean标签的内部        标签的属性            name：用于指定注入时所调用的set方法名称            value：用于提供基本类型和String类型的数据            ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象        优势：            创建对象时没有明确的限制，可以直接使用默认构造函数        弊端：            如果有某个成员必须有值，则获取对象是有可能set方法没有执行。</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService2"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl2"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"TEST"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"21"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"birthday"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"now"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>涉及的类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAccountService</span> </span>&#123;    <span class="hljs-comment">//如果是经常变化的数据，并不适用于注入的方式</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> Date birthday;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBirthday</span><span class="hljs-params">(Date birthday)</span> </span>&#123;        <span class="hljs-keyword">this</span>.birthday = birthday;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">saveAccount</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"service中的saveAccount方法执行了。。。"</span>+name+<span class="hljs-string">","</span>+age+<span class="hljs-string">","</span>+birthday);    &#125;&#125;</code></pre><ol start="3"><li>复杂类型/集合类型注入</li></ol><pre><code class="hljs xml">用于给List结构集合注入的标签：list array set用于个Map结构集合注入的标签:map  props结构相同，标签可以互换</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService3"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl3"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myStrs"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>AAA<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>BBB<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>CCC<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myList"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>AAA<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>BBB<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>CCC<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mySet"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>AAA<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>BBB<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>CCC<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myMap"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"testC"</span>&gt;</span>ccc<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"testD"</span>&gt;</span>ddd<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myProps"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"testA"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"aaa"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"testB"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>BBB<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>涉及的类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAccountService</span> </span>&#123;    <span class="hljs-keyword">private</span> String[] myStrs;    <span class="hljs-keyword">private</span> List&lt;String&gt; myList;    <span class="hljs-keyword">private</span> Set&lt;String&gt; mySet;    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; myMap;    <span class="hljs-keyword">private</span> Properties myProps;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMyStrs</span><span class="hljs-params">(String[] myStrs)</span> </span>&#123;        <span class="hljs-keyword">this</span>.myStrs = myStrs;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMyList</span><span class="hljs-params">(List&lt;String&gt; myList)</span> </span>&#123;        <span class="hljs-keyword">this</span>.myList = myList;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMySet</span><span class="hljs-params">(Set&lt;String&gt; mySet)</span> </span>&#123;        <span class="hljs-keyword">this</span>.mySet = mySet;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMyMap</span><span class="hljs-params">(Map&lt;String, String&gt; myMap)</span> </span>&#123;        <span class="hljs-keyword">this</span>.myMap = myMap;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMyProps</span><span class="hljs-params">(Properties myProps)</span> </span>&#123;        <span class="hljs-keyword">this</span>.myProps = myProps;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">saveAccount</span><span class="hljs-params">()</span></span>&#123;        System.out.println(Arrays.toString(myStrs));        System.out.println(myList);        System.out.println(mySet);        System.out.println(myMap);        System.out.println(myProps);    &#125;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring(4)---JdbcTemplate、事务控制</title>
    <link href="/2020/05/26/Spring(4)---JdbcTemplate%E3%80%81%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/"/>
    <url>/2020/05/26/Spring(4)---JdbcTemplate%E3%80%81%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>Spring---JdbcTemplate、事务控制</font></div><h2 id="jdbctemplate的使用"><a href="#jdbctemplate的使用" class="headerlink" title="jdbctemplate的使用"></a>jdbctemplate的使用</h2><h2 id="自定义jdbctemplate"><a href="#自定义jdbctemplate" class="headerlink" title="自定义jdbctemplate"></a>自定义jdbctemplate</h2><ul><li>现在xml文件中进行配置</li></ul><pre><code class="hljs java">&lt;!-- 配置账户的持久层--&gt;    &lt;bean id=<span class="hljs-string">"accountDao"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"com.itheima.dao.impl.AccountDaoImpl"</span>&gt;        &lt;!--&lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/property&gt;--&gt;        &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--配置JdbcTemplate--&gt;    &lt;bean id=<span class="hljs-string">"jdbcTemplate"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;        &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 配置数据源--&gt;    &lt;bean id=<span class="hljs-string">"dataSource"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;        &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt;        &lt;property name="url" value="jdbc:mysql://localhost:3306/eesy"&gt;&lt;/property&gt;        &lt;property name="username" value="root"&gt;&lt;/property&gt;        &lt;property name="password" value="1234"&gt;&lt;/property&gt;    &lt;/bean&gt;</code></pre><p>然后就可以注入使用：</p><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountDaoImpl2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAccountDao</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">findAccountById</span><span class="hljs-params">(Integer accountId)</span> </span>&#123;        List&lt;Account&gt; accounts = jdbcTemplate.query(<span class="hljs-string">"select * from account where id = ?"</span>,<span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account<span class="hljs-class">.<span class="hljs-keyword">class</span>),<span class="hljs-title">accountId</span>)</span>;        <span class="hljs-keyword">return</span> accounts.isEmpty()?<span class="hljs-keyword">null</span>:accounts.get(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">findAccountByName</span><span class="hljs-params">(String accountName)</span> </span>&#123;        List&lt;Account&gt; accounts = jdbcTemplate.query(<span class="hljs-string">"select * from account where name = ?"</span>,<span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account<span class="hljs-class">.<span class="hljs-keyword">class</span>),<span class="hljs-title">accountName</span>)</span>;        <span class="hljs-keyword">if</span>(accounts.isEmpty())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span>(accounts.size()&gt;<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"结果集不唯一"</span>);        &#125;        <span class="hljs-keyword">return</span> accounts.get(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAccount</span><span class="hljs-params">(Account account)</span> </span>&#123;        jdbcTemplate.update(<span class="hljs-string">"update account set name=?,money=? where id=?"</span>,account.getName(),account.getMoney(),account.getId());    &#125;&#125;</code></pre><h3 id="使用spring的jdbctemplate的类"><a href="#使用spring的jdbctemplate的类" class="headerlink" title="使用spring的jdbctemplate的类"></a>使用spring的jdbctemplate的类</h3><p>此时就不可以再进行注入，但是因为xml中配置过数据源，数据源存在jdbctemplate就会存在</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountDaoImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JdbcDaoSupport</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAccountDao</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">findAccountById</span><span class="hljs-params">(Integer accountId)</span> </span>&#123;        List&lt;Account&gt; accounts = <span class="hljs-keyword">super</span>.getJdbcTemplate().query(<span class="hljs-string">"select * from account where id = ?"</span>,<span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account<span class="hljs-class">.<span class="hljs-keyword">class</span>),<span class="hljs-title">accountId</span>)</span>;        <span class="hljs-keyword">return</span> accounts.isEmpty()?<span class="hljs-keyword">null</span>:accounts.get(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">findAccountByName</span><span class="hljs-params">(String accountName)</span> </span>&#123;        List&lt;Account&gt; accounts = <span class="hljs-keyword">super</span>.getJdbcTemplate().query(<span class="hljs-string">"select * from account where name = ?"</span>,<span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account<span class="hljs-class">.<span class="hljs-keyword">class</span>),<span class="hljs-title">accountName</span>)</span>;        <span class="hljs-keyword">if</span>(accounts.isEmpty())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span>(accounts.size()&gt;<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"结果集不唯一"</span>);        &#125;        <span class="hljs-keyword">return</span> accounts.get(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAccount</span><span class="hljs-params">(Account account)</span> </span>&#123;        <span class="hljs-keyword">super</span>.getJdbcTemplate().update(<span class="hljs-string">"update account set name=?,money=? where id=?"</span>,account.getName(),account.getMoney(),account.getId());    &#125;&#125;</code></pre><h3 id="基于xml的声明的事务控制配置步骤"><a href="#基于xml的声明的事务控制配置步骤" class="headerlink" title="基于xml的声明的事务控制配置步骤"></a>基于xml的声明的事务控制配置步骤</h3><ol><li>配置事务管理器</li><li>配置事务的通知<pre><code>此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的使用tx:advice标签配置事务通知 属性：        id：给事务通知起一个唯一标识        transaction-manager：给事务通知提供一个事务管理器引用</code></pre></li><li>配置AOP中的通用切入点表达式</li><li>建立事务通知和切入点表达式的对应关系</li><li>配置事务的属性<pre><code>是在事务的通知tx:advice标签的内部</code></pre></li></ol><pre><code class="hljs java">&lt;!-- 配置事务管理器 --&gt;    &lt;bean id=<span class="hljs-string">"transactionManager"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;        &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 配置事务的通知--&gt;    &lt;tx:advice id=<span class="hljs-string">"txAdvice"</span> transaction-manager=<span class="hljs-string">"transactionManager"</span>&gt;        &lt;!-- 配置事务的属性                isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。                propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。                read-only：用于指定事务是否只读。只有查询方法才能设置为<span class="hljs-keyword">true</span>。默认值是<span class="hljs-keyword">false</span>，表示读写。                timeout：用于指定事务的超时时间，默认值是-<span class="hljs-number">1</span>，表示永不超时。如果指定了数值，以秒为单位。                rollback-<span class="hljs-keyword">for</span>：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。                no-rollback-<span class="hljs-keyword">for</span>：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。        --&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=<span class="hljs-string">"*"</span> propagation=<span class="hljs-string">"REQUIRED"</span> read-only=<span class="hljs-string">"false"</span>/&gt;            &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"&gt;&lt;/tx:method&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!-- 配置aop--&gt;    &lt;aop:config&gt;        &lt;!-- 配置切入点表达式--&gt;        &lt;aop:pointcut id="pt1" expression="execution(* com.itheima.service.impl.*.*(..))"&gt;&lt;/aop:pointcut&gt;        &lt;!--建立切入点表达式和事务通知的对应关系 --&gt;        &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"&gt;&lt;/aop:advisor&gt;    &lt;/aop:config&gt;</code></pre><h3 id="基于注解的事务控制"><a href="#基于注解的事务控制" class="headerlink" title="基于注解的事务控制"></a>基于注解的事务控制</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 账户的业务层实现类</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 事务控制应该都是在业务层</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Service</span>(<span class="hljs-string">"accountService"</span>)<span class="hljs-meta">@Transactional</span>(propagation= Propagation.SUPPORTS,readOnly=<span class="hljs-keyword">true</span>)<span class="hljs-comment">//只读型事务的配置</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAccountService</span></span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IAccountDao accountDao;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">findAccountById</span><span class="hljs-params">(Integer accountId)</span> </span>&#123;        <span class="hljs-keyword">return</span> accountDao.findAccountById(accountId);    &#125;    <span class="hljs-comment">//需要的是读写型事务配置</span>    <span class="hljs-meta">@Transactional</span>(propagation= Propagation.REQUIRED,readOnly=<span class="hljs-keyword">false</span>)    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(String sourceName, String targetName, Float money)</span> </span>&#123;        System.out.println(<span class="hljs-string">"transfer...."</span>);            <span class="hljs-comment">//2.1根据名称查询转出账户</span>            Account source = accountDao.findAccountByName(sourceName);            <span class="hljs-comment">//2.2根据名称查询转入账户</span>            Account target = accountDao.findAccountByName(targetName);            <span class="hljs-comment">//2.3转出账户减钱</span>            source.setMoney(source.getMoney()-money);            <span class="hljs-comment">//2.4转入账户加钱</span>            target.setMoney(target.getMoney()+money);            <span class="hljs-comment">//2.5更新转出账户</span>            accountDao.updateAccount(source);            <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>/<span class="hljs-number">0</span>;            <span class="hljs-comment">//2.6更新转入账户</span>            accountDao.updateAccount(target);    &#125;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数组与集合</title>
    <link href="/2020/05/20/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88/"/>
    <url>/2020/05/20/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>Java集合梳理</font></div><h2 id="数组与集合"><a href="#数组与集合" class="headerlink" title="数组与集合"></a>数组与集合</h2><hr><p>说明：</p><p>​        集合和数组都是对多个数据进行存储操作的结构，简称java容器，而此时说的<strong>存储</strong>，指的是<strong>内存层面</strong>的存储，不涉及到持久层（.txt, .jpg, .avi, 数据库中等）的存储。</p><p>数组在存储多个数据方面的特点：</p><ul><li>一旦初始化以后，其长度就确定了，<strong>不可修改</strong>。</li><li>数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。比如：String[] arr;int[] arr1; Object[] arr2;</li><li>数组存储数据的特点：<strong>有序、可重复</strong>。对于无序、不可重复的需求，不能满足。</li><li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>​         <strong>Java集合不能存放基本数据类型</strong> ,Java集合如Map、Set、List等所有集合只能存放引用类型数据，它们都是存放引用类型数据的容器，不能存放如int、long、float、double等基础类型的数据。</p><h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/collection%E6%8E%A5%E5%8F%A3%E6%A1%86%E6%9E%B6.PNG" srcset="/img/loading.gif" alt="collection接口框架"></p><p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE.png" srcset="/img/loading.gif" alt="集合框架图"></p><h3 id="Collection接口中的方法的使用"><a href="#Collection接口中的方法的使用" class="headerlink" title="Collection接口中的方法的使用"></a>Collection接口中的方法的使用</h3><pre><code class="hljs java">Collection coll = <span class="hljs-keyword">new</span> ArrayList();</code></pre><ol><li>add(Object e):将元素e添加到集合coll中</li></ol><pre><code class="hljs java">coll.add(<span class="hljs-string">"AA"</span>);      coll.add(<span class="hljs-string">"BB"</span>);      coll.add(<span class="hljs-number">123</span>);<span class="hljs-comment">//自动装箱</span>      coll.add(<span class="hljs-keyword">new</span> Date());</code></pre><ol start="2"><li>size():获取添加的元素的个数</li></ol><pre><code class="hljs java">System.out.println(coll.size());<span class="hljs-comment">//4</span></code></pre><ol start="3"><li>addAll(Collection coll1):将coll1集合中的元素添加到当前的集合中</li></ol><pre><code class="hljs java">Collection coll1 = <span class="hljs-keyword">new</span> ArrayList();     coll1.add(<span class="hljs-number">456</span>);     coll1.add(<span class="hljs-string">"CC"</span>);     coll.addAll(coll1);</code></pre><ol start="4"><li>clear():清空集合元素</li></ol><pre><code class="hljs java">coll.clear();</code></pre><ol start="5"><li>isEmpty():判断当前集合是否为空</li></ol><pre><code class="hljs ```java">System.out.println(coll.isEmpty());</code></pre><ol start="6"><li>contains(Object obj):判断当前集合中是否包含obj，<strong>在判断时会调用obj对象所在类的equals()。</strong></li><li>containsAll(Collection coll1):判断形参coll1中的所有元素是否都存在于当前集合中。</li><li>remove(Object obj):从当前集合中移除obj元素。</li><li>removeAll(Collection coll1):差集：从当前集合中移除coll1中所有的元素。</li><li>retainAll(Collection coll1):交集：获取当前集合和coll1集合的交集，<strong>并返回给当前集合</strong></li><li>equals(Object obj):要想返回true，需要当前集合和形参集合的元素都相同。也会调用对象的添加方法，如果其中的元素的有序的要求相同的添加顺序，因为它是有序的，如果其中的元素是无序的就要求内容相同。</li><li>hashCode():返回当前对象的哈希值。</li><li>集合 —&gt;数组：toArray()</li></ol><pre><code class="hljs java">Collection coll = <span class="hljs-keyword">new</span> ArrayList();      coll.add(<span class="hljs-number">123</span>);      coll.add(<span class="hljs-number">456</span>);      coll.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Jerry"</span>,<span class="hljs-number">20</span>));      coll.add(<span class="hljs-keyword">new</span> String(<span class="hljs-string">"Tom"</span>));      coll.add(<span class="hljs-keyword">false</span>);Object[] arr = coll.toArray();      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; arr.length;i++)&#123;          System.out.println(arr[i]);      &#125;</code></pre><ol start="14"><li>数组 —&gt;集合:调用Arrays类的静态方法asList()</li></ol><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"AA"</span>, <span class="hljs-string">"BB"</span>, <span class="hljs-string">"CC"</span>&#125;);      System.out.println(list);</code></pre><ol start="15"><li>iterator():返回Iterator接口的实例，用于遍历集合元素</li></ol><p>Tips：</p><p>使用Collection集合存储对象，要求对象所属的类满足：<br>向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要<strong>重写equals()</strong>。</p><h3 id="关于迭代器"><a href="#关于迭代器" class="headerlink" title="关于迭代器"></a>关于迭代器</h3><p><strong>集合元素的遍历操作，使用迭代器Iterator接口</strong></p><p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8E%9F%E7%90%86%E5%9B%BE.png" srcset="/img/loading.gif" alt="迭代器原理图"></p><ul><li>内部的方法：hasNext() 和  next()</li><li>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</li><li>内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()</li></ul><pre><code class="hljs java">Collection coll = <span class="hljs-keyword">new</span> ArrayList();      coll.add(<span class="hljs-number">123</span>);      coll.add(<span class="hljs-number">456</span>);      coll.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Jerry"</span>,<span class="hljs-number">20</span>));      coll.add(<span class="hljs-keyword">new</span> String(<span class="hljs-string">"Tom"</span>));      coll.add(<span class="hljs-keyword">false</span>);      Iterator iterator = coll.iterator();<span class="hljs-keyword">while</span>(iterator.hasNext())&#123;          <span class="hljs-comment">//next():①指针下移 ②将下移以后集合位置上的元素返回</span>          System.out.println(iterator.next());      &#125;</code></pre><p>Tips:错误写法：</p><pre><code class="hljs java"><span class="hljs-comment">//错误方式一：原因：next():①指针下移 ②将下移以后集合位置上的元素返回，这样相当于下移了两次</span>      Iterator iterator = coll.iterator();      <span class="hljs-keyword">while</span>((iterator.next()) != <span class="hljs-keyword">null</span>)&#123;          System.out.println(iterator.next());      &#125;<span class="hljs-comment">//错误方式二：</span>      <span class="hljs-comment">//集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</span>      <span class="hljs-keyword">while</span> (coll.iterator().hasNext())&#123;          System.out.println(coll.iterator().next());      &#125;</code></pre><p>Iterator中的remove()</p><p>Tips:  Iterator <strong>在工作的时候是不允许被迭代的对象被改变的</strong>。不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式。</p><p>删除元素：</p><pre><code class="hljs java"><span class="hljs-comment">//删除集合中"Tom"</span>      Iterator iterator = coll.iterator();      <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<span class="hljs-comment">// iterator.remove();</span>          Object obj = iterator.next();          <span class="hljs-keyword">if</span>(<span class="hljs-string">"Tom"</span>.equals(obj))&#123;              iterator.remove();<span class="hljs-comment">// iterator.remove();</span>          &#125;</code></pre><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p>jdk5.0新特性–增强for循环：(foreach循环)</p><p><strong>内部仍然调用了迭代器。</strong></p><pre><code class="hljs java">Collection coll = <span class="hljs-keyword">new</span> ArrayList();   coll.add(<span class="hljs-number">123</span>);   coll.add(<span class="hljs-number">456</span>);   coll.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Jerry"</span>,<span class="hljs-number">20</span>));   coll.add(<span class="hljs-keyword">new</span> String(<span class="hljs-string">"Tom"</span>));   coll.add(<span class="hljs-keyword">false</span>);   <span class="hljs-comment">//for(集合元素的类型 局部变量 : 集合对象)</span>      <span class="hljs-keyword">for</span>(Object obj : coll)&#123;       System.out.println(obj);   &#125;</code></pre><h2 id="Collection子接口-List接口"><a href="#Collection子接口-List接口" class="headerlink" title="Collection子接口-List接口"></a>Collection子接口-List接口</h2><p><strong>存储有序的，可以重复的数据</strong></p><h3 id="List接口框架"><a href="#List接口框架" class="headerlink" title="List接口框架"></a>List接口框架</h3><p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/list%E6%8E%A5%E5%8F%A3%E6%A1%86%E6%9E%B6.PNG" srcset="/img/loading.gif" alt="List接口框架"></p><h3 id="各种源码分析"><a href="#各种源码分析" class="headerlink" title="各种源码分析"></a>各种源码分析</h3><p> ArrayList的源码分析：</p><p>jdk 7情况下</p><p>ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData</p><p>list.add(123);//elementData[0] = new Integer(123);</p><p>…</p><p>list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。</p><p>默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</p><p>结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</p><p> jdk 8中ArrayList的变化：</p><p>ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组</p><p>list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</p><p>…</p><p>后续的添加和扩容操作与jdk 7 无异。</p><p>LinkedList的源码分析：</p><p> LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null</p><p>list.add(123);//将123封装到Node中，创建了Node对象。</p><p>Vector的源码分析：</p><p>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</p><p>在扩容方面，默认扩容为原来的数组长度的2倍。</p><p>ArrayList、LinkedList、Vector三者的异同：</p><p>三个类都是实现了List接口，存储数据的特点：存储的都是有序、可重复的数据。</p><p>不同，见源码分析</p><h3 id="List接口中常用的方法"><a href="#List接口中常用的方法" class="headerlink" title="List接口中常用的方法"></a>List接口中常用的方法</h3><p>void add(int index, Object ele):在index位置插入ele元素<br>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来<br>Object get(int index):获取指定index位置的元素<br>int indexOf(Object obj):返回obj在集合中首次出现的位置<br>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置<br>Object remove(int index):移除指定index位置的元素，并返回此元素<br>Object set(int index, Object ele):设置指定index位置的元素为ele<br>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</p><h2 id="Collection子接口-set接口"><a href="#Collection子接口-set接口" class="headerlink" title="Collection子接口-set接口"></a>Collection子接口-set接口</h2><p>无序性：</p><p>不等于随机性，存储的数据在底层数组中，并非按照数组索引的顺序添加，而是根据数据的哈希值决定的，</p><p>不可重复性：保证的元素的添加按照equals()判断，不能返回true，ye’jiu’shi’shuo相通的元素只添加一个</p><h3 id="Set接口框架"><a href="#Set接口框架" class="headerlink" title="Set接口框架"></a>Set接口框架</h3><p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/set%E6%8E%A5%E5%8F%A3%E6%A1%86%E6%9E%B6.PNG" srcset="/img/loading.gif" alt="Set接口框架"></p><p>说明：</p><p>1、Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。</p><p>2、向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()</p><p>要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码</p><p>重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</p><h3 id="元素的添加过程"><a href="#元素的添加过程" class="headerlink" title="元素的添加过程"></a>元素的添加过程</h3><p>我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，<br>        此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断<br>        数组此位置上是否已经有元素：<br>            如果此位置上没有其他元素，则元素a添加成功。 —&gt;情况1<br>            如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：<br>                如果hash值不相同，则元素a添加成功。—&gt;情况2<br>                如果hash值相同，进而需要调用元素a所在类的equals()方法：<br>                       equals()返回true,元素a添加失败<br>                       equals()返回false,则元素a添加成功。—&gt;情况2</p><p>对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。<br>    jdk 7 :元素a放到数组中，指向原来的元素。<br>    jdk 8 :原来的元素在数组中，指向元素a<br>    总结：七上八下</p><p>HashSet底层：数组+链表的结构。</p><p>关于HashSet的使用：</p><p>LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个<br>数据和后一个数据。<br>优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;        Set set = <span class="hljs-keyword">new</span> LinkedHashSet();        set.add(<span class="hljs-number">456</span>);        set.add(<span class="hljs-number">123</span>);        set.add(<span class="hljs-number">123</span>);        set.add(<span class="hljs-string">"AA"</span>);        set.add(<span class="hljs-string">"CC"</span>);        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Tom"</span>,<span class="hljs-number">12</span>));        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Tom"</span>,<span class="hljs-number">12</span>));        set.add(<span class="hljs-number">129</span>);        Iterator iterator = set.iterator();        <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;            System.out.println(iterator.next());        &#125;    &#125;</code></pre><p>关于TreeSet的使用</p><p>1、向TreeSet中添加的数据，要求是<strong>相同类</strong>的对象。</p><p>2、两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator）</p><p>3、自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals().</p><p>4、定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals().</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;        Comparator com = <span class="hljs-keyword">new</span> Comparator() &#123;            <span class="hljs-comment">//按照年龄从小到大排列</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;                <span class="hljs-keyword">if</span>(o1 <span class="hljs-keyword">instanceof</span> User &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> User)&#123;                    User u1 = (User)o1;                    User u2 = (User)o2;                    <span class="hljs-keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不匹配"</span>);                &#125;            &#125;        &#125;;        TreeSet set = <span class="hljs-keyword">new</span> TreeSet(com);        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Tom"</span>,<span class="hljs-number">12</span>));        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jerry"</span>,<span class="hljs-number">32</span>));        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jim"</span>,<span class="hljs-number">2</span>));        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Mike"</span>,<span class="hljs-number">65</span>));        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Mary"</span>,<span class="hljs-number">33</span>));        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jack"</span>,<span class="hljs-number">33</span>));        set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jack"</span>,<span class="hljs-number">56</span>));        Iterator iterator = set.iterator();        <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;            System.out.println(iterator.next());        &#125;    &#125;</code></pre><h2 id="双列集合框架-Map"><a href="#双列集合框架-Map" class="headerlink" title="双列集合框架-Map"></a>双列集合框架-Map</h2><h3 id="Map接口框架"><a href="#Map接口框架" class="headerlink" title="Map接口框架"></a>Map接口框架</h3><p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/map%E6%8E%A5%E5%8F%A3%E6%A1%86%E6%9E%B6.PNG" srcset="/img/loading.gif" alt="Map接口框架"></p><p>存储结构的理解：</p><p>Map中的key:无序的、不可重复的，使用Set存储所的key  —&gt; key所在的类要重写equals()和hashCode() （以HashMap为例)<br>Map中的value:无序的、可重复的，使用Collection存储所的value —&gt;value所在的类要重写equals()<br>一个键值对：key-value构成了一个Entry对象。<br>Map中的entry:无序的、不可重复的，使用Set存储所的entry</p><h3 id="HashMap的底层原理"><a href="#HashMap的底层原理" class="headerlink" title="HashMap的底层原理"></a>HashMap的底层原理</h3><p>HashMap map = new HashMap():</p><p>在实例化以后，底层创建了长度是16的一维数组Entry[] table。</p><p>…可能已经执行过多次put…</p><p>map.put(key1,value1):</p><p>首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</p><p>如果此位置上的数据为空，此时的key1-value1添加成功。 —-情况1</p><p>如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值：</p><p>如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。—-情况2</p><p>如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：</p><p>如果equals()返回false:此时key1-value1添加成功。—-情况3</p><p>如果equals()返回true:使用value1替换value2。补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。</p><p>在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p><p>jdk8 相较于jdk7在底层实现方面的不同：</p><p>new HashMap():底层没有创建一个长度为16的数组</p><p>jdk 8底层的数组是：Node[],而非Entry[]</p><p>首次调用put()方法时，底层创建长度为16的数组</p><p>jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。</p><p>形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）<br>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</p><p>HashMap底层典型属性的属性的说明：</p><p> DEFAULT_INITIAL_CAPACITY : HashMap的默认容量：16</p><p>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75</p><p>threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12</p><p>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8</p><p>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p> Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中<br> void putAll(Map m):将m中的所有key-value对存放到当前map中<br> Object remove(Object key)：移除指定key的key-value对，并返回value<br> void clear()：清空当前map中的所有数据<br> 元素查询的操作：<br> Object get(Object key)：获取指定key对应的value<br> boolean containsKey(Object key)：是否包含指定的key<br> boolean containsValue(Object value)：是否包含指定的value<br> int size()：返回map中key-value对的个数<br> boolean isEmpty()：判断当前map是否为空<br> boolean equals(Object obj)：判断当前map和参数对象obj是否相等<br> 元视图操作的方法：<br> Set keySet()：返回所有key构成的Set集合<br> Collection values()：返回所有value构成的Collection集合<br> Set entrySet()：返回所有key-value对构成的Set集合</p><pre><code class="hljs java"><span class="hljs-comment">//遍历所有的key-value</span>        <span class="hljs-comment">//方式一：entrySet()</span>        Set entrySet = map.entrySet();        Iterator iterator1 = entrySet.iterator();        <span class="hljs-keyword">while</span> (iterator1.hasNext())&#123;            Object obj = iterator1.next();            <span class="hljs-comment">//entrySet集合中的元素都是entry</span>            Map.Entry entry = (Map.Entry) obj;            System.out.println(entry.getKey() + <span class="hljs-string">"----&gt;"</span> + entry.getValue());        &#125;        System.out.println();        <span class="hljs-comment">//方式二：</span>        Set keySet = map.keySet();        Iterator iterator2 = keySet.iterator();        <span class="hljs-keyword">while</span>(iterator2.hasNext())&#123;            Object key = iterator2.next();            Object value = map.get(key);            System.out.println(key + <span class="hljs-string">"====="</span> + value);        &#125;</code></pre><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>向TreeMap中添加key-value，要求key必须是由同一个类创建的对象</p><p>因为要按照key进行排序：自然排序 、定制排序</p><p>定制排序：</p><pre><code class="hljs java"><span class="hljs-comment">//定制排序</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;        TreeMap map = <span class="hljs-keyword">new</span> TreeMap(<span class="hljs-keyword">new</span> Comparator() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;                <span class="hljs-keyword">if</span>(o1 <span class="hljs-keyword">instanceof</span> User &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> User)&#123;                    User u1 = (User)o1;                    User u2 = (User)o2;                    <span class="hljs-keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());                &#125;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的类型不匹配！"</span>);            &#125;        &#125;);        User u1 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Tom"</span>,<span class="hljs-number">23</span>);        User u2 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jerry"</span>,<span class="hljs-number">32</span>);        User u3 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jack"</span>,<span class="hljs-number">20</span>);        User u4 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Rose"</span>,<span class="hljs-number">18</span>);        map.put(u1,<span class="hljs-number">98</span>);        map.put(u2,<span class="hljs-number">89</span>);        map.put(u3,<span class="hljs-number">76</span>);        map.put(u4,<span class="hljs-number">100</span>);        Set entrySet = map.entrySet();        Iterator iterator1 = entrySet.iterator();        <span class="hljs-keyword">while</span> (iterator1.hasNext())&#123;            Object obj = iterator1.next();            Map.Entry entry = (Map.Entry) obj;            System.out.println(entry.getKey() + <span class="hljs-string">"----&gt;"</span> + entry.getValue());        &#125;    &#125;</code></pre><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p>Properties:常用来处理配置文件。key和value都是String类型</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;        FileInputStream fis = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            Properties pros = <span class="hljs-keyword">new</span> Properties();            fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"jdbc.properties"</span>);            pros.load(fis);<span class="hljs-comment">//加载流对应的文件</span>            String name = pros.getProperty(<span class="hljs-string">"name"</span>);            String password = pros.getProperty(<span class="hljs-string">"password"</span>);            System.out.println(<span class="hljs-string">"name = "</span> + name + <span class="hljs-string">", password = "</span> + password);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span>(fis != <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-keyword">try</span> &#123;                    fis.close();                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;</code></pre><h2 id="Connections工具类的使用"><a href="#Connections工具类的使用" class="headerlink" title="Connections工具类的使用"></a>Connections工具类的使用</h2><p>Connectionos是操作Collection和Map的工具类</p><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>reverse(List)：反转 List 中元素的顺序<br>shuffle(List)：对 List 集合元素进行随机排序<br>sort(List)：根据元素的自然顺序对指定 List 集合元素升序排序<br>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序<br>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换<br>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素<br>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素<br>Object min(Collection)<br>Object min(Collection，Comparator)<br>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数<br>void copy(List dest,List src)：将src中的内容复制到dest中<br>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所旧值</p><p>说明：ArrayList和HashMap都是线程不安全的，如果程序要求线程安全，我们可以将ArrayList、HashMap转换为线程的。<br>使用synchronizedList(List list） 和 synchronizedMap(Map map）</p><pre><code class="hljs java"><span class="hljs-comment">//返回的list1即为线程安全的List</span>        List list1 = Collections.synchronizedList(list);</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java常用类——String、StringBuffer、StringBuilder</title>
    <link href="/2020/05/15/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E2%80%94%E2%80%94String%E3%80%81StringBuffer%E3%80%81StringBuilder/"/>
    <url>/2020/05/15/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E2%80%94%E2%80%94String%E3%80%81StringBuffer%E3%80%81StringBuilder/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>Java常用类——String、StringBuffer、StringBuilder</font></div>   <hr><font size='4'>   <h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>使用一对””引起来表示（java.lang.String类）<br>1、String声明为final，不可被继承<br>2、String实现了Serializable接口，表示字符串是支持可序列化的<br>emsp;emsp;实现了Comparable接口，表示String可以比较大小<br>3、内部定义了final char[] values用于存储字符串数据<br>4、String代表不可变的字符序列，简称：<strong>不可变性</strong><br>emsp;emsp;也就是说，当字符串重新赋值时，需要重写指定内存区域赋值，不可使用原有的values进行赋值<br>emsp;emsp;当对现有的字符串进行<strong>连接操作</strong>的时候，也需要重新指定内存区赋值，不可使用原有的value进行赋值<br>emsp;emsp;当调用String的<strong>replace()</strong>方法修改指定的字符或者字符串时，也需要指定内存区域，不能使用原有的value进行赋值<br>5、通过<strong>字面量</strong>的方式（例如： String s1 = “abc”;）给一个字符串赋值，此时，字符串声明在常量池中<br>6、字符串常量池中，<strong>不会存储相同的字符串</strong>    </p><h3 id="String实例化的方式"><a href="#String实例化的方式" class="headerlink" title="String实例化的方式"></a>String实例化的方式</h3><p>方式一：通过字面量定义的方式   </p><p>这种方式将javaEE声明在方法区中的字符串常量池中<br><font size='5'></p><pre><code>String s1 = &quot;javaEE&quot;;String s2 = &quot;javaEE&quot;;</code></pre></font><p>方式二：通过new + 构造器的方式   </p><p>引用中保存的是地址值，是数据在堆空间中开辟空间以后对应的地址值<br><font size='5'></p><pre><code>String s3 = new String(&quot;javaEE&quot;);String s4 = new String(&quot;javaEE&quot;);    </code></pre></font>   两者的==情况：   <font size='5'><pre><code>System.out.println(s1 == s2);//trueSystem.out.println(s1 == s3);//falseSystem.out.println(s1 == s4);//falseSystem.out.println(s3 == s4);//false </code></pre></font><p>细节上：   </p><p>1、常量与常量拼接的结果在常量池中，而且常量池中不会存在相同内容的常量<br>2、只要拼接时有一个时变量，结果就在堆中（例如当对现有的String进行再拼接时，其实是重新指定了内存区域的），如果不加final的话，因为加了final的变为常量<br><font size='5'></p><pre><code>String s1 = &quot;javaEEhadoop&quot;;final  String s2 = &quot;javaEE&quot;;String s3 = s2 + &quot;hadoop&quot;;System.out.println(s1 == s3);//true     </code></pre></font>   ![字面量赋值和new的区别](https://github.com/BunnyAndOak0/IMG/raw/master/images/%E5%AD%97%E9%9D%A2%E9%87%8F%E8%B5%8B%E5%80%BC%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB.png)      <p>Tips:<br>JVM中字符串常量池存放位置说明：<br>jdk 1.6 (jdk 6.0 ,java 6.0):字符串常量池存储在方法区（永久区）<br>jdk 1.7:字符串常量池存储在堆空间<br>jdk 1.8:字符串常量池存储在方法区（元空间）   </p><p>3、如果拼接结果调用intern()方法，返回值就在<strong>常量池</strong>中   </p><p>例如：<br><font size='5'></p><pre><code>public void test4(){    String s1 = &quot;javaEEhadoop&quot;;    String s2 = &quot;javaEE&quot;;    String s3 = s2 + &quot;hadoop&quot;;    System.out.println(s1 == s3);//false    final String s4 = &quot;javaEE&quot;;//s4:常量    String s5 = s4 + &quot;hadoop&quot;;    System.out.println(s1 == s5);//true}   </code></pre></font><p>使用intern()方法<br><font size='5'></p><pre><code>    public void test3(){    String s1 = &quot;javaEE&quot;;    String s2 = &quot;hadoop&quot;;    String s3 = &quot;javaEEhadoop&quot;;    String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;;    String s5 = s1 + &quot;hadoop&quot;;    String s6 = &quot;javaEE&quot; + s2;    String s7 = s1 + s2;    System.out.println(s3 == s4);//true    System.out.println(s3 == s5);//false    System.out.println(s3 == s6);//false    System.out.println(s3 == s7);//false    System.out.println(s5 == s6);//false    System.out.println(s5 == s7);//false    System.out.println(s6 == s7);//false    String s8 = s6.intern();//返回值得到的s8使用的常量值中已经存在的“javaEEhadoop”    System.out.println(s3 == s8);//true}   </code></pre></font><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>int length()：返回字符串的长度： return value.length<br>char charAt(int index)： 返回某索引处的字符return value[index]<br>boolean isEmpty()：判断是否是空字符串：return value.length == 0<br>String toLowerCase()：使用默认语言环境，将 String 中的所字符转换为小写<br>String toUpperCase()：使用默认语言环境，将 String 中的所字符转换为大写<br>String trim()：返回字符串的副本，忽略前导空白和尾部空白<br>boolean equals(Object obj)：比较字符串的内容是否相同<br>boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写<br>String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”<br>int compareTo(String anotherString)：比较两个字符串的大小<br>String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。<br>String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。<strong>左闭右开</strong>   </p><p>boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束<br>boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始<br>boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始<br>boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true<br>int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引<br>int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始<br>int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引<br>int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索   </p><p>注：indexOf和lastIndexOf方法如果未找到都是返回-1   </p><p>替换：<br>String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所 oldChar 得到的。<br>String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串。<br>String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所匹配给定的正则表达式的子字符串。<br>String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。<br>匹配:<br>boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。<br>切片：<br>String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。<br>String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。   </p><h3 id="String与其他类型的转换"><a href="#String与其他类型的转换" class="headerlink" title="String与其他类型的转换"></a>String与其他类型的转换</h3><p>1、String 与基本数据类型、包装类之间的转换。<br>String –&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)<br>基本数据类型、包装类 –&gt; String:调用String重载的valueOf(xxx)<br><font size='5'></p><pre><code>    @Testpublic void test1(){    String str1 = &quot;123&quot;;//   int num = (int)str1;//错误的    int num = Integer.parseInt(str1);    String str2 = String.valueOf(num);//&quot;123&quot;    String str3 = num + &quot;&quot;;    System.out.println(str1 == str3);    }}   </code></pre></font><p>2、String 与 char[]之间的转换<br>String –&gt; char[]:调用String的toCharArray()<br>char[] –&gt; String:<strong>调用String的构造器</strong>(ball ball you 不要再错在这里了！！！)<br><font size='5'></p><pre><code>public void test2(){    String str1 = &quot;abc123&quot;;  //题目： a21cb3    char[] charArray = str1.toCharArray();    for (int i = 0; i &lt; charArray.length; i++) {        System.out.println(charArray[i]);    }    char[] arr = new char[]{&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;};    String str2 = new String(arr);    System.out.println(str2);}   </code></pre></font><p>3、String 与 byte[]之间的转换<br>编码：String –&gt; byte[]:调用String的getBytes()<br>解码：byte[] –&gt; String:调用String的构造器   </p><p>编码：字符串 –&gt;字节  (看得懂 —&gt;看不懂的二进制数据)<br>解码：编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂）   </p><p>说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。<br><font size='5'></p><pre><code>public void test3() throws UnsupportedEncodingException {    String str1 = &quot;abc123中国&quot;;    byte[] bytes = str1.getBytes();//使用默认的字符集，进行编码。    System.out.println(Arrays.toString(bytes));    byte[] gbks = str1.getBytes(&quot;gbk&quot;);//使用gbk字符集进行编码。    System.out.println(Arrays.toString(gbks));    System.out.println(&quot;******************&quot;);    String str2 = new String(bytes);//使用默认的字符集，进行解码。    System.out.println(str2);    String str3 = new String(gbks);    System.out.println(str3);//出现乱码。原因：编码集和解码集不一致！    String str4 = new String(gbks, &quot;gbk&quot;);    System.out.println(str4);//没有出现乱码。原因：编码集和解码集一致！}   </code></pre></font><h3 id="与字符串相关的类"><a href="#与字符串相关的类" class="headerlink" title="与字符串相关的类"></a>与字符串相关的类</h3><p>与StringBuffer、StringBuilder之间的转换<br>String –&gt; StringBuffer、StringBuilder:调用StringBuffer、StringBuilder构造器<br>StringBuffer、StringBuilder –&gt; String:①调用String构造器；②StringBuffer、StringBuilder的toString()   </p><p>String、StringBuffer、StringBuilder三者的异同<br>String:不可变的字符序列；底层使用char[]存储<br>StringBuffer:可变的字符序列；<strong>线程安全</strong>的，<strong>效率低</strong>；底层使用char[]存储<br>StringBuilder:可变的字符序列；jdk5.0新增的，<strong>线程不安全</strong>的，<strong>效率高</strong>；底层使用char[]存储    </p><p>TIps：<br>源码分析：<br>String str = new String();//char[] value = new char[0];<br>tring str1 = new String(“abc”);//char[] value = new char[]{‘a’,’b’,’c’};<br>StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。<br>System.out.println(sb1.length());<br>sb1.append(‘a’);//value[0] = ‘a’;<br>sb1.append(‘b’);//value[1] = ‘b’;   </p><p>扩容问题:<br>如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。<br>默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。   </p><p>StringBuffer的常用方法：<br>StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接<br>StringBuffer delete(int start,int end)：删除指定位置的内容<br>StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str<br>StringBuffer insert(int offset, xxx)：在指定位置插入xxx<br>StringBuffer reverse() ：把当前字符序列逆转<br>public int indexOf(String str)<br>public String substring(int start,int end):返回一个从start开始到end索引结束的左闭右开区间的子字符串<br>public int length()<br>public char charAt(int n )<br>public void setCharAt(int n ,char ch)   </p><p>遍历：for() + charAt() / toString()   </p><p>对比String、StringBuffer、StringBuilder三者的效率：<br>从高到低排列：StringBuilder &gt; StringBuffer &gt; String   </p></font>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java常用类——Date、比较器、其他类</title>
    <link href="/2020/05/15/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E2%80%94%E2%80%94Date%E3%80%81%E6%AF%94%E8%BE%83%E5%99%A8%E3%80%81%E5%85%B6%E4%BB%96%E7%B1%BB/"/>
    <url>/2020/05/15/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E2%80%94%E2%80%94Date%E3%80%81%E6%AF%94%E8%BE%83%E5%99%A8%E3%80%81%E5%85%B6%E4%BB%96%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>Java常用类——Date、比较器、其他类</font></div> <hr><h2 id="JDK8之前的日期API"><a href="#JDK8之前的日期API" class="headerlink" title="JDK8之前的日期API"></a>JDK8之前的日期API</h2><h3 id="System类中的currentTimeMillis"><a href="#System类中的currentTimeMillis" class="headerlink" title="System类中的currentTimeMillis()"></a>System类中的currentTimeMillis()</h3><p><font size='4'>返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差，称为时间戳</font></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">long</span> time = System.currentTimeMillis();        <span class="hljs-comment">//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</span>        System.out.println(time);    &#125;</code></pre><h3 id="java-util-Date类和java-sql-Date类"><a href="#java-util-Date类和java-sql-Date类" class="headerlink" title="java.util.Date类和java.sql.Date类"></a>java.util.Date类和java.sql.Date类</h3><p>java.util.Date类 </p><p>&emsp;&emsp;&emsp;|—java.sql.Date类  </p><p>1、两个构造器的使用  </p><p> 构造器一：Date()：创建一个对应当前时间的Date对象  </p><p> 构造器二：创建指定毫秒数的Date对象</p><pre><code class="hljs jav">&#x2F;&#x2F;构造器一：Date()：创建一个对应当前时间的Date对象   Date date1 &#x3D; new Date();   System.out.println(date1.toString());&#x2F;&#x2F;Sat Feb 16 16:35:31 GMT+08:00 2019   System.out.println(date1.getTime());&#x2F;&#x2F;1550306204104</code></pre><p>2、两个方法的使用<br> toString():显示当前的年、月、日、时、分、秒<br> getTime():获取当前Date对象对应的毫秒数。（时间戳）</p><pre><code class="hljs jav">&#x2F;&#x2F;构造器二：创建指定毫秒数的Date对象   Date date2 &#x3D; new Date(155030620410L);   System.out.println(date2.toString());</code></pre><p>3、java.sql.Date对应着数据库中的日期类型的变量  </p><pre><code class="hljs ja">&#x2F;&#x2F;创建java.sql.Date对象   java.sql.Date date3 &#x3D; new java.sql.Date(35235325345L);   System.out.println(date3);&#x2F;&#x2F;1971-02-13     &#x2F;&#x2F;将java.util.Date对象转换为java.sql.Date对象   &#x2F;&#x2F;情况一：&#x2F;&#x2F;  Date date4 &#x3D; new java.sql.Date(2343243242323L);&#x2F;&#x2F;  java.sql.Date date5 &#x3D; (java.sql.Date) date4;   &#x2F;&#x2F;情况二：   Date date6 &#x3D; new Date();   java.sql.Date date7 &#x3D; new java.sql.Date(date6.getTime());</code></pre><h3 id="java-text-SimpleDataFormat类"><a href="#java-text-SimpleDataFormat类" class="headerlink" title="java.text.SimpleDataFormat类"></a>java.text.SimpleDataFormat类</h3><p>SimpleDateFormat对日期Date类的格式化和解析  </p><p> 1、格式化：日期 —&gt; 字符串  </p><p> 2、解析：格式化的逆过程，字符串 —&gt; 日期  </p><p> 3、SimpleDateFormat的实例化:new + 构造器</p><pre><code class="hljs ja">@Test   public void testSimpleDateFormat() throws ParseException &#123;       &#x2F;&#x2F;实例化SimpleDateFormat:使用默认的构造器       SimpleDateFormat sdf &#x3D; new SimpleDateFormat();       &#x2F;&#x2F;格式化：日期 ---&gt;字符串       Date date &#x3D; new Date();       System.out.println(date);       String format &#x3D; sdf.format(date);       System.out.println(format);       &#x2F;&#x2F;解析：格式化的逆过程，字符串 ---&gt; 日期       String str &#x3D; &quot;19-12-18 上午11:43&quot;;       Date date1 &#x3D; sdf.parse(str);       System.out.println(date1);       &#x2F;&#x2F;*************按照指定的方式格式化和解析：调用带参的构造器*****************&#x2F;&#x2F; SimpleDateFormat sdf1 &#x3D; new SimpleDateFormat(&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;);       SimpleDateFormat sdf1 &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);       &#x2F;&#x2F;格式化       String format1 &#x3D; sdf1.format(date);       System.out.println(format1);&#x2F;&#x2F;2019-02-18 11:48:27       &#x2F;&#x2F;解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现),       &#x2F;&#x2F;否则，抛异常       Date date2 &#x3D; sdf1.parse(&quot;2020-02-18 11:48:27&quot;);       System.out.println(date2);&#x2F;&#x2F;Tue Feb 18 11:48:27 CST 2020   &#125;</code></pre><h3 id="Calendar类：日历类、抽象类"><a href="#Calendar类：日历类、抽象类" class="headerlink" title="Calendar类：日历类、抽象类"></a>Calendar类：日历类、抽象类</h3><p>1、实例化  </p><p> 方式一：创建其子类（GregorianCalendar的对象  </p><p> 方式二：调用其静态方法getInstance()  </p><pre><code class="hljs ja">Calendar calendar &#x3D; Calendar.getInstance();&#x2F;&#x2F;System.out.println(calendar.getClass());</code></pre><p>2、常用方法  </p><p> get()</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> days = calendar.get(Calendar.DAY_OF_MONTH);System.out.println(days);System.out.println(calendar.get(Calendar.DAY_OF_YEAR));</code></pre><p>set()</p><pre><code class="hljs java"><span class="hljs-comment">//calendar可变性</span>calendar.set(Calendar.DAY_OF_MONTH,<span class="hljs-number">22</span>);days = calendar.get(Calendar.DAY_OF_MONTH);System.out.println(days);</code></pre><p>add()</p><pre><code class="hljs java">calendar.add(Calendar.DAY_OF_MONTH,-<span class="hljs-number">3</span>);days = calendar.get(Calendar.DAY_OF_MONTH);System.out.println(days);</code></pre><p>getTime():日历类—&gt; Date </p><pre><code class="hljs java">Date date = calendar.getTime();System.out.println(date);</code></pre><p>setTime():Date —&gt; 日历类</p><pre><code class="hljs java">Date date1 = <span class="hljs-keyword">new</span> Date();calendar.setTime(date1);days = calendar.get(Calendar.DAY_OF_MONTH);System.out.println(days);</code></pre><h3 id="JDK8中新的日期时API"><a href="#JDK8中新的日期时API" class="headerlink" title="JDK8中新的日期时API"></a>JDK8中新的日期时API</h3><p>迭代  </p><p> 第一代：jdk 1.0 Date类  </p><p> 第二代：jdk 1.1 Calendar类，一定程度上替换Date类  </p><p> 第三代：jdk 1.8 提出了新的一套API  </p><p> 存在问题  </p><p> 可变性：像日期和时间这样的类应该是不可变的。  </p><p> 偏移性：Date中的年份是从1900开始的，而月份都从0开始。  </p><p> 格式化：格式化只对Date用，Calendar则不行。  </p><p> 此外，它们也不是线程安全的；不能处理闰秒等。  </p><p> 1、LocalDate、LocalTime、LocalDateTime 的使用  </p><p> 说明：  </p><p> LocalDateTime相较于LocalDate、LocalTime，使用频率要高  </p><p> 类似于Calendar  </p><p> <img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/LocalDateTime.png" srcset="/img/loading.gif" alt="LocalDateTime">  </p><p> 2、Instant的使用  </p><p> 类似于 java.util.Date类  </p><p> <img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/Instant.png" srcset="/img/loading.gif" alt="Instant"></p><p> 3、DateTimeFormatter  </p><p> 格式化或解析日期、时间  </p><p> 类似于SimpleDateFormat </p><pre><code class="hljs java"><span class="hljs-comment">//  重点：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</span>DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd hh:mm:ss"</span>);<span class="hljs-comment">//格式化</span>String str4 = formatter3.format(LocalDateTime.now());System.out.println(str4);<span class="hljs-comment">//2019-02-18 03:52:09</span><span class="hljs-comment">//解析</span>TemporalAccessor accessor = formatter3.parse(<span class="hljs-string">"2019-02-18 03:52:09"</span>);System.out.println(accessor);</code></pre><p><img src="https://github.com/BunnyAndOak0/IMG/blob/master/images/DateTimeFormatter.png" srcset="/img/loading.gif" alt="DateTimeFormatter"></p><h2 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h2><p>System类  </p><p> System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。<br> 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。  </p><p> 方法：  </p><p> native long currentTimeMillis()  </p><p> void exit(int status)  </p><p> void gc()  </p><p> String getProperty(String key) </p><pre><code class="hljs java">String javaVersion = System.getProperty(<span class="hljs-string">"java.version"</span>);System.out.println(<span class="hljs-string">"java的version:"</span> + javaVersion);String javaHome = System.getProperty(<span class="hljs-string">"java.home"</span>);System.out.println(<span class="hljs-string">"java的home:"</span> + javaHome);</code></pre><p>Math类  </p><p> java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。  </p><p> BigInteger类、BigDecimal类  </p><p> java.math包的BigInteger可以表示不可变的任意精度的整数  </p><p> 要求数字精度比较高，用到java.math.BigDecimal类</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;        BigInteger bi = <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">"1243324112234324324325235245346567657653"</span>);        BigDecimal bd = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"12435.351"</span>);        BigDecimal bd2 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"11"</span>);        System.out.println(bi);<span class="hljs-comment">//1243324112234324324325235245346567657653</span>        <span class="hljs-comment">//  System.out.println(bd.divide(bd2));</span>        System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));<span class="hljs-comment">//1130.486</span>        System.out.println(bd.divide(bd2, <span class="hljs-number">25</span>, BigDecimal.ROUND_HALF_UP));<span class="hljs-comment">//1130.4864545454545454545454545</span>    &#125;</code></pre><h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p>使用场景  </p><p> Java中的对象，正常情况下，只能进行比较：== 或 != 。不能使用 &gt; 或 &lt; 的但是在开发场景中，我们需要对多个对象进行排序，就可以使用两个接口中的任何一个：Comparable 或 Comparator  </p><p> 1、Comparable接口的使用举例：自然排序  </p><p> 像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。  </p><p> 像String、包装类重写compareTo()方法以后，进行了从小到大的排列  </p><p> 重写compareTo(obj)的规则：  </p><p> &emsp;&emsp;如果当前对象this大于形参对象obj，则返回正整数，  </p><p> &emsp;&emsp;如果当前对象this小于形参对象obj，则返回负整数，  </p><p> &emsp;&emsp;如果当前对象this等于形参对象obj，则返回零。  </p><p> 对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。在compareTo(obj)方法中指明如何排序  </p><p> 例如：在String中</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;        String[] arr = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"AA"</span>,<span class="hljs-string">"CC"</span>,<span class="hljs-string">"KK"</span>,<span class="hljs-string">"MM"</span>,<span class="hljs-string">"GG"</span>,<span class="hljs-string">"JJ"</span>,<span class="hljs-string">"DD"</span>&#125;;        Arrays.sort(arr);        System.out.println(Arrays.toString(arr));    &#125;</code></pre><p>在自定义类中 </p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;        Goods[] arr = <span class="hljs-keyword">new</span> Goods[<span class="hljs-number">5</span>];        arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"lenovoMouse"</span>,<span class="hljs-number">34</span>);        arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"dellMouse"</span>,<span class="hljs-number">43</span>);        arr[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"xiaomiMouse"</span>,<span class="hljs-number">12</span>);        arr[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"huaweiMouse"</span>,<span class="hljs-number">65</span>);        arr[<span class="hljs-number">4</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"microsoftMouse"</span>,<span class="hljs-number">43</span>);        Arrays.sort(arr);        System.out.println(Arrays.toString(arr));    &#125;</code></pre><p>先实现Comparable接口： </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Goods</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">Comparable</span></span></code></pre><p>重新compareTo()方法：</p><pre><code class="hljs java"><span class="hljs-comment">//指明商品比较大小的方式:按照价格从低到高排序,再按照产品名称从高到低排序</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;<span class="hljs-comment">//  System.out.println("**************");</span>        <span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Goods)&#123;            Goods goods = (Goods)o;            <span class="hljs-comment">//方式一：</span>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.price &gt; goods.price)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.price &lt; goods.price)&#123;                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//    return 0;</span>               <span class="hljs-keyword">return</span> -<span class="hljs-keyword">this</span>.name.compareTo(goods.name);            &#125;            <span class="hljs-comment">//方式二：</span><span class="hljs-comment">//   return Double.compare(this.price,goods.price);</span>        &#125;<span class="hljs-comment">//   return 0;</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"传入的数据类型不一致！"</span>);    &#125;</code></pre><hr><p>2、Comparator接口的使用：定制排序 </p><p>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序  </p><p> 重写compare(Object o1,Object o2)方法，比较o1和o2的大小：  </p><p> 如果方法返回正整数，则表示o1大于o2；  </p><p> 如果返回0，表示相等；  </p><p> 返回负整数，表示o1小于o2。  </p><p> 例如Stirng类型定制排序： </p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;        String[] arr = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"AA"</span>,<span class="hljs-string">"CC"</span>,<span class="hljs-string">"KK"</span>,<span class="hljs-string">"MM"</span>,<span class="hljs-string">"GG"</span>,<span class="hljs-string">"JJ"</span>,<span class="hljs-string">"DD"</span>&#125;;        Arrays.sort(arr,<span class="hljs-keyword">new</span> Comparator()&#123;            <span class="hljs-comment">//按照字符串从大到小的顺序排列</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;                <span class="hljs-keyword">if</span>(o1 <span class="hljs-keyword">instanceof</span> String &amp;&amp; o2 <span class="hljs-keyword">instanceof</span>  String)&#123;                    String s1 = (String) o1;                    String s2 = (String) o2;                    <span class="hljs-keyword">return</span> -s1.compareTo(s2);                &#125;<span class="hljs-comment">// return 0;</span>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不一致"</span>);            &#125;        &#125;);        System.out.println(Arrays.toString(arr));    &#125;</code></pre><p>例如自定义类定制排序：</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span>&#123;        Goods[] arr = <span class="hljs-keyword">new</span> Goods[<span class="hljs-number">6</span>];        arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"lenovoMouse"</span>,<span class="hljs-number">34</span>);        arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"dellMouse"</span>,<span class="hljs-number">43</span>);        arr[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"xiaomiMouse"</span>,<span class="hljs-number">12</span>);        arr[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"huaweiMouse"</span>,<span class="hljs-number">65</span>);        arr[<span class="hljs-number">4</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"huaweiMouse"</span>,<span class="hljs-number">224</span>);        arr[<span class="hljs-number">5</span>] = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"microsoftMouse"</span>,<span class="hljs-number">43</span>);        Arrays.sort(arr, <span class="hljs-keyword">new</span> Comparator() &#123;            <span class="hljs-comment">//指明商品比较大小的方式:按照产品名称从低到高排序,再按照价格从高到低排序</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;                <span class="hljs-keyword">if</span>(o1 <span class="hljs-keyword">instanceof</span> Goods &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> Goods)&#123;                    Goods g1 = (Goods)o1;                    Goods g2 = (Goods)o2;                    <span class="hljs-keyword">if</span>(g1.getName().equals(g2.getName()))&#123;                        <span class="hljs-keyword">return</span> -Double.compare(g1.getPrice(),g2.getPrice());                    &#125;<span class="hljs-keyword">else</span>&#123;                        <span class="hljs-keyword">return</span> g1.getName().compareTo(g2.getName());                    &#125;                &#125;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不一致"</span>);            &#125;        &#125;);        System.out.println(Arrays.toString(arr));    &#125;</code></pre><p>例如，定义了comparator的比较方法之后：  </p><pre><code class="hljs java">Comparator com = <span class="hljs-keyword">new</span> Comparator() &#123;    <span class="hljs-comment">//指明商品比较大小的方式:照产品名称从低到高排序,再照价格从高到低排序</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;        <span class="hljs-keyword">if</span>(o1 <span class="hljs-keyword">instanceof</span> Goods &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> Goods)&#123;            Goods g1 = (Goods)o1;            Goods g2 = (Goods)o2;            <span class="hljs-keyword">if</span>(g1.getName().equals(g2.getName()))&#123;                <span class="hljs-keyword">return</span> -Double.compare(g1.getPrice(),g2.getPrice());            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">return</span> g1.getName().compareTo(g2.getName());            &#125;        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不一致"</span>);    &#125;&#125;</code></pre><p>使用场景：  </p><p> Arrays.sort(goods,com);  </p><p> Collections.sort(coll,com);  </p><p> new TreeSet(com); </p><hr><p>Comparable接口与Comparator的使用的对比：  </p><p> Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。  </p><p> Comparator接口属于临时性的比较</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程梳理</title>
    <link href="/2020/05/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <url>/2020/05/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>多线程梳理</font></div>   <hr><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>程序：<br>&emsp;&emsp;是为了完成特定任务，用某种语言编写的一组指令的集合，也就是一段静态代码。<br>进程：<br>&emsp;&emsp;是程序的一次执行过程，或是<strong>正在执行的一个程序</strong>。<br>线程：<br>&emsp;&emsp;进程可以细化为线程，也就是程序内部的一条执行的路径（可以作为调度和执行的单位，每个线程拥有独立的运行栈和计数器配就是pc）。<br>也就是说：进程可以细化为多个线程，而每个线程拥有自己独立的栈，程序计数器，多个线程共享同一个进程中的方法区和堆。<br>内存结构如图：<br><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" alt="内存结构">   </p><p>多线程的优点：提高程序的响应，提高CPU的利用率，改善程序结构<br>善用多线程的环境：需要执行两个或者多个任务，是要实现一些要等待的任务，需要在后台运行等。</p><h2 id="单核与多核-并发与并行"><a href="#单核与多核-并发与并行" class="headerlink" title="单核与多核 并发与并行"></a>单核与多核 并发与并行</h2><p>单核CPU：其实是一种假的多线程，因为在一个时间单元内，只能执行一个线程任务。<br>多核CPU：可以更好的发挥多线程的效率。<br>Tips：<br>&emsp;&emsp;一个java程序java.exe，至少有三个线程，main()主程序，gc()垃圾回收线程，异常处理线程。   </p><p>并行：多个CPU同时执行多个任务。<br>并发：一个CPU（采用时间片）同时执行多个任务。</font>   </p><h2 id="创建多线程的方式-总共四种"><a href="#创建多线程的方式-总共四种" class="headerlink" title="创建多线程的方式(总共四种)"></a>创建多线程的方式(总共四种)</h2><h3 id="方式一：继承于Thread类"><a href="#方式一：继承于Thread类" class="headerlink" title="方式一：继承于Thread类"></a>方式一：继承于Thread类</h3><p>1、创建一个继承于Thread类的子类<br>2、重写Thread类的run()方法 —&gt;  将要执行的操作生命在run()中即可<br>3、创建Thread类的子类的对象<br>4、通过此对象调用<strong>start()</strong>，调用的是start()，不是run()   </p><p>调用start()的时候，会启动当前线程，并调用当前线程的run()<br>Tips：<br>&emsp;&emsp;不可以直接调用run()方法，这样的话只会调用方法而不会启动线程<br>&emsp;&emsp;不可以在已启动的线程上再次调用start()，否则会报会报IllegalThreadStateException的异常</font>   </p><h3 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h3><p>1、创建一个实现了Runnable接口的类<br>2、实现类去实现Runnable中的抽象方法run()<br>3、创建实现类的对象<br>4、将此对象作为参数传递到Thread类的构造器中，创建Thead类的对象<br>5、通过Thread类的对象调用start()   </p><p>通过Thread类的对象调用start()的时候，线程会启动，并调用当线程的run()方法，也就是调用了Runnable类型的target里面的run()</font>   </p><font size='5'>两种线程方式的比较：</font>   <p>开发中优先选用<strong>Runnable接口</strong>的方式<br>原因：<br>1、实现类的方式没有类的单继承性局限<br>2、实现类的方式更适合来处理多个线程有共享数据的情况   </p><p>相同点：两种方式都需要重新run()方法，将线程要执行的逻辑声明在run()中<br>(联系：public class Thread implements Runnable)   </p><h3 id="方式三：实现Callable接口-JDK5-0新增"><a href="#方式三：实现Callable接口-JDK5-0新增" class="headerlink" title="方式三：实现Callable接口(JDK5.0新增)"></a>方式三：实现Callable接口(JDK5.0新增)</h3><p>Callable和Raunnable比较<br>1、call()可以有返回值的。<br>2、call()可以抛出异常，被外面的操作捕获，获取异常的信息<br>3、Callable是支持泛型的   </p><pre><code>//1.创建一个实现Callable的实现类class NumThread implements Callable{    //2.实现call方法，将此线程需要执行的操作声明在call()中    @Override    public Object call() throws Exception {        int sum = 0;        for (int i = 1; i &lt;= 100; i++) {            if(i % 2 == 0){                System.out.println(i);                sum += i;            }        }        return sum;    }}public class ThreadNew {    public static void main(String[] args) {        //3.创建Callable接口实现类的对象        NumThread numThread = new NumThread();        //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象        FutureTask futureTask = new FutureTask(numThread);        //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()        new Thread(futureTask).start();        try {            //6.获取Callable中call方法的返回值            //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。            Object sum = futureTask.get();            System.out.println(&quot;总和为：&quot; + sum);        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }    }}   </code></pre><h3 id="方式四：使用线程池-JDK5-0新增"><a href="#方式四：使用线程池-JDK5-0新增" class="headerlink" title="方式四：使用线程池(JDK5.0新增)"></a>方式四：使用线程池(JDK5.0新增)</h3><p>好处：<br>1、提高响应速度（减少了创建新线程的时间）<br>2、降低资源消耗（重复利用线程池中线程，不需要每次都创建）<br>3、便于线程管理<br>corePoolSize：核心池的大小<br>maximumPoolSize：最大线程数<br>keepAliveTime：线程没有任务时最多保持多长时间后会终止   </p><pre><code>class NumberThread implements Runnable{    @Override    public void run() {        for(int i = 0;i &lt;= 100;i++){            if(i % 2 == 0){                System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i);            }        }    }}class NumberThread1 implements Runnable{    @Override    public void run() {        for(int i = 0;i &lt;= 100;i++){            if(i % 2 != 0){                System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i);            }        }    }}public class ThreadPool {    public static void main(String[] args) {        //1. 提供指定线程数量的线程池        ExecutorService service = Executors.newFixedThreadPool(10);        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;        //设置线程池的属性//        System.out.println(service.getClass());//        service1.setCorePoolSize(15);//        service1.setKeepAliveTime();        //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象        service.execute(new NumberThread());//适合适用于Runnable        service.execute(new NumberThread1());//适合适用于Runnable//        service.submit(Callable callable);//适合使用于Callable        //3.关闭连接池        service.shutdown();    }}</code></pre><h2 id="Thread常用的方法："><a href="#Thread常用的方法：" class="headerlink" title="Thread常用的方法："></a>Thread常用的方法：</h2><p>1、start()：启动当前线程调用run()<br>2、run()：通常需要重写Thread类中的此方法，声明要执行的操作<br>3、currentThread()：<strong>静态方法</strong>，返回执行当前代码的线程<br>4、setName()/getName()：设置/获取当前线程的名字(设置线程名字也可以在构造器中进行)<br>5、setName()：设置当前线程的名字<br>6、yield()：释放当前cpu的执行权，例如：this.yield()，<strong>但是不释放锁</strong><br>7、join()：在线程a中调用b的join()方法，则a就会进入阻塞状态，直达b完全执行完之后，才会结束阻塞状态，也就是说将b线程加入到main线程中，只有b线程运行结束，才会接着往下走<br>8、stop()：已过时，强制结束当前线程<br>9、sleep(毫秒数)：让当前线程睡眠指定的毫秒数，此时，线程是阻塞状态<br>10、isAlive()：判断当前线程是否存活   </p><p>线程的优先级：<br>1、<br>MAX_PRIORITY：10<br>MIN _PRIORITY：1<br>NORM_PRIORITY：5  –&gt;默认优先级<br>2.如何获取和设置当前线程的优先级：<br>getPriority():获取线程的优先级<br>setPriority(int p):设置线程的优先级   </p><p>说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。   </p><p>线程通行：wait()/notify()/notifyAll()：此三个的方法定义在Object类中   </p><p>线程分为：守护线程、用户线程<br>守护线程依赖于用户线程例如：垃圾回收，通过thread.setDaemon(true);可以将用户线程变为守护线程，如果jvm中都为守护线程，则当前jvm将会退出   </p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" srcset="/img/loading.gif" alt="生命周期">   </p><p>状态包括：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING ,TEARMINATED<br>(sleep()不会释放锁，wait()会释放锁)</p><h2 id="解决线程"><a href="#解决线程" class="headerlink" title="解决线程"></a>解决线程</h2><p>解决线程安全问题会用到同步机制，有三种方式，但是效率会下降，因为使用同步机制时就相当于是一个单线程，只有一个线程参与，而其他的线程等待   </p><h3 id="方式一：使用同步代码块"><a href="#方式一：使用同步代码块" class="headerlink" title="方式一：使用同步代码块"></a>方式一：使用同步代码块</h3><pre><code>synchronized(同步监视器){    //需要被同步的代码} </code></pre><p>说明：<br>1.操作共享数据的代码，即为需要被同步的代码。  –&gt;不能包含代码多了，也不能包含代码少了。<br>2.共享数据：多个线程共同操作的变量。比如：共享数据。<br>3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。<br>要求：多个线程必须要共用同一把锁。<br>补充：在<strong>实现Runnable接口</strong>创建多线程的方式中，我们可以考虑使用this充当同步监视器。   </p><p>对于继承了Thread类来实现线程的方法来说，<strong>同步代码块</strong>中的同步监视器，慎用this来充当同步监视器，而考虑使用<strong>当前类</strong>来充当同步监视器   </p><pre><code>class Window2 extends Thread{    private static int ticket = 100;        private static Object obj = new Object();    @Override    public void run() {        while(true){            //正确的        // synchronized (obj){            synchronized (Window2.class){//Class clazz = Window2.class,Window2.class只会加载一次                //错误的方式：this代表着t1,t2,t3三个对象        // synchronized (this){                if(ticket &gt; 0){                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(getName() + &quot;：卖票，票号为：&quot; + ticket);                    ticket--;                }else{                    break;                }            }        }    }}public class WindowTest2 {    public static void main(String[] args) {        Window2 t1 = new Window2();        Window2 t2 = new Window2();        Window2 t3 = new Window2();</code></pre><p>​<br>            t1.setName(“窗口1”);<br>            t2.setName(“窗口2”);<br>            t3.setName(“窗口3”);</p><pre><code>        t1.start();        t2.start();        t3.start();    }}   </code></pre><p>对于<strong>实现Runnable接口</strong>实现多线程来说，<strong>同步代码块</strong>中的同步监视器可以为<strong>this</strong> </p><pre><code>class Window1 implements Runnable{private int ticket = 100;//Object obj = new Object();//Dog dog = new Dog();    @Override    public void run() {//        Object obj = new Object();        while(true){            synchronized (this){//此时的this:唯一的Window1的对象   //方式二：synchronized (dog) {                if (ticket &gt; 0) {                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(Thread.currentThread().getName() + &quot;:卖票，票号为：&quot; + ticket);                    ticket--;                } else {                    break;                }            }        }    }}public class WindowTest1 {    public static void main(String[] args) {        Window1 w = new Window1();        Thread t1 = new Thread(w);        Thread t2 = new Thread(w);        Thread t3 = new Thread(w);        t1.setName(&quot;窗口1&quot;);        t2.setName(&quot;窗口2&quot;);        t3.setName(&quot;窗口3&quot;);        t1.start();        t2.start();        t3.start();    }}class Dog{}       </code></pre><h3 id="方式二：使用同步方法"><a href="#方式二：使用同步方法" class="headerlink" title="方式二：使用同步方法"></a>方式二：使用同步方法</h3><p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。<br>说明：<br>1、同步方法仍然涉及同步监视器，只是不需要我们现实的声明<br>2、<strong>非静态</strong>的同步方法，同步监视器是：<strong>this</strong><br>&emsp;<strong>静态</strong>的同步方法，同步监视器是：<strong>当前类本身</strong>   </p><p>对于使用<strong>继承Thread类</strong>的方法来实现线程的方法来说，而使用<strong>同步方法</strong>时，需要用<strong>static synchronized</strong>来修饰<br>例如：   </p><pre><code>class Window4 extends Thread {    private static int ticket = 100;    @Override    public void run() {        while (true) {            show();        }    }    private static synchronized void show(){//同步监视器：Window4.class        //private synchronized void show(){ //同步监视器：t1,t2,t3。此种解决方式是错误的        if (ticket &gt; 0) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + ticket);            ticket--;        }    }}public class WindowTest4 {    public static void main(String[] args) {        Window4 t1 = new Window4();        Window4 t2 = new Window4();        Window4 t3 = new Window4();</code></pre><p>​<br>            t1.setName(“窗口1”);<br>            t2.setName(“窗口2”);<br>            t3.setName(“窗口3”);</p><pre><code>        t1.start();        t2.start();        t3.start();    }}</code></pre><p>对于<strong>实现Runnable接口</strong>实现多线程来说，同步监视器可以为<strong>this</strong>，使用<strong>同步方法</strong>时，要用<strong>sychronized</strong>来修饰方法<br>例如：   </p><pre><code>class Window3 implements Runnable {    private int ticket = 100;    @Override    public void run() {        while (true) {            show();        }    }    private synchronized void show(){//同步监视器：this        //synchronized (this){            if (ticket &gt; 0) {                try {                    Thread.sleep(100);                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(Thread.currentThread().getName() + &quot;:卖票，票号为：&quot; + ticket);                ticket--;            }        //}    }}public class WindowTest3 {    public static void main(String[] args) {        Window3 w = new Window3();        Thread t1 = new Thread(w);        Thread t2 = new Thread(w);        Thread t3 = new Thread(w);        t1.setName(&quot;窗口1&quot;);        t2.setName(&quot;窗口2&quot;);        t3.setName(&quot;窗口3&quot;);        t1.start();        t2.start();        t3.start();    }}</code></pre><h3 id="方式三：使用Lock锁-JDK5-0新增"><a href="#方式三：使用Lock锁-JDK5-0新增" class="headerlink" title="方式三：使用Lock锁(JDK5.0新增)"></a>方式三：使用Lock锁(JDK5.0新增)</h3><p>没有使用同步监视器，因为其自身就是一个同步监视器<br>1、实例化ReentrantLock<br>2、调用锁定方法lock()<br>3、调用解锁方法unlock()   </p><p>例如：   </p><pre><code>class Window implements Runnable{    private int ticket = 100;    //1.实例化ReentrantLock    private ReentrantLock lock = new ReentrantLock();    @Override    public void run() {        while(true){            try{                //2.调用锁定方法lock()                lock.lock();                if(ticket &gt; 0){                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(Thread.currentThread().getName() + &quot;：售票，票号为：&quot; + ticket);                    ticket--;                }else{                    break;                }            }finally {                //3.调用解锁方法：unlock()                lock.unlock();            }        }    }}public class LockTest {    public static void main(String[] args) {        Window w = new Window();        Thread t1 = new Thread(w);        Thread t2 = new Thread(w);        Thread t3 = new Thread(w);        t1.setName(&quot;窗口1&quot;);        t2.setName(&quot;窗口2&quot;);        t3.setName(&quot;窗口3&quot;);        t1.start();        t2.start();        t3.start();    }}    </code></pre><p>Tips:<br>synchronized和lock的异同：<br>相同：二者都可以解决线程安全问题<br>不同：synchronized机制在执行完响应的代码之后会<strong>自动释放同步监视器(锁)</strong>，而Lock需要调用方法来<strong>手动启动lock()</strong>,同时结束之后也需要<strong>手动实现unlock()</strong>     </p><p>同步机制的利弊：<br>好处：解决了线程的安全问题。<br>弊端：操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的资源，就形成了线程的思索   </p><p>说明：死锁出现后，不会出现异常，不会出现提示，只是所有的线程都处于堵塞状态，无法继续   </p><pre><code>public class ThreadTest {    public static void main(String[] args) {        StringBuffer s1 = new StringBuffer();        StringBuffer s2 = new StringBuffer();        new Thread(){            @Override            public void run() {                synchronized (s1){                    s1.append(&quot;a&quot;);                    s2.append(&quot;1&quot;);                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    synchronized (s2){                        s1.append(&quot;b&quot;);                        s2.append(&quot;2&quot;);                        System.out.println(s1);                        System.out.println(s2);                    }                }            }        }.start();        new Thread(new Runnable() {            @Override            public void run() {                synchronized (s2){                    s1.append(&quot;c&quot;);                    s2.append(&quot;3&quot;);                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    synchronized (s1){                        s1.append(&quot;d&quot;);                        s2.append(&quot;4&quot;);                        System.out.println(s1);                        System.out.println(s2);                    }                }            }        }).start();    }}</code></pre><h2 id="使用同步机制将单例模式的懒汉式改为线程安全的"><a href="#使用同步机制将单例模式的懒汉式改为线程安全的" class="headerlink" title="使用同步机制将单例模式的懒汉式改为线程安全的"></a>使用同步机制将单例模式的懒汉式改为线程安全的</h2><pre><code>public class BankTest {}class Bank{    private Bank(){}    private static Bank instance = null;    public static Bank getInstance(){        //方式一：效率稍差//        synchronized (Bank.class) {//            if(instance == null){////                instance = new Bank();//            }//            return instance;//        }        //方式二：效率更高        if(instance == null){            synchronized (Bank.class) {                if(instance == null){                    instance = new Bank();                }            }        }        return instance;    }}</code></pre><h2 id="关于线程通信"><a href="#关于线程通信" class="headerlink" title="关于线程通信"></a>关于线程通信</h2><p>三个方法：<br>wait()：使当前线程进入阻塞，并释放同步监视器<br>notify()：唤醒被wait()的一个线程，如果多个线程被wait就唤醒优先级高的那个<br>notifyAll()：唤醒所有的被wait()的方法   </p><p>说明：<br>1、wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中<br>2、wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器，否则，会出现IllegalMonitorStateException异常<br>3、wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。   </p><p>sleep() 和 wait()的异同<br>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。<br>不同点：<br>(1)两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()<br>(2)调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中<br>(3)关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。   </p><p>例如：   </p><pre><code>class Number implements Runnable{    private int number = 1;    private Object obj = new Object();    @Override    public void run() {        while(true){            synchronized (obj) {                obj.notify();                if(number &lt;= 100){                    try {                        Thread.sleep(10);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(Thread.currentThread().getName() + &quot;:&quot; + number);                    number++;                    try {                        //使得调用如下wait()方法的线程进入阻塞状态                        obj.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }else{                    break;                }            }        }    }}public class CommunicationTest {    public static void main(String[] args) {        Number number = new Number();        Thread t1 = new Thread(number);        Thread t2 = new Thread(number);        t1.setName(&quot;线程1&quot;);        t2.setName(&quot;线程2&quot;);        t1.start();        t2.start();    }}</code></pre><h2 id="经典的生产者消费者问题"><a href="#经典的生产者消费者问题" class="headerlink" title="经典的生产者消费者问题"></a>经典的生产者消费者问题</h2><pre><code>class Clerk{    private int productCount = 0;    //生产产品    public synchronized void produceProduct() {        if(productCount &lt; 20){            productCount++;            System.out.println(Thread.currentThread().getName() + &quot;:开始生产第&quot; + productCount + &quot;个产品&quot;);            notify();        }else{            //等待            try {                wait();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    //消费产品    public synchronized void consumeProduct() {        if(productCount &gt; 0){            System.out.println(Thread.currentThread().getName() + &quot;:开始消费第&quot; + productCount + &quot;个产品&quot;);            productCount--;            notify();        }else{            //等待            try {                wait();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}class Producer extends Thread{//生产者    private Clerk clerk;    public Producer(Clerk clerk) {        this.clerk = clerk;    }    @Override    public void run() {        System.out.println(getName() + &quot;:开始生产产品.....&quot;);        while(true){            try {                Thread.sleep(10);            } catch (InterruptedException e) {                e.printStackTrace();            }            clerk.produceProduct();        }    }}class Consumer extends Thread{//消费者    private Clerk clerk;    public Consumer(Clerk clerk) {        this.clerk = clerk;    }    @Override    public void run() {        System.out.println(getName() + &quot;:开始消费产品.....&quot;);        while(true){            try {                Thread.sleep(20);            } catch (InterruptedException e) {                e.printStackTrace();            }            clerk.consumeProduct();        }    }}public class ProductTest {    public static void main(String[] args) {        Clerk clerk = new Clerk();        Producer p1 = new Producer(clerk);        p1.setName(&quot;生产者1&quot;);        Consumer c1 = new Consumer(clerk);        c1.setName(&quot;消费者1&quot;);        Consumer c2 = new Consumer(clerk);        c2.setName(&quot;消费者2&quot;);        p1.start();        c1.start();        c2.start();    }}</code></pre><p><a href="https://www.bilibili.com/video/BV1Qb411g7cz?p=413" target="_blank" rel="noopener">资料来源</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JSON的简单了解</title>
    <link href="/2020/05/14/JSON%E7%9A%84%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/"/>
    <url>/2020/05/14/JSON%E7%9A%84%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>JSON的简单了解</font></div><hr><h3 id="JSON是什么"><a href="#JSON是什么" class="headerlink" title="JSON是什么"></a>JSON是什么</h3><p>&emsp;&emsp;是一种基于JavaScript语法子集的开放标准数据交换格式。JSON是基于文本的，轻量级的，通常被认为易于读/写。</p><h3 id="语法格式要求"><a href="#语法格式要求" class="headerlink" title="语法格式要求"></a>语法格式要求</h3><font size='4'>&emsp;&emsp;在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：   1、对象数组表示为键值对   2、数据由逗号分隔   3、花括号保存对象   4、方括号保存数组   <p>JSON键值对是用来保存JS对象的一种方式，例如：<br>{“age”:”3”}<br>JSON是JS对象的字符串的表示法，它使用文本表示一个JS对象的信息。本质是一个字符串。</font>   </p><h3 id="JSON和JavaScript对象互转"><a href="#JSON和JavaScript对象互转" class="headerlink" title="JSON和JavaScript对象互转"></a>JSON和JavaScript对象互转</h3><p><font size='4'>JSON和JS对象的互转:<br>JSON字符串 —&gt;   JS对象<br>使用JSON.parse()方法:</p><p>JS对象 —&gt; JSON字符串<br>使用JSON.stringify()方法<br><font size='5'></p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    var user = {        name : &quot;爱丽丝&quot;,        age : 3,        sex : &quot;女&quot;    };    //输出此对象    console.log(user);    //将js对象转换为JSON    var str = JSON.stringify(user);    // str的输出结果：{&quot;name&quot;:&quot;爱丽丝&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;女&quot;}    console.log(str);    var obj = JSON.parse(str);    //obj的输出结果：{name: &quot;爱丽丝&quot;, age: 3, sex: &quot;女&quot;}    console.log(obj);&lt;/script&gt;   </code></pre></font><p>由于前后端分离，数据交互就变得异常重要，而json就是很重要的一部分</font>   </p><h3 id="使用Jackson进行json的解析"><a href="#使用Jackson进行json的解析" class="headerlink" title="使用Jackson进行json的解析"></a>使用Jackson进行json的解析</h3><p><font size='4'>Json返回的是一个字符串，而市面上有很多第三方jar包可以实现此功能，例如<strong>jackson</strong>（可以去maven仓库找）:可以利用@ResponseBody就可以将对象转换为json返回<br><font size='5'></p><pre><code>@Controllerpublic class UserController {    @RequestMapping(&quot;/json1&quot;)    @ResponseBody    public String json1() throws JsonProcessingException {       //创建一个jackson的对象映射器，用来解析数据       ObjectMapper mapper = new ObjectMapper();       //创建一个对象       User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);       //将我们的对象解析成为json格式       String str = mapper.writeValueAsString(user);       //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便       return str;    }}</code></pre></font><p>结果可以返回json的字符串，但是会出现乱码的问题<br>解决方法一：<br>使用@RequestMapping注解中的produces属性来指定返回类型和编码格式<br><font size='5'></p><pre><code>//produces:指定响应体返回类型和编码@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;)</code></pre></font>   可以解决乱码问题   <p>解决办法二：<br>在springMVC中，直接进行统一的配置，通过配置StringHttpMessageConverter进行转换<br><font size='5'></p><pre><code>&lt;mvc:annotation-driven&gt;    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;       &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;           &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;       &lt;/bean&gt;       &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;           &lt;property name=&quot;objectMapper&quot;&gt;               &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;                   &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;               &lt;/bean&gt;           &lt;/property&gt;       &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;</code></pre></font> </font><h3 id="关于统一返回json字符串"><a href="#关于统一返回json字符串" class="headerlink" title="关于统一返回json字符串"></a>关于统一返回json字符串</h3><p><font size='4'>可以直接在类上使用，@RestController，这样所有的方法返回的都是json字符串了，而不用每一个方法上都添加@ResponseBody，这是在开发中常用的方法<br><font size='5'></p><pre><code>@RestControllerpublic class UserController {    //produces:指定响应体返回类型和编码    @RequestMapping(value = &quot;/json1&quot;)    public String json1() throws JsonProcessingException {       //创建一个jackson的对象映射器，用来解析数据       ObjectMapper mapper = new ObjectMapper();       //创建一个对象       User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);       //将我们的对象解析成为json格式       String str = mapper.writeValueAsString(user);       //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便       return str;    }}   </code></pre></font></font><h3 id="关于时间问题的处理"><a href="#关于时间问题的处理" class="headerlink" title="关于时间问题的处理"></a>关于时间问题的处理</h3><p><font size='4'>json在将时间返回为json数据时，会将时间转换为时间戳的形式进行显示<br>解决办法：取消timestamps的形式，还可以自定义时间格式<br><font size='5'></p><pre><code>@RequestMapping(&quot;/json4&quot;)public String json4() throws JsonProcessingException {    ObjectMapper mapper = new ObjectMapper();    //不使用时间戳的方式   在此步骤关闭时间戳    mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);    //自定义日期格式对象    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    //指定日期格式    mapper.setDateFormat(sdf);    Date date = new Date();    String str = mapper.writeValueAsString(date);    return str;}</code></pre></font></font><h3 id="一点小拓展"><a href="#一点小拓展" class="headerlink" title="一点小拓展"></a>一点小拓展</h3><p><font size='4'>&emsp;&emsp;可以将经常使用的代码封装到一个工具类中：<br><font size='5'></p><pre><code>package com.kuang.utils;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import java.text.SimpleDateFormat;public class JsonUtils {    public static String getJson(Object object) {       return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;);    }    public static String getJson(Object object,String dateFormat) {       ObjectMapper mapper = new ObjectMapper();       //不使用时间差的方式       mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);       //自定义日期格式对象       SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);       //指定日期格式       mapper.setDateFormat(sdf);       try {           return mapper.writeValueAsString(object);      } catch (JsonProcessingException e) {           e.printStackTrace();      }       return null;    }}   </code></pre></font>这样调用的时候就可以直接使用啦</font>   <hr><p><font size='4'>&emsp;&emsp;astjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。   </p><p>记得导入fastjson 的 pom依赖！（可以在maven仓库找）</p><p>fastjson 三个主要的类：</p><p>（1）JSONObject  代表 json 对象 </p><p>（2）JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。</p><p>（3）JSONArray   代表 json 对象数组：内部是有List接口中的方法来完成操作的。<br>例如代码演示：<br><font size='5'></p><pre><code>package com.kuang.controller;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.kuang.pojo.User;import java.util.ArrayList;import java.util.List;public class FastJsonDemo {    public static void main(String[] args) {       //创建一个对象       User user1 = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);       User user2 = new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;);       User user3 = new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;);       User user4 = new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;);       List&lt;User&gt; list = new ArrayList&lt;User&gt;();       list.add(user1);       list.add(user2);       list.add(user3);       list.add(user4);       System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;);       String str1 = JSON.toJSONString(list);       System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1);       String str2 = JSON.toJSONString(user1);       System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2);       System.out.println(&quot;\n****** JSON字符串 转 Java对象*******&quot;);       User jp_user1=JSON.parseObject(str2,User.class);       System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1);       System.out.println(&quot;\n****** Java对象 转 JSON对象 ******&quot;);       JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);       System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;));       System.out.println(&quot;\n****** JSON对象 转 Java对象 ******&quot;);       User to_java_user = JSON.toJavaObject(jsonObject1, User.class);       System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user);    }}</code></pre></font><hr><p>以上资料参考：<a href="https://mp.weixin.qq.com/s/RAqRKZJqsJ78HRrJg71R1g" target="_blank" rel="noopener">狂神说JAVA</a></font></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式和方法引用</title>
    <link href="/2020/05/13/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    <url>/2020/05/13/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>Lambda表达式和方法引用的整理</font></div><hr><h2 id="Lanbda表达式"><a href="#Lanbda表达式" class="headerlink" title="Lanbda表达式"></a>Lanbda表达式</h2><font size='4'><h3 id="1、Lambda表达式的格式"><a href="#1、Lambda表达式的格式" class="headerlink" title="1、Lambda表达式的格式"></a>1、Lambda表达式的格式</h3><p><code>(o1,o2) -&gt; Integer.compare(o1,o2);</code><br>左边 —&gt; lambda表达式的形参列表，本质上也就是接口中抽象方法的形参列表<br>右边 —&gt; lambda体，也就是重写抽象方法的方法体   </p><h3 id="2、Lambda表达式的使用的六种情况："><a href="#2、Lambda表达式的使用的六种情况：" class="headerlink" title="2、Lambda表达式的使用的六种情况："></a>2、Lambda表达式的使用的六种情况：</h3><p>(1)语法格式一：无参，无返回值<br><font size='5'></p><pre><code>    @Testpublic void test1(){    //不使用Lambda表达式    Runnable r1 = new Runnable() {        @Override        public void run() {            System.out.println(&quot;不使用Lambda表达式&quot;);        }    };    r1.run();    System.out.println(&quot;***********************&quot;);    //使用Lambda表达式    Runnable r2 = () -&gt; {        System.out.println(&quot;使用Lambda表达式&quot;);    };    r2.run();}   </code></pre></font><p>(2)有一个参数，但是没有返回值<br><font size='5'></p><pre><code>@Testpublic void test2(){    //不使用Lambda表达式    Consumer&lt;String&gt; con = new Consumer&lt;String&gt;() {        @Override        public void accept(String s) {            System.out.println(s);        }    };    con.accept(&quot;不使用Lambda表达式&quot;);    System.out.println(&quot;*******************&quot;);    //使用Lambda表达式    Consumer&lt;String&gt; con1 = (String s) -&gt; {        System.out.println(s);    };    con1.accept(&quot;使用Lambda表达式&quot;);}   </code></pre></font><p>(3)数据类型可以省略，因为可以推断得出，称为类型推断<br><font size='5'></p><pre><code>@Testpublic void test3(){    //不使用Lambda表达式    Consumer&lt;String&gt; con1 = (String s) -&gt; {        System.out.println(s);    };    con1.accept(&quot;不使用Lambda表达式&quot;);    System.out.println(&quot;*******************&quot;);    //使用Lambda表达式    Consumer&lt;String&gt; con2 = (s) -&gt; {        System.out.println(s);    };    con2.accept(&quot;使用Lambda表达式&quot;);}</code></pre></font>   <p>(4)只需要一个参数的时候，小括号可以省略<br><font size='5'></p><pre><code>@Testpublic void test5(){    //不使用Lambda表达式    Consumer&lt;String&gt; con1 = (s) -&gt; {        System.out.println(s);    };    con1.accept(&quot;不使用Lambda表达式&quot;);    System.out.println(&quot;*******************&quot;);    //使用Lambda表达式    Consumer&lt;String&gt; con2 = s -&gt; {        System.out.println(s);    };    con2.accept(&quot;使用Lambda表达式&quot;);}</code></pre></font>   <p>(5)需要两个或两个以上的参数，多条执行语句，可以有返回值<br><font size='5'></p><pre><code>    @Testpublic void test6(){    //不使用Lambda表达式    Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;() {        @Override        public int compare(Integer o1, Integer o2) {            System.out.println(o1);            System.out.println(o2);            return o1.compareTo(o2);        }    };    System.out.println(com1.compare(12,21));    System.out.println(&quot;*****************************&quot;);    //使用Lambda表达式    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; {        System.out.println(o1);        System.out.println(o2);        return o1.compareTo(o2);    };    System.out.println(com2.compare(12,6));}</code></pre></font>   <p>(6)只有一条语句时，如果有返回值，return和大括号都可以省略（<strong>return必须省略</strong>）<br><font size='5'></p><pre><code>@Testpublic void test7(){    //不使用Lambda表达式    Comparator&lt;Integer&gt; com1 = (o1,o2) -&gt; {        return o1.compareTo(o2);    };    System.out.println(com1.compare(12,6));    System.out.println(&quot;*****************************&quot;);    //使用Lambda表达式    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; o1.compareTo(o2);    System.out.println(com2.compare(12,21));}</code></pre></font><p>综合的列子：<br>例子一：<br><font size='5'></p><pre><code>@Testpublic void test1(){    //不用Lambda表达式    happyTime(500, new Consumer&lt;Double&gt;() {        @Override        public void accept(Double aDouble) {            System.out.println(&quot;天上的星星有&quot; + aDouble);        }    });    System.out.println(&quot;********************&quot;);    //使用Lambda表达式    happyTime(400,nums -&gt; System.out.println(&quot;眼睛里有&quot; + nums + &quot;颗星星&quot;));}public void happyTime(double nums, Consumer&lt;Double&gt; con){    con.accept(nums);}   </code></pre></font><p>例子二：<br><font size='5'></p><pre><code>@Testpublic void test2(){    List&lt;String&gt; list = Arrays.asList(&quot;北京&quot;,&quot;南京&quot;,&quot;天津&quot;,&quot;东京&quot;,&quot;西京&quot;,&quot;普京&quot;);    List&lt;String&gt; filterStrs = filterString(list, new Predicate&lt;String&gt;() {        @Override        public boolean test(String s) {            return s.contains(&quot;京&quot;);        }    });    System.out.println(filterStrs);    List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains(&quot;京&quot;));    System.out.println(filterStrs1);}    //根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定    public List&lt;String&gt; filterString(List&lt;String&gt; list, Predicate&lt;String&gt; pre){        ArrayList&lt;String&gt; filterList = new ArrayList&lt;&gt;();        for(String s : list){            if(pre.test(s)){                filterList.add(s);            }        }        return filterList;    }}    </code></pre></font><p>总结：<br>&emsp;&emsp;-&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也可以省略<br>&emsp;&emsp;-&gt;右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对{}和return关键字</p><h3 id="3、lambda表达式的本质"><a href="#3、lambda表达式的本质" class="headerlink" title="3、lambda表达式的本质"></a>3、lambda表达式的本质</h3><p>作为函数式接口的<strong>实例</strong><br>&emsp;&emsp;所谓函数式接口也就是只声明了<strong>一个</strong>抽象方法的接口成为函数式接口，一般用@FunctionalInterface来注释，也可以用@FunctionalInterface来检验接口是否为函数式接口，如果不是函数式接口，会报错。<br>&emsp;&emsp;以前用匿名实现类表现的现在都可以用lambda表达式来写   </p><h3 id="4、关于函数式接口"><a href="#4、关于函数式接口" class="headerlink" title="4、关于函数式接口"></a>4、关于函数式接口</h3><p>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。<br>我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。<br><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.png" srcset="/img/loading.gif" alt="函数式接口"><br></font>   </p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><font size='4'>(1)使用情景   当传递给Lambda体的操作，已经有实现的方法了，就可以使用方法的引用   方法的引用：本质上就是Lambda表达式，而Lambda表达式时函数式接口的实例，所以，方法引用，也就是函数式接口的实例   使用格式：类（或对象）：：方法名   方法的引用使用要求：要求接口中抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同（针对于情况一和情况二）   <p>具体分为三种情况<br>情况一：对象 :: 实例方法<br><font size='5'></p><pre><code>//Consumer中的void accept(T t)//PrintStream中的void println(T t)@Testpublic void test1() {    Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);    con1.accept(&quot;北京&quot;);    System.out.println(&quot;*******************&quot;);    PrintStream ps = System.out;    Consumer&lt;String&gt; con2 = ps::println;    con2.accept(&quot;beijing&quot;);}   </code></pre></font><p>情况二：类 :: 静态方法<br><font size='5'></p><pre><code>//Comparator中的int compare(T t1,T t2)//Integer中的int compare(T t1,T t2)@Testpublic void test3() {    Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);    System.out.println(com1.compare(12,21));    System.out.println(&quot;*******************&quot;);    Comparator&lt;Integer&gt; com2 = Integer::compare;    System.out.println(com2.compare(12,3));}</code></pre></font>   <p>情况三：类 :: 实例方法  (有难度)<br><font size='5'>   </p><pre><code>// Comparator中的int comapre(T t1,T t2)// String中的int t1.compareTo(t2)@Testpublic void test5() {    Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);    System.out.println(com1.compare(&quot;abc&quot;,&quot;abd&quot;));    System.out.println(&quot;*******************&quot;);    Comparator&lt;String&gt; com2 = String :: compareTo;    System.out.println(com2.compare(&quot;abd&quot;,&quot;abm&quot;));}   //BiPredicate中的boolean test(T t1, T t2);//String中的boolean t1.equals(t2)@Testpublic void test6() {    BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);    System.out.println(pre1.test(&quot;abc&quot;,&quot;abc&quot;));    System.out.println(&quot;*******************&quot;);    BiPredicate&lt;String,String&gt; pre2 = String :: equals;    System.out.println(pre2.test(&quot;abc&quot;,&quot;abd&quot;));}</code></pre></font></font>   <hr><p><a href="https://www.bilibili.com/video/BV1Qb411g7cz?p=666" target="_blank" rel="noopener">资料来源</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Maven的大概梳理</title>
    <link href="/2020/05/13/%E5%85%B3%E4%BA%8EMaven%E7%9A%84%E5%A4%A7%E6%A6%82%E6%A2%B3%E7%90%86/"/>
    <url>/2020/05/13/%E5%85%B3%E4%BA%8EMaven%E7%9A%84%E5%A4%A7%E6%A6%82%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<div align='center'><font size='6'>关于Maven的大概梳理</font></div><hr><h2 id="目前项目中存在的问题"><a href="#目前项目中存在的问题" class="headerlink" title="目前项目中存在的问题"></a>目前项目中存在的问题</h2><p><font size='4'>1、一个项目就是一个工程<br>2、项目中需要的jar包必须手动复制，粘贴到”WEB-INF/lib”目录下<br>所带来的问题是：同样的jar包重复出现，这样浪费空间也让空间比较臃肿，借助maven可以将jar包保存在仓库中<br>3、jar包需要别人替我们准备好，或者到官网上下载<br>而官网提供的jar包下载形式是不同的，很不方便，面临各种问题，而借助maven可以按照统一的规范下载<br>4、一个jar包以来的其他的jar包需要自己手动加入到项目中<br></font>   </p><h2 id="maven是什么？"><a href="#maven是什么？" class="headerlink" title="maven是什么？"></a>maven是什么？</h2><p><font size='4'>Maven是一款服务于<strong>java</strong>平台的自动化构建工具<br>关于构建：<br>web工程和编译结果在目录上的不同：<br><img src="https://github.com/BunnyAndOak0/IMG/raw/master/images/maven%E4%B8%ADweb%E5%B7%A5%E7%A8%8B%E5%92%8C%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C%E7%9B%AE%E5%BD%95%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C.PNG" srcset="/img/loading.gif" alt="web工程和编译结果在目录上的不同"><br>构建的各个环节：<br>[1]清理：将以前的得到的旧的class字节码文件删除，为下一次编译做准备<br>[2]编译：将java源程序编译成class字节码文件<br>[3]测试：自动测试，自动调用junit程序<br>[4]报告：测试程序执行的结果<br>[5]打包：动态web工程打包为war包，java工程打jar包<br>[6]安装：maven特定的概念————将打包得到的文件复制到仓库中的位置<br>[7]部署：将动态的web工程生成war包复制到servlet容器指定目录下，使其可以运行</font>   </p><h2 id="maven的核心概念"><a href="#maven的核心概念" class="headerlink" title="maven的核心概念"></a>maven的核心概念</h2><h3 id="1、约定的目录结构"><a href="#1、约定的目录结构" class="headerlink" title="1、约定的目录结构"></a>1、约定的目录结构</h3><p><font size='4'>例如：<br>        目录结构<br>            Hello<br>            |—src<br>            |—|—main<br>            |—|—|—java<br>            |—|—|—resources<br>            |—|—test<br>            |—|—|—java<br>            |—|—|—resources<br>            |—pom.xml   </p><p>(1)根目录：工程名<br>(2)scr目录：源码<br>(3)pom.xml文件：maven工程的核心配置文件<br>(4)main目录：存放主程序<br>(5)test目录：存放测试程序<br>(6)java目录：存放java源程序<br>(7)resource目录：存放框架或者其他工具的配置文件   </p><p>一般来说：约定 &gt; 配置 &gt; 编码   </p><p>maven常用的命令<br>(1)mvn clean:清理<br>(2)mvn compile:编译主程序<br>(3)mvn test-complie:编译测试程序<br>(4)mvn test:执行测试<br>(5)mvn package:打包<br>(6)mvn site:生成站点   </p><p>Tips：<br>&emsp;&emsp;当我们执行maven命令需要用到某些插件时，maven核心程序会先去本地仓库（家目录）中寻找<code>C:\Users\18369\.m2\repository</code>如果没有找到，就会自动联网，在中央仓库中下载。</font>   </p><h3 id="2、pom"><a href="#2、pom" class="headerlink" title="2、pom"></a>2、pom</h3><p><font size='4'>(1)Project Object Model:项目对象模型<br>(2)pom.xml是maven工程的核心配置文件</font>   </p><h3 id="3、坐标"><a href="#3、坐标" class="headerlink" title="3、坐标"></a>3、坐标</h3><p><font size='4'>(1)使用三个向量在仓库中定位唯一的一个maven工程（管理jar包的方式）<br>&emsp;&emsp;[1]groupid：公司或者组织域名倒序+项目名   </p><pre><code>&lt;groupId&gt;org.example&lt;/groupId&gt;</code></pre><p>&emsp;&emsp;[2]artifactId：模块名   </p><pre><code>&lt;artifactId&gt;springMVC_day02_02_fileupload&lt;/artifactId&gt;   </code></pre><p>&emsp;&emsp;[3]version：版本</p><pre><code>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;   </code></pre></font><h3 id="4、依赖"><a href="#4、依赖" class="headerlink" title="4、依赖"></a>4、依赖</h3><p><font size='4'>(1)maven解析依赖信息的时候，会到本地仓库中查找被以来的jar包，对于我们自己的maven工程，使用mvn install命令安装后就可以进入仓库了。<br>(2)依赖的范围：<br><font size='5'><code>&lt;scope&gt;test&lt;/scope&gt;</code>默认值是compile</font>   </p><p>&emsp;&emsp;[1]compile<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对主程序<strong>有效</strong>，测试程序<strong>有效</strong>，<strong>参与</strong>打包，<strong>参与</strong>部署<br>&emsp;&emsp;[2]test<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对主程序<strong>无效</strong>，测试程序<strong>有效</strong>，<strong>不参与</strong>打包，<strong>不参与</strong>部署<br>&emsp;&emsp;[3]provided<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对主程序<strong>有效</strong>，测试程序<strong>有效</strong>，<strong>不参与</strong>打包，<strong>不参与</strong>部署   </p><p>(3)依赖的传递性<br>&emsp;&emsp;[1]可以传递的依赖不必在每个工程中都重复声明<br>&emsp;&emsp;[2]<strong>非</strong>compile范围的依赖是传递不过来的   </p><p>(4)依赖的排除<br>&emsp;&emsp;[1]需要设置依赖排除的场合<br>&emsp;&emsp;[2]依赖排除的方式<br><font size='5'></p><pre><code>&lt;exclusions&gt;    &lt;exclusion&gt;        &lt;groupId&gt;commons-logging&lt;/groupId&gt;        &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;    &lt;/exclusion&gt;&lt;/exclusions&gt;   </code></pre></font><p>(5)依赖的原则<br>&emsp;&emsp;[1]作用：解决模块工程之间的jar包冲突问题<br>&emsp;&emsp;[2]原则上：路径距离不同时：路径最短者优先<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;路径距离相同时：先声明者（指dependency标签的声明顺序）优先<br>(6)统一管理依赖的版本<br>建议方式：<br>&emsp;&emsp;[1]使用properties标签，其中使用自定义标签，统一声明版本号<br>&emsp;&emsp;例如：<br><font size='5'></p><pre><code>&lt;properties&gt;    &lt;edu.kmust.spring.version&gt;4.1.1.RELEASE&lt;/edu.kmust.spring.version&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt; </code></pre></font>  &emsp;&emsp;[2]在需要统一的位置，使用${自定义标签名}引用声明的版本号   &emsp;&emsp;例如：   <font size='5'><pre><code>&lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;        &lt;!-- 引用版本号实现统一管理 --&gt;        &lt;version&gt;${edu.kmust.spring.version}&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;   </code></pre></font><p>&emsp;&emsp;[3]properties标签并不只是可以声明版本号，也可以进行其他的设置，凡是需要统一声明后再使用的都可以引用<br><font size='5'></p><pre><code>&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;   </code></pre></font></font></font>    </font>   <h3 id="5、仓库"><a href="#5、仓库" class="headerlink" title="5、仓库"></a>5、仓库</h3><p><font size='4'>(1)分类<br>[1]本地仓库：当前电脑上<br>[2]远程仓库<br>&emsp;&emsp;私服：为当前局域网中的maven工程服务<br>&emsp;&emsp;中央仓库：架设在Internet上为全世界的maven服务<br>&emsp;&emsp;中央仓库的镜像：架设在各个州，为中央仓库分流，减轻负担，提升访问速度   </p><p>(2)仓库中保存的内容<br>&emsp;&emsp;[1]maven自身所诉需要的插件<br>&emsp;&emsp;[2]第三方框架或者工具的jar包<br>&emsp;&emsp;[3]我们自己开发的maven工程</font>   </p><h3 id="6、生命周期-插件-目标"><a href="#6、生命周期-插件-目标" class="headerlink" title="6、生命周期/插件/目标"></a>6、生命周期/插件/目标</h3><p><font size='4'>&emsp;&emsp;各个构建环节的执行顺序，不可打乱，必须按照正确的顺序来执行。<br>&emsp;&emsp;不论执行生命周期的哪一阶段，都是从生命周期最初的位置开始执行的。<br>&emsp;&emsp;插件和目标<br>&emsp;&emsp;&emsp;[1]生命周期的各个阶段仅仅定义了要执行的任务是什么<br>&emsp;&emsp;&emsp;[2]各个阶段和插件的目标是对应的<br>&emsp;&emsp;&emsp;[3]相似的目标又特定的插件完成   </p></font>   <h3 id="7、继承"><a href="#7、继承" class="headerlink" title="7、继承"></a>7、继承</h3><font size='4'>继承可以解决的问题：由于test范围的依赖不能传递，所以必然会分散再各个模块的工程中，很容易造成版本不一致。   需求：统一管理各个模块工程中对某个（例如junit）依赖的版本。   解决思路：将junit的依赖统一提取到父工程中，在子工程中声明junit时不指定版本，就以父工程中的统一设定为准。   <p>具体步骤：<br>[1]创建一个maven的父工程，打包方式为<strong>pom</strong><br><font size='5'></p><pre><code>&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;&lt;artifactId&gt;Parent&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt;</code></pre></font><p>[2]在子工程中声明对父工程的引用<br><font size='5'></p><pre><code>&lt;!-- 子工程中声明父工程 --&gt;&lt;parent&gt;    &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;    &lt;artifactId&gt;Parent&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;!-- 以当前文件为基准的父工程pom.xml文件的相对路径 --&gt;    &lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt;</code></pre></font><p>[3]将子工程的坐标与父工程中相同的部分删除<br>例如：<code>&lt;gourpId&gt;  &lt;/gourpId&gt;</code>等（有黄色波浪下划线的部分）<br>[4]在父工程中统一管理junit的依赖<br><font size='5'></p><pre><code>&lt;!-- 配置依赖的管理 --&gt;&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.9&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;</code></pre></font><p>[5]在子工程中删除junit依赖的版本号部分<br>也就是：<code>&lt;version&gt;  &lt;/version&gt;</code><br>Tips：配置继承后，执行命令时要先安装父工程</p><h3 id="8、聚合"><a href="#8、聚合" class="headerlink" title="8、聚合"></a>8、聚合</h3><p>作用：一键安装各个模块工具<br>在一个总的聚合工具中配置各个参与聚合的模块<br><font size='5'></p><pre><code>&lt;!-- 配置聚合 --&gt;&lt;modules&gt;    &lt;!-- 指定各个子工程的相对路径 --&gt;    &lt;module&gt;../HelloFriend&lt;/module&gt;    &lt;module&gt;../MakeFriends&lt;/module&gt;    &lt;module&gt;../Hello&lt;/module&gt;&lt;/modules&gt;</code></pre></font>   使用方法：在聚合工程的pom.xml上右键 ---> run as ---> maven install</font>   <hr><p><a href="https://www.bilibili.com/video/BV1Pt411y7Rh?p=1" target="_blank" rel="noopener">资料来源</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于反射的知识点的整理</title>
    <link href="/2020/05/07/%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E6%95%B4%E7%90%86/"/>
    <url>/2020/05/07/%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<div align='center' ><font size='6'>关于反射的知识点的整理</font></div><hr><h2 id="关于java-lang-Class的理解"><a href="#关于java-lang-Class的理解" class="headerlink" title="关于java.lang.Class的理解"></a>关于java.lang.Class的理解</h2><font size='4'><h3 id="1、类的加载过程"><a href="#1、类的加载过程" class="headerlink" title="1、类的加载过程"></a>1、类的加载过程</h3><p>&emsp;&emsp;程序在运行过程中通过javac.exe命令之后，会生成一个或者多个字节码文件(以.class结尾)，接着当我们使用java.exe命令对某个字节码文件进行解释编译运行，此时就相当于将某个字节码文件加载到了内存中，此过程称之为类的加载，而加载到内存中的类，我们称之为运行时类，此时的运行时类就作为一个Class的实例存在。换句话说，Class的实例就对应着一个运行时类。</p><h3 id="2、哪些对象可以有Class的对象"><a href="#2、哪些对象可以有Class的对象" class="headerlink" title="2、哪些对象可以有Class的对象"></a>2、哪些对象可以有Class的对象</h3><p>(1)、 interface 接口</p><p>(2)、数组[]</p><p>(3)、enum 枚举</p><p>(4)、primitive type 基本数据类型</p><p>(5)、annotation 注解</p><p>(6)、class：外部类、成员(成员内部类、静态内部类)、局部内部类、匿名内部类</p><p>(7)、void</p><h3 id="3、关于获取Class类的实例的方法"><a href="#3、关于获取Class类的实例的方法" class="headerlink" title="3、关于获取Class类的实例的方法"></a>3、关于获取Class类的实例的方法</h3><p>关于其中使用到的<a href="附录：">^Person</a>类见附录</p><p>(1)、方式一：通过运行时属性来获取</p><pre><code>Class&lt;Person&gt; clazz1 = Person.class;    System.out.println(clazz1);</code></pre><p>(2)、方式二：通过运行时类的对象来获取</p><pre><code>Person p1 = new Person();    Class clazz2 = p1.getClass();       //此方法在Object中声明    System.out.println(clazz2);</code></pre><p>(3)、方式三：通过静态方法forName(String classPath)来获取</p><pre><code>Class clazz3 = Class.forName(&quot;Reflaction.Person&quot;);    System.out.println(clazz3);</code></pre><p>(4)、方式四：通过类的加载ClassLoader来获取</p><pre><code>ClassLoader classLoader = ReflactionTest.class.getClassLoader();    Class&lt;Person&gt; clazz4 = (Class&lt;Person&gt;) classLoader.loadClass(&quot;Reflaction.Person&quot;);    System.out.println(clazz4);</code></pre><h3 id="4、一点点关于数组的小思考"><a href="#4、一点点关于数组的小思考" class="headerlink" title="4、一点点关于数组的小思考"></a>4、一点点关于数组的小思考</h3><pre><code>int[] a = new int[10];int[] b = new int[100];Class a10 = a.getClass();Class b100 = b.getClass();System.out.println(a10 == b100);</code></pre><p>结果为：<strong>true</strong><br>原因是：只要数组的元素类型和维度(一维数组、二维数组这样的)一样，它们为同一个Class<br></font></p><hr><h3 id="以下为Person类的附录："><a href="#以下为Person类的附录：" class="headerlink" title="以下为Person类的附录："></a>以下为Person类的附录：</h3><pre><code>package Reflaction;/** * @author BunnyAndOak0 * */public class Person {        private String name;        public int age;        public String getName() {            return name;        }        public void setName(String name) {            this.name = name;        }        public int getAge() {            return age;        }        public void setAge(int age) {            this.age = age;        }        public Person() {            super();            // TODO Auto-generated constructor stub        }        private Person(String name) {            super();            this.name = name;        }        public Person(String name, int age) {            super();            this.name = name;            this.age = age;        }        @Override        public String toString() {            return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;        }        public void show() {            System.out.println(&quot;我是一个人！&quot;);        }        private String showNation(String nation) {            System.out.println(&quot;我的国籍是：&quot; + nation);            return nation;        }}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2020/05/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <url>/2020/05/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="想写一点关于博客语法的东西"><a href="#想写一点关于博客语法的东西" class="headerlink" title="想写一点关于博客语法的东西"></a>想写一点关于博客语法的东西</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/05/07/hello-world/"/>
    <url>/2020/05/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
